{"title": "How to handle RESTful web Services using Retrofit, OkHttp, Gson, Glide and Coroutines", "byline": "Andrius Baruckis", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>How to handle RESTful web Services using Retrofit, OkHttp, Gson, Glide and Coroutines</h1>\n<section>\n<section data-test-label=\"post-content\">\n<h4 id=\"kriptofolio-app-series-part-5\">Kriptofolio app series \u2014 Part 5</h4><p>These days almost every Android app connects to internet to get/send data. You should definitely learn how to handle RESTful Web Services, as their correct implementation is the core knowledge while creating modern apps.</p><p>This part is going to be complicated. We are going to combine multiple libraries at once to get a working result. I am not going to talk about the native Android way to handle internet requests, because in the real world nobody uses it. Every good app does not try to reinvent the wheel but instead uses the most popular third party libraries to solve common problems. It would be too complicated to recreate the functionality that these well-made libraries have to offer.</p><h3 id=\"series-content\">Series content</h3><ul><li><a href=\"https://www.freecodecamp.org/news/kriptofolio-app-series\">Introduction: A roadmap to build a modern Android app in 2018\u20132019</a></li><li><a href=\"https://www.freecodecamp.org/news/kriptofolio-app-series-part-1\">Part 1: An introduction to the SOLID principles</a></li><li><a href=\"https://www.freecodecamp.org/news/kriptofolio-app-series-part-2\">Part 2: How to start building your Android app: creating Mockups, UI, and XML layouts</a></li><li><a href=\"https://www.freecodecamp.org/news/kriptofolio-app-series-part-3\">Part 3: All about that Architecture: exploring different architecture patterns and how to use them in your app</a></li><li><a href=\"https://www.freecodecamp.org/news/kriptofolio-app-series-part-4\">Part 4: How to implement Dependency Injection in your app with Dagger 2</a></li><li>Part 5: Handle RESTful Web Services using Retrofit, OkHttp, Gson, Glide and Coroutines (you\u2019re here)</li></ul><h3 id=\"what-is-retrofit-okhttp-and-gson\">What is Retrofit, OkHttp and Gson?</h3><p>Retrofit is a REST Client for Java and Android. This library, in my opinion, is the most important one to learn, as it will do the main job. It makes it relatively easy to retrieve and upload JSON (or other structured data) via a REST based webservice.</p><p>In Retrofit you configure which converter is used for the data serialization. Typically to serialize and deserialize objects to and from JSON you use an open-source Java library \u2014 Gson. Also if you need, you can add custom converters to Retrofit to process XML or other protocols.</p><p>For making HTTP requests Retrofit uses the OkHttp library. OkHttp is a pure HTTP/SPDY client responsible for any low-level network operations, caching, requests and responses manipulation. In contrast, Retrofit is a high-level REST abstraction build on top of OkHttp. Retrofit is strongly coupled with OkHttp and makes intensive use of it.</p><p>Now that you know that everything is closely related, we are going to use all these 3 libraries at once. Our first goal is to get all the cryptocurrencies list using Retrofit from the Internet. We will use a special OkHttp interceptor class for CoinMarketCap API authentication when making a call to the server. We will get back a JSON data result and then convert it using the Gson library.</p><h3 id=\"quick-setup-for-retrofit-2-just-to-try-it-first\">Quick setup for Retrofit 2 just to try it first</h3><p>When learning something new, I like to try it out in practice as soon as I can. We will apply a similar approach with Retrofit 2 for you to understand it better more quickly. Don\u2019t worry right now about code quality or any programming principles or optimizations \u2014 we\u2019ll just write some code to make Retrofit 2 work in our project and discuss what it does.</p><p>Follow these steps to set up Retrofit 2 on My Crypto Coins app project:</p><h4 id=\"first-give-internet-permission-for-the-app\"><strong>First, give INTERNET permission for the app</strong></h4><p>We are going to execute HTTP requests on a server accessible via the Internet. Give this permission by adding these lines to your Manifest file:</p><pre tabindex=\"0\"><code>&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.baruckis.mycryptocoins\"&gt;\n\n    &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n    ...\n&lt;/manifest&gt;</code></pre><h4 id=\"then-you-should-add-library-dependencies\"><strong>Then you should add library dependencies</strong></h4><p>Find the latest <a href=\"https://square.github.io/retrofit/\" rel=\"noopener\">Retrofit version</a>. Also you should know that Retrofit doesn\u2019t ship with an integrated JSON converter. Since we will get responses in JSON format, we need to include the converter manually in the dependencies too. We are going to use latest Google\u2019s JSON converter <a href=\"https://github.com/google/gson\" rel=\"noopener\">Gson version</a>. Let\u2019s add these lines to your gradle file:</p><pre tabindex=\"0\"><code>// 3rd party\n// HTTP client - Retrofit with OkHttp\nimplementation \"com.squareup.retrofit2:retrofit:$versions.retrofit\"\n// JSON converter Gson for JSON to Java object mapping\nimplementation \"com.squareup.retrofit2:converter-gson:$versions.retrofit\"</code></pre><p>As you noticed from my comment, the OkHttp dependency is already shipped with the Retrofit 2 dependency. Versions is just a separate gradle file for convenience:</p><pre tabindex=\"0\"><code>def versions = [:]\n\nversions.retrofit = \"2.4.0\"\n\next.versions = versions</code></pre><h4 id=\"next-set-up-the-retrofit-interface\"><strong>Next set up the Retrofit interface</strong></h4><p>It\u2019s an interface that declares our requests and their types. Here we define the API on the client side.</p><pre tabindex=\"0\"><code>/**\n * REST API access points.\n */\ninterface ApiService {\n\n    // The @GET annotation tells retrofit that this request is a get type request.\n    // The string value tells retrofit that the path of this request is\n    // baseUrl + v1/cryptocurrency/listings/latest + query parameter.\n    @GET(\"v1/cryptocurrency/listings/latest\")\n    // Annotation @Query is used to define query parameter for request. Finally the request url will\n    // look like that https://sandbox-api.coinmarketcap.com/v1/cryptocurrency/listings/latest?convert=EUR.\n    fun getAllCryptocurrencies(@Query(\"convert\") currency: String): Call&lt;CryptocurrenciesLatest&gt;\n    // The return type for this function is Call with its type CryptocurrenciesLatest.\n}</code></pre><h4 id=\"and-set-up-the-data-class\"><strong>And set up the data class</strong></h4><p>Data classes are POJOs (Plain Old Java Objects) that represent the responses of the API calls we\u2019re going to make.</p><pre tabindex=\"0\"><code>/**\n * Data class to handle the response from the server.\n */\ndata class CryptocurrenciesLatest(\n        val status: Status,\n        val data: List&lt;Data&gt;\n) {\n\n    data class Data(\n            val id: Int,\n            val name: String,\n            val symbol: String,\n            val slug: String,\n            // The annotation to a model property lets you pass the serialized and deserialized\n            // name as a string. This is useful if you don't want your model class and the JSON\n            // to have identical naming.\n            @SerializedName(\"circulating_supply\")\n            val circulatingSupply: Double,\n            @SerializedName(\"total_supply\")\n            val totalSupply: Double,\n            @SerializedName(\"max_supply\")\n            val maxSupply: Double,\n            @SerializedName(\"date_added\")\n            val dateAdded: String,\n            @SerializedName(\"num_market_pairs\")\n            val numMarketPairs: Int,\n            @SerializedName(\"cmc_rank\")\n            val cmcRank: Int,\n            @SerializedName(\"last_updated\")\n            val lastUpdated: String,\n            val quote: Quote\n    ) {\n\n        data class Quote(\n                // For additional option during deserialization you can specify value or alternative\n                // values. Gson will check the JSON for all names we specify and try to find one to\n                // map it to the annotated property.\n                @SerializedName(value = \"USD\", alternate = [\"AUD\", \"BRL\", \"CAD\", \"CHF\", \"CLP\",\n                    \"CNY\", \"CZK\", \"DKK\", \"EUR\", \"GBP\", \"HKD\", \"HUF\", \"IDR\", \"ILS\", \"INR\", \"JPY\",\n                    \"KRW\", \"MXN\", \"MYR\", \"NOK\", \"NZD\", \"PHP\", \"PKR\", \"PLN\", \"RUB\", \"SEK\", \"SGD\",\n                    \"THB\", \"TRY\", \"TWD\", \"ZAR\"])\n                val currency: Currency\n        ) {\n\n            data class Currency(\n                    val price: Double,\n                    @SerializedName(\"volume_24h\")\n                    val volume24h: Double,\n                    @SerializedName(\"percent_change_1h\")\n                    val percentChange1h: Double,\n                    @SerializedName(\"percent_change_24h\")\n                    val percentChange24h: Double,\n                    @SerializedName(\"percent_change_7d\")\n                    val percentChange7d: Double,\n                    @SerializedName(\"market_cap\")\n                    val marketCap: Double,\n                    @SerializedName(\"last_updated\")\n                    val lastUpdated: String\n            )\n        }\n    }\n\n    data class Status(\n            val timestamp: String,\n            @SerializedName(\"error_code\")\n            val errorCode: Int,\n            @SerializedName(\"error_message\")\n            val errorMessage: String,\n            val elapsed: Int,\n            @SerializedName(\"credit_count\")\n            val creditCount: Int\n    )\n}</code></pre><h4 id=\"create-a-special-interceptor-class-for-authentication-when-making-a-call-to-the-server\"><strong>Create a special interceptor class for authentication when making a call to the server</strong></h4><p>This is the case particular for any API that requires authentication to get a successful response. Interceptors are a powerful way to customize your requests. We are going to intercept the actual request and to add individual request headers, which will validate the call with an API Key provided by <a href=\"https://pro.coinmarketcap.com/\" rel=\"noopener\">CoinMarketCap Professional API Developer Portal</a>. To get yours, you need to register there.</p><pre tabindex=\"0\"><code>/**\n * Interceptor used to intercept the actual request and\n * to supply your API Key in REST API calls via a custom header.\n */\nclass AuthenticationInterceptor : Interceptor {\n\n    override fun intercept(chain: Interceptor.Chain): Response {\n\n        val newRequest = chain.request().newBuilder()\n                // TODO: Use your API Key provided by CoinMarketCap Professional API Developer Portal.\n                .addHeader(\"X-CMC_PRO_API_KEY\", \"CMC_PRO_API_KEY\")\n                .build()\n\n        return chain.proceed(newRequest)\n    }\n}</code></pre><h4 id=\"finally-add-this-code-to-our-activity-to-see-retrofit-working\"><strong>Finally, add this code to our activity to see Retrofit working</strong></h4><p>I wanted to get your hands dirty as soon as possible, so I put everything in one place. This is not the correct way, but it\u2019s the fastest instead just to see a visual result quickly.</p><pre tabindex=\"0\"><code>class AddSearchActivity : AppCompatActivity(), Injectable {\n\n    private lateinit var listView: ListView\n    private lateinit var listAdapter: AddSearchListAdapter\n\n    ...\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        ...\n\n        // Later we will setup Retrofit correctly, but for now we do all in one place just for quick start.\n        setupRetrofitTemporarily()\n    }\n\n    ...\n\n    private fun setupRetrofitTemporarily() {\n\n        // We need to prepare a custom OkHttp client because need to use our custom call interceptor.\n        // to be able to authenticate our requests.\n        val builder = OkHttpClient.Builder()\n        // We add the interceptor to OkHttpClient.\n        // It will add authentication headers to every call we make.\n        builder.interceptors().add(AuthenticationInterceptor())\n        val client = builder.build()\n\n\n        val api = Retrofit.Builder() // Create retrofit builder.\n                .baseUrl(\"https://sandbox-api.coinmarketcap.com/\") // Base url for the api has to end with a slash.\n                .addConverterFactory(GsonConverterFactory.create()) // Use GSON converter for JSON to POJO object mapping.\n                .client(client) // Here we set the custom OkHttp client we just created.\n                .build().create(ApiService::class.java) // We create an API using the interface we defined.\n\n\n        val adapterData: MutableList&lt;Cryptocurrency&gt; = ArrayList&lt;Cryptocurrency&gt;()\n\n        val currentFiatCurrencyCode = \"EUR\"\n\n        // Let's make asynchronous network request to get all latest cryptocurrencies from the server.\n        // For query parameter we pass \"EUR\" as we want to get prices in euros.\n        val call = api.getAllCryptocurrencies(\"EUR\")\n        val result = call.enqueue(object : Callback&lt;CryptocurrenciesLatest&gt; {\n\n            // You will always get a response even if something wrong went from the server.\n            override fun onFailure(call: Call&lt;CryptocurrenciesLatest&gt;, t: Throwable) {\n\n                Snackbar.make(findViewById(android.R.id.content),\n                        // Throwable will let us find the error if the call failed.\n                        \"Call failed! \" + t.localizedMessage,\n                        Snackbar.LENGTH_INDEFINITE).show()\n            }\n\n            override fun onResponse(call: Call&lt;CryptocurrenciesLatest&gt;, response: Response&lt;CryptocurrenciesLatest&gt;) {\n\n                // Check if the response is successful, which means the request was successfully\n                // received, understood, accepted and returned code in range [200..300).\n                if (response.isSuccessful) {\n\n                    // If everything is OK, let the user know that.\n                    Toast.makeText(this@AddSearchActivity, \"Call OK.\", Toast.LENGTH_LONG).show();\n\n                    // Than quickly map server response data to the ListView adapter.\n                    val cryptocurrenciesLatest: CryptocurrenciesLatest? = response.body()\n                    cryptocurrenciesLatest!!.data.forEach {\n                        val cryptocurrency = Cryptocurrency(it.name, it.cmcRank.toShort(),\n                                0.0, it.symbol, currentFiatCurrencyCode, it.quote.currency.price,\n                                0.0, it.quote.currency.percentChange1h,\n                                it.quote.currency.percentChange7d, it.quote.currency.percentChange24h,\n                                0.0)\n                        adapterData.add(cryptocurrency)\n                    }\n\n                    listView.visibility = View.VISIBLE\n                    listAdapter.setData(adapterData)\n\n                }\n                // Else if the response is unsuccessful it will be defined by some special HTTP\n                // error code, which we can show for the user.\n                else Snackbar.make(findViewById(android.R.id.content),\n                        \"Call error with HTTP status code \" + response.code() + \"!\",\n                        Snackbar.LENGTH_INDEFINITE).show()\n\n            }\n\n        })\n\n    }\n\n   ...\n}</code></pre><p>You can explore the code <a href=\"https://github.com/baruckis/Kriptofolio/tree/4d7946705b8c4dc2db3775bcc000d2918f8f1b73\" rel=\"noopener\">here</a>. Remember this is only an initial simplified implementation version for you to get the idea better.</p><h3 id=\"final-correct-setup-for-retrofit-2-with-okhttp-3-and-gson\">Final correct setup for Retrofit 2 with OkHttp 3 and Gson</h3><p>Ok after a quick experiment, it is time to bring this Retrofit implementation to the next level. We already got the data successfully but not correctly. We are missing the states like loading, error and success. Our code is mixed without separation of concerns. It\u2019s a common mistake to write all your code in an activity or a fragment. Our activity class is UI based and should only contain logic that handles UI and operating system interactions.</p><p>Actually, after this quick setup, I worked a lot and made many changes. There is no point to put all the code that was changed in the article. Better instead you should browse the final Part 5 code repo <a href=\"https://github.com/baruckis/Kriptofolio/tree/Part-5\" rel=\"noopener\">here</a>. I have commented everything very well and my code should be clear for you to understand. But I am going to talk about most important things I have done and why I did them.</p><p>The first step to improve was to start using Dependency Injection. Remember from the <a href=\"https://www.freecodecamp.org/news/kriptofolio-app-series-part-4\">previous part</a> we already have Dagger 2 implemented inside the project correctly. So I used it for the Retrofit setup.</p><pre tabindex=\"0\"><code>/**\n * AppModule will provide app-wide dependencies for a part of the application.\n * It should initialize objects used across our application, such as Room database, Retrofit, Shared Preference, etc.\n */\n@Module(includes = [ViewModelsModule::class])\nclass AppModule() {\n    ...\n\n    @Provides\n    @Singleton\n    fun provideHttpClient(): OkHttpClient {\n        // We need to prepare a custom OkHttp client because need to use our custom call interceptor.\n        // to be able to authenticate our requests.\n        val builder = OkHttpClient.Builder()\n        // We add the interceptor to OkHttpClient.\n        // It will add authentication headers to every call we make.\n        builder.interceptors().add(AuthenticationInterceptor())\n\n        // Configure this client not to retry when a connectivity problem is encountered.\n        builder.retryOnConnectionFailure(false)\n\n        // Log requests and responses.\n        // Add logging as the last interceptor, because this will also log the information which\n        // you added or manipulated with previous interceptors to your request.\n        builder.interceptors().add(HttpLoggingInterceptor().apply {\n            // For production environment to enhance apps performance we will be skipping any\n            // logging operation. We will show logs just for debug builds.\n            level = if (BuildConfig.DEBUG) HttpLoggingInterceptor.Level.BODY else HttpLoggingInterceptor.Level.NONE\n        })\n        return builder.build()\n    }\n\n    @Provides\n    @Singleton\n    fun provideApiService(httpClient: OkHttpClient): ApiService {\n        return Retrofit.Builder() // Create retrofit builder.\n                .baseUrl(API_SERVICE_BASE_URL) // Base url for the api has to end with a slash.\n                .addConverterFactory(GsonConverterFactory.create()) // Use GSON converter for JSON to POJO object mapping.\n                .addCallAdapterFactory(LiveDataCallAdapterFactory())\n                .client(httpClient) // Here we set the custom OkHttp client we just created.\n                .build().create(ApiService::class.java) // We create an API using the interface we defined.\n    }\n\n    ...\n}</code></pre><p>Now as you see, Retrofit is separated from the activity class as it should be. It will be initialized only once and used app-wide.</p><p>As you may have noticed while creating the Retrofit builder instance, we added a special Retrofit calls adapter using <code>addCallAdapterFactory</code>. By default, Retrofit returns a <code>Call&lt;T&gt;</code>, but for our project we require it to return a <code>LiveData&lt;T&gt;</code> type. In order to do that we need to add <code>LiveDataCallAdapter</code> by using <code>LiveDataCallAdapterFactory</code>.</p><pre tabindex=\"0\"><code>/**\n * A Retrofit adapter that converts the Call into a LiveData of ApiResponse.\n * @param &lt;R&gt;\n&lt;/R&gt; */\nclass LiveDataCallAdapter&lt;R&gt;(private val responseType: Type) :\n        CallAdapter&lt;R, LiveData&lt;ApiResponse&lt;R&gt;&gt;&gt; {\n\n    override fun responseType() = responseType\n\n    override fun adapt(call: Call&lt;R&gt;): LiveData&lt;ApiResponse&lt;R&gt;&gt; {\n        return object : LiveData&lt;ApiResponse&lt;R&gt;&gt;() {\n            private var started = AtomicBoolean(false)\n            override fun onActive() {\n                super.onActive()\n                if (started.compareAndSet(false, true)) {\n                    call.enqueue(object : Callback&lt;R&gt; {\n                        override fun onResponse(call: Call&lt;R&gt;, response: Response&lt;R&gt;) {\n                            postValue(ApiResponse.create(response))\n                        }\n\n                        override fun onFailure(call: Call&lt;R&gt;, throwable: Throwable) {\n                            postValue(ApiResponse.create(throwable))\n                        }\n                    })\n                }\n            }\n        }\n    }\n}</code></pre><pre tabindex=\"0\"><code>class LiveDataCallAdapterFactory : CallAdapter.Factory() {\n    override fun get(\n            returnType: Type,\n            annotations: Array&lt;Annotation&gt;,\n            retrofit: Retrofit\n    ): CallAdapter&lt;*, *&gt;? {\n        if (CallAdapter.Factory.getRawType(returnType) != LiveData::class.java) {\n            return null\n        }\n        val observableType = CallAdapter.Factory.getParameterUpperBound(0, returnType as ParameterizedType)\n        val rawObservableType = CallAdapter.Factory.getRawType(observableType)\n        if (rawObservableType != ApiResponse::class.java) {\n            throw IllegalArgumentException(\"type must be a resource\")\n        }\n        if (observableType !is ParameterizedType) {\n            throw IllegalArgumentException(\"resource must be parameterized\")\n        }\n        val bodyType = CallAdapter.Factory.getParameterUpperBound(0, observableType)\n        return LiveDataCallAdapter&lt;Any&gt;(bodyType)\n    }\n}</code></pre><p>Now we will get <code>LiveData&lt;T&gt;</code> instead of <code>Call&lt;T&gt;</code> as the return type from Retrofit service methods defined in the <code>ApiService</code> interface.</p><p>Another important step to make is to start using the Repository pattern. I have talked about it in <a href=\"https://www.freecodecamp.org/news/kriptofolio-app-series-part-3\">Part 3</a>. Check out our MVVM architecture schema from that post to remember where it goes.</p><figure><img alt=\"qlI48NPPMqMbOeV47Cpkxop4nhW8RhgfTtjO\" height=\"640\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/qlI48NPPMqMbOeV47Cpkxop4nhW8RhgfTtjO\" width=\"800\"/></figure><p>As you see in the picture, Repository is a separate layer for the data. It\u2019s our single source of contact for getting or sending data. When we use Repository, we are following the separation of concerns principle. We can have different data sources (like in our case persistent data from an SQLite database and data from web services), but Repository is always going to be single source of truth for all app data.</p><p>Instead of communicating with our Retrofit implementation directly, we are going to use Repository for that. For each kind of entity, we are going to have a separate Repository.</p><pre tabindex=\"0\"><code>/**\n * The class for managing multiple data sources.\n */\n@Singleton\nclass CryptocurrencyRepository @Inject constructor(\n        private val context: Context,\n        private val appExecutors: AppExecutors,\n        private val myCryptocurrencyDao: MyCryptocurrencyDao,\n        private val cryptocurrencyDao: CryptocurrencyDao,\n        private val api: ApiService,\n        private val sharedPreferences: SharedPreferences\n) {\n\n    // Just a simple helper variable to store selected fiat currency code during app lifecycle.\n    // It is needed for main screen currency spinner. We set it to be same as in shared preferences.\n    var selectedFiatCurrencyCode: String = getCurrentFiatCurrencyCode()\n\n\n    ...\n  \n\n    // The Resource wrapping of LiveData is useful to update the UI based upon the state.\n    fun getAllCryptocurrencyLiveDataResourceList(fiatCurrencyCode: String, shouldFetch: Boolean = false, callDelay: Long = 0): LiveData&lt;Resource&lt;List&lt;Cryptocurrency&gt;&gt;&gt; {\n        return object : NetworkBoundResource&lt;List&lt;Cryptocurrency&gt;, CoinMarketCap&lt;List&lt;CryptocurrencyLatest&gt;&gt;&gt;(appExecutors) {\n\n            // Here we save the data fetched from web-service.\n            override fun saveCallResult(item: CoinMarketCap&lt;List&lt;CryptocurrencyLatest&gt;&gt;) {\n\n                val list = getCryptocurrencyListFromResponse(fiatCurrencyCode, item.data, item.status?.timestamp)\n\n                cryptocurrencyDao.reloadCryptocurrencyList(list)\n                myCryptocurrencyDao.reloadMyCryptocurrencyList(list)\n            }\n\n            // Returns boolean indicating if to fetch data from web or not, true means fetch the data from web.\n            override fun shouldFetch(data: List&lt;Cryptocurrency&gt;?): Boolean {\n                return data == null || shouldFetch\n            }\n\n            override fun fetchDelayMillis(): Long {\n                return callDelay\n            }\n\n            // Contains the logic to get data from the Room database.\n            override fun loadFromDb(): LiveData&lt;List&lt;Cryptocurrency&gt;&gt; {\n\n                return Transformations.switchMap(cryptocurrencyDao.getAllCryptocurrencyLiveDataList()) { data -&gt;\n                    if (data.isEmpty()) {\n                        AbsentLiveData.create()\n                    } else {\n                        cryptocurrencyDao.getAllCryptocurrencyLiveDataList()\n                    }\n                }\n            }\n\n            // Contains the logic to get data from web-service using Retrofit.\n            override fun createCall(): LiveData&lt;ApiResponse&lt;CoinMarketCap&lt;List&lt;CryptocurrencyLatest&gt;&gt;&gt;&gt; = api.getAllCryptocurrencies(fiatCurrencyCode)\n\n        }.asLiveData()\n    }\n\n\n    ...\n\n\n    fun getCurrentFiatCurrencyCode(): String {\n        return sharedPreferences.getString(context.resources.getString(R.string.pref_fiat_currency_key), context.resources.getString(R.string.pref_default_fiat_currency_value))\n                ?: context.resources.getString(R.string.pref_default_fiat_currency_value)\n    }\n\n\n    ...\n\n\n    private fun getCryptocurrencyListFromResponse(fiatCurrencyCode: String, responseList: List&lt;CryptocurrencyLatest&gt;?, timestamp: Date?): ArrayList&lt;Cryptocurrency&gt; {\n\n        val cryptocurrencyList: MutableList&lt;Cryptocurrency&gt; = ArrayList()\n\n        responseList?.forEach {\n            val cryptocurrency = Cryptocurrency(it.id, it.name, it.cmcRank.toShort(),\n                    it.symbol, fiatCurrencyCode, it.quote.currency.price,\n                    it.quote.currency.percentChange1h,\n                    it.quote.currency.percentChange7d, it.quote.currency.percentChange24h, timestamp)\n            cryptocurrencyList.add(cryptocurrency)\n        }\n\n        return cryptocurrencyList as ArrayList&lt;Cryptocurrency&gt;\n    }\n\n}</code></pre><p>As you notice in the <code>CryptocurrencyRepository</code> class code, I am using the <code>NetworkBoundResource</code> abstract class. What is it and why do we need it?</p><p><code>NetworkBoundResource</code> is a small but very important helper class that will allow us to maintain a synchronization between the local database and the web service. Our goal is to build a modern application that will work smoothly even when our device is offline. Also with the help of this class we will be able to present different network states like errors or loading for the user visually.</p><p><code>NetworkBoundResource</code> starts by observing the database for the resource. When the entry is loaded from the database for the first time, it checks whether the result is good enough to be dispatched or if it should be re-fetched from the network. Note that both of these situations can happen at the same time, given that you probably want to show cached data while updating it from the network.</p><p>If the network call completes successfully, it saves the response into the database and re-initializes the stream. If the network request fails, the <code>NetworkBoundResource</code> dispatches a failure directly.</p><pre tabindex=\"0\"><code>/**\n * A generic class that can provide a resource backed by both the sqlite database and the network.\n *\n *\n * You can read more about it in the [Architecture\n * Guide](https://developer.android.com/arch).\n * @param &lt;ResultType&gt; - Type for the Resource data.\n * @param &lt;RequestType&gt; - Type for the API response.\n&lt;/RequestType&gt;&lt;/ResultType&gt; */\n\n// It defines two type parameters, ResultType and RequestType,\n// because the data type returned from the API might not match the data type used locally.\nabstract class NetworkBoundResource&lt;ResultType, RequestType&gt;\n@MainThread constructor(private val appExecutors: AppExecutors) {\n\n    // The final result LiveData.\n    private val result = MediatorLiveData&lt;Resource&lt;ResultType&gt;&gt;()\n\n    init {\n        // Send loading state to UI.\n        result.value = Resource.loading(null)\n        @Suppress(\"LeakingThis\")\n        val dbSource = loadFromDb()\n        result.addSource(dbSource) { data -&gt;\n            result.removeSource(dbSource)\n            if (shouldFetch(data)) {\n                fetchFromNetwork(dbSource)\n            } else {\n                result.addSource(dbSource) { newData -&gt;\n                    setValue(Resource.successDb(newData))\n                }\n            }\n        }\n    }\n\n    @MainThread\n    private fun setValue(newValue: Resource&lt;ResultType&gt;) {\n        if (result.value != newValue) {\n            result.value = newValue\n        }\n    }\n\n    // Fetch the data from network and persist into DB and then send it back to UI.\n    private fun fetchFromNetwork(dbSource: LiveData&lt;ResultType&gt;) {\n        val apiResponse = createCall()\n        // We re-attach dbSource as a new source, it will dispatch its latest value quickly.\n        result.addSource(dbSource) { newData -&gt;\n            setValue(Resource.loading(newData))\n        }\n\n        // Create inner function as we want to delay it.\n        fun fetch() {\n            result.addSource(apiResponse) { response -&gt;\n                result.removeSource(apiResponse)\n                result.removeSource(dbSource)\n                when (response) {\n                    is ApiSuccessResponse -&gt; {\n                        appExecutors.diskIO().execute {\n                            saveCallResult(processResponse(response))\n                            appExecutors.mainThread().execute {\n                                // We specially request a new live data,\n                                // otherwise we will get immediately last cached value,\n                                // which may not be updated with latest results received from network.\n                                result.addSource(loadFromDb()) { newData -&gt;\n                                    setValue(Resource.successNetwork(newData))\n                                }\n                            }\n                        }\n                    }\n                    is ApiEmptyResponse -&gt; {\n                        appExecutors.mainThread().execute {\n                            // reload from disk whatever we had\n                            result.addSource(loadFromDb()) { newData -&gt;\n                                setValue(Resource.successDb(newData))\n                            }\n                        }\n                    }\n                    is ApiErrorResponse -&gt; {\n                        onFetchFailed()\n                        result.addSource(dbSource) { newData -&gt;\n                            setValue(Resource.error(response.errorMessage, newData))\n                        }\n                    }\n                }\n            }\n        }\n\n        // Add delay before call if needed.\n        val delay = fetchDelayMillis()\n        if (delay &gt; 0) {\n            Handler().postDelayed({ fetch() }, delay)\n        } else fetch()\n\n    }\n\n    // Called when the fetch fails. The child class may want to reset components\n    // like rate limiter.\n    protected open fun onFetchFailed() {}\n\n    // Returns a LiveData object that represents the resource that's implemented\n    // in the base class.\n    fun asLiveData() = result as LiveData&lt;Resource&lt;ResultType&gt;&gt;\n\n    @WorkerThread\n    protected open fun processResponse(response: ApiSuccessResponse&lt;RequestType&gt;) = response.body\n\n    // Called to save the result of the API response into the database.\n    @WorkerThread\n    protected abstract fun saveCallResult(item: RequestType)\n\n    // Called with the data in the database to decide whether to fetch\n    // potentially updated data from the network.\n    @MainThread\n    protected abstract fun shouldFetch(data: ResultType?): Boolean\n\n    // Make a call to the server after some delay for better user experience.\n    protected open fun fetchDelayMillis(): Long = 0\n\n    // Called to get the cached data from the database.\n    @MainThread\n    protected abstract fun loadFromDb(): LiveData&lt;ResultType&gt;\n\n    // Called to create the API call.\n    @MainThread\n    protected abstract fun createCall(): LiveData&lt;ApiResponse&lt;RequestType&gt;&gt;\n}</code></pre><p>Under the hood, the <code>NetworkBoundResource</code> class is made by using MediatorLiveData and its ability to observe multiple LiveData sources at once. Here we have two LiveData sources: the database and the network call response. Both of those LiveData are wrapped into one MediatorLiveData which is exposed by <code>NetworkBoundResource</code>.</p><figure><img alt=\"qbNZeVc-RHe54xa9LSZMOfzmmrBA9rXzhGYo\" height=\"465\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/qbNZeVc-RHe54xa9LSZMOfzmmrBA9rXzhGYo\" width=\"534\"/><figcaption>NetworkBoundResource</figcaption></figure><p>Let\u2019s take a closer look how the <code>NetworkBoundResource</code> will work in our app. Imagine the user will launch the app and click on a floating action button on the bottom right corner. The app will launch the add crypto coins screen. Now we can analyze <code>NetworkBoundResource</code>'s usage inside it.</p><p>If the app is freshly installed and it is its first launch, then there will not be any data stored inside the local database. Because there is no data to show, a loading progress bar UI will be shown. Meanwhile the app is going to make a request call to the server via a web service to get all the cryptocurrencies list.</p><p>If the response is unsuccessful then the error message UI will be shown with the ability to retry a call by pressing a button. When a request call is successful at last, then the response data will be saved to a local SQLite database.</p><p>If we come back to the same screen the next time, the app will load data from the database instead of making a call to the internet again. But the user can ask for a new data update by implementing pull-to-refresh functionality. Old data information will be shown whilst the network call is happening. All this is done with the help of <code>NetworkBoundResource</code>.</p><p>Another class used in our Repository and <code>LiveDataCallAdapter</code> where all the \"magic\" happens is <code>ApiResponse</code>. Actually <code>ApiResponse</code> is just a simple common wrapper around the <code>Retrofit2.Response</code> class that converts each response to an instance of LiveData.</p><pre tabindex=\"0\"><code>/**\n * Common class used by API responses. ApiResponse is a simple wrapper around the Retrofit2.Call\n * class that convert responses to instances of LiveData.\n * @param &lt;CoinMarketCapType&gt; the type of the response object\n&lt;/T&gt; */\n@Suppress(\"unused\") // T is used in extending classes\nsealed class ApiResponse&lt;CoinMarketCapType&gt; {\n    companion object {\n        fun &lt;CoinMarketCapType&gt; create(error: Throwable): ApiErrorResponse&lt;CoinMarketCapType&gt; {\n            return ApiErrorResponse(error.message ?: \"Unknown error.\")\n        }\n\n        fun &lt;CoinMarketCapType&gt; create(response: Response&lt;CoinMarketCapType&gt;): ApiResponse&lt;CoinMarketCapType&gt; {\n            return if (response.isSuccessful) {\n                val body = response.body()\n                if (body == null || response.code() == 204) {\n                    ApiEmptyResponse()\n                } else {\n                    ApiSuccessResponse(body = body)\n                }\n            } else {\n\n                // Convert error response to JSON object.\n                val gson = Gson()\n                val type = object : TypeToken&lt;CoinMarketCap&lt;CoinMarketCapType&gt;&gt;() {}.type\n                val errorResponse: CoinMarketCap&lt;CoinMarketCapType&gt; = gson.fromJson(response.errorBody()!!.charStream(), type)\n\n                val msg = errorResponse.status?.errorMessage ?: errorResponse.message\n                val errorMsg = if (msg.isNullOrEmpty()) {\n                    response.message()\n                } else {\n                    msg\n                }\n                ApiErrorResponse(errorMsg ?: \"Unknown error.\")\n            }\n        }\n    }\n}\n\n/**\n * Separate class for HTTP 204 resposes so that we can make ApiSuccessResponse's body non-null.\n */\nclass ApiEmptyResponse&lt;CoinMarketCapType&gt; : ApiResponse&lt;CoinMarketCapType&gt;()\n\ndata class ApiSuccessResponse&lt;CoinMarketCapType&gt;(val body: CoinMarketCapType) : ApiResponse&lt;CoinMarketCapType&gt;()\n\ndata class ApiErrorResponse&lt;CoinMarketCapType&gt;(val errorMessage: String) : ApiResponse&lt;CoinMarketCapType&gt;()</code></pre><p>Inside this wrapper class, if our response has an error, we use the Gson library to convert the error to a JSON object. However, if the response was successful, then the Gson converter for JSON to POJO object mapping is used. We already added it when creating the retrofit builder instance with <code>GsonConverterFactory</code> inside the Dagger <code>AppModule</code> function <code>provideApiService</code>.</p><h3 id=\"glide-for-image-loading\">Glide for image loading</h3><p><a href=\"https://github.com/huyn/glide\" rel=\"noopener\">What is Glide</a>? From the docs:</p><blockquote>Glide is a fast and efficient open source media management and image loading framework for Android that wraps media decoding, memory and disk caching, and resource pooling into a simple and easy to use interface.</blockquote><blockquote>Glide\u2019s primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but it is also effective for almost any case where you need to fetch, resize, and display a remote image.</blockquote><p>Sounds like a complicated library which offers many useful features that you would not want to develop all by yourself. In My Crypto Coins app, we have several list screens where we need to show multiple cryptocurrency logos \u2014 pictures taken from the internet all at once \u2014 and still ensure a smooth scrolling experience for the user. So this library fits our needs perfectly. Also this library is very popular among Android developers.</p><p>Steps to setup Glide on My Crypto Coins app project:</p><h4 id=\"declare-dependencies\"><strong>Declare dependencies</strong></h4><p>Get the latest <a href=\"https://bumptech.github.io/glide\" rel=\"noopener\">Glide version</a>. Again versions is a separate file <code>versions.gradle</code> for the project.</p><pre tabindex=\"0\"><code>// Glide\nimplementation \"com.github.bumptech.glide:glide:$versions.glide\"\nkapt \"com.github.bumptech.glide:compiler:$versions.glide\"\n// Glide's OkHttp3 integration.\nimplementation \"com.github.bumptech.glide:okhttp3-integration:$versions.glide\"+\"@aar\"</code></pre><p>Because we want to use the networking library OkHttp in our project for all network operations, we need to include the specific Glide integration for it instead of the default one. Also since Glide is going to perform a network request to load images via the internet, we need to include the permission <code>INTERNET</code> in our <code>AndroidManifest.xml</code> file \u2014 but we already did that with the Retrofit setup.</p><h4 id=\"create-appglidemodule\"><strong>Create AppGlideModule</strong></h4><p>Glide v4, which we will be using, offers a generated API for Applications. It will use an annotation processor to generate an API that allows applications to extend Glide\u2019s API and include components provided by integration libraries. For any app to access the generated Glide API we need to include an appropriately annotated <code>AppGlideModule</code> implementation. There can be only a single implementation of the generated API and only one <code>AppGlideModule</code> per application.</p><p>Let\u2019s create a class extending <code>AppGlideModule</code> somewhere in your app project:</p><pre tabindex=\"0\"><code>/**\n * Glide v4 uses an annotation processor to generate an API that allows applications to access all\n * options in RequestBuilder, RequestOptions and any included integration libraries in a single\n * fluent API.\n *\n * The generated API serves two purposes:\n * Integration libraries can extend Glide\u2019s API with custom options.\n * Applications can extend Glide\u2019s API by adding methods that bundle commonly used options.\n *\n * Although both of these tasks can be accomplished by hand by writing custom subclasses of\n * RequestOptions, doing so is challenging and produces a less fluent API.\n */\n@GlideModule\nclass AppGlideModule : AppGlideModule()</code></pre><p>Even if our application is not changing any additional settings or implementing any methods in <code>AppGlideModule</code>, we still need to have its implementation to use Glide. You're not required to implement any of the methods in <code>AppGlideModule</code> for the API to be generated. You can leave the class blank as long as it extends <code>AppGlideModule</code> and is annotated with <code>@GlideModule</code>.</p><h4 id=\"use-glide-generated-api\"><strong>Use Glide-generated API</strong></h4><p>When using <code>AppGlideModule</code>, applications can use the API by starting all loads with <code>GlideApp.with()</code>. This is the code that shows how I have used Glide to load and show cryptocurrency logos in the add crypto coins screen all cryptocurrencies list.</p><pre tabindex=\"0\"><code>class AddSearchListAdapter(val context: Context, private val cryptocurrencyClickCallback: ((Cryptocurrency) -&gt; Unit)?) : BaseAdapter() {\n\n    ...\n\n    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {\n        ...\n\n        val itemBinding: ActivityAddSearchListItemBinding\n\n        ...\n\n        // We make an Uri of image that we need to load. Every image unique name is its id.\n        val imageUri = Uri.parse(CRYPTOCURRENCY_IMAGE_URL).buildUpon()\n                .appendPath(CRYPTOCURRENCY_IMAGE_SIZE_PX)\n                .appendPath(cryptocurrency.id.toString() + CRYPTOCURRENCY_IMAGE_FILE)\n                .build()\n\n        // Glide generated API from AppGlideModule.\n        GlideApp\n                // We need to provide context to make a call.\n                .with(itemBinding.root)\n                // Here you specify which image should be loaded by providing Uri.\n                .load(imageUri)\n                // The way you combine and execute multiple transformations.\n                // WhiteBackground is our own implemented custom transformation.\n                // CircleCrop is default transformation that Glide ships with.\n                .transform(MultiTransformation(WhiteBackground(), CircleCrop()))\n                // The target ImageView your image is supposed to get displayed in.\n                .into(itemBinding.itemImageIcon.imageview_front)\n\n        ...\n\n        return itemBinding.root\n    }\n\n    ...\n\n}</code></pre><p>As you see, you can start using Glide with just few lines of code and let it do all the hard work for you. It is pretty straightforward.</p><h3 id=\"kotlin-coroutines\">Kotlin Coroutines</h3><p>While building this app, we are going to face situations when we will run time consuming tasks such as writing data to a database or reading from it, fetching data from the network and other. All these common tasks take longer to complete than allowed by the Android framework\u2019s main thread.</p><p>The main thread is a single thread that handles all updates to the UI. Developers are required not to block it to avoid the app freezing or even crashing with an Application Not Responding dialog. Kotlin coroutines is going to solve this problem for us by introducing main thread safety. It is the last missing piece that we want to add for My Crypto Coins app.</p><p>Coroutines are a Kotlin feature that convert async callbacks for long-running tasks, such as database or network access, into sequential code. With coroutines, you can write asynchronous code, which was traditionally written using the Callback pattern, using a synchronous style. The return value of a function will provide the result of the asynchronous call. Code written sequentially is typically easier to read, and can even use language features such as exceptions.</p><p>So we are going to use coroutines everywhere in this app where we need to wait until a result is available from a long-running task and than continue execution. Let\u2019s see one exact implementation for our ViewModel where we will retry getting the latest data from the server for our cryptocurrencies presented on the main screen.</p><p>First add coroutines to the project:</p><pre tabindex=\"0\"><code>// Coroutines support libraries for Kotlin.\n\n// Dependencies for coroutines.\nimplementation \"org.jetbrains.kotlinx:kotlinx-coroutines-core:$versions.coroutines\"\n\n// Dependency is for the special UI context that can be passed to coroutine builders that use\n// the main thread dispatcher to dispatch events on the main thread.\nimplementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:$versions.coroutines\"</code></pre><p>Then we will create abstract class which will become the base class to be used for any ViewModel that needs to have common functionality like coroutines in our case:</p><pre tabindex=\"0\"><code>abstract class BaseViewModel : ViewModel() {\n\n    // In Kotlin, all coroutines run inside a CoroutineScope.\n    // A scope controls the lifetime of coroutines through its job.\n    private val viewModelJob = Job()\n    // Since uiScope has a default dispatcher of Dispatchers.Main, this coroutine will be launched\n    // in the main thread.\n    val uiScope = CoroutineScope(Dispatchers.Main + viewModelJob)\n\n\n    // onCleared is called when the ViewModel is no longer used and will be destroyed.\n    // This typically happens when the user navigates away from the Activity or Fragment that was\n    // using the ViewModel.\n    override fun onCleared() {\n        super.onCleared()\n        // When you cancel the job of a scope, it cancels all coroutines started in that scope.\n        // It's important to cancel any coroutines that are no longer required to avoid unnecessary\n        // work and memory leaks.\n        viewModelJob.cancel()\n    }\n}</code></pre><p>Here we create specific coroutine scope, which will control the lifetime of coroutines through its job. As you see, scope allows you to specify a default dispatcher that controls which thread runs a coroutine. When the ViewModel is no longer used, we cancel <code>viewModelJob</code> and with that every coroutine started by <code>uiScope</code> will be cancelled as well.</p><p>Finally, implement the retry functionality:</p><pre tabindex=\"0\"><code>/**\n * The ViewModel class is designed to store and manage UI-related data in a lifecycle conscious way.\n * The ViewModel class allows data to survive configuration changes such as screen rotations.\n */\n\n// ViewModel will require a CryptocurrencyRepository so we add @Inject code into ViewModel constructor.\nclass MainViewModel @Inject constructor(val context: Context, val cryptocurrencyRepository: CryptocurrencyRepository) : BaseViewModel() {\n\n    ...\n\n    val mediatorLiveDataMyCryptocurrencyResourceList = MediatorLiveData&lt;Resource&lt;List&lt;MyCryptocurrency&gt;&gt;&gt;()\n    private var liveDataMyCryptocurrencyResourceList: LiveData&lt;Resource&lt;List&lt;MyCryptocurrency&gt;&gt;&gt;\n    private val liveDataMyCryptocurrencyList: LiveData&lt;List&lt;MyCryptocurrency&gt;&gt;\n\n    ...\n\n    // This is additional helper variable to deal correctly with currency spinner and preference.\n    // It is kept inside viewmodel not to be lost because of fragment/activity recreation.\n    var newSelectedFiatCurrencyCode: String? = null\n\n    // Helper variable to store state of swipe refresh layout.\n    var isSwipeRefreshing: Boolean = false\n\n\n    init {\n        ...\n\n        // Set a resource value for a list of cryptocurrencies that user owns.\n        liveDataMyCryptocurrencyResourceList = cryptocurrencyRepository.getMyCryptocurrencyLiveDataResourceList(cryptocurrencyRepository.getCurrentFiatCurrencyCode())\n\n\n        // Declare additional variable to be able to reload data on demand.\n        mediatorLiveDataMyCryptocurrencyResourceList.addSource(liveDataMyCryptocurrencyResourceList) {\n            mediatorLiveDataMyCryptocurrencyResourceList.value = it\n        }\n\n        ...\n    }\n\n   ...\n\n    /**\n     * On retry we need to run sequential code. First we need to get owned crypto coins ids from\n     * local database, wait for response and only after it use these ids to make a call with\n     * retrofit to get updated owned crypto values. This can be done using Kotlin Coroutines.\n     */\n    fun retry(newFiatCurrencyCode: String? = null) {\n\n        // Here we store new selected currency as additional variable or reset it.\n        // Later if call to server is unsuccessful we will reuse it for retry functionality.\n        newSelectedFiatCurrencyCode = newFiatCurrencyCode\n\n        // Launch a coroutine in uiScope.\n        uiScope.launch {\n            // Make a call to the server after some delay for better user experience.\n            updateMyCryptocurrencyList(newFiatCurrencyCode, SERVER_CALL_DELAY_MILLISECONDS)\n        }\n    }\n\n    // Refresh the data from local database.\n    fun refreshMyCryptocurrencyResourceList() {\n        refreshMyCryptocurrencyResourceList(cryptocurrencyRepository.getMyCryptocurrencyLiveDataResourceList(cryptocurrencyRepository.getCurrentFiatCurrencyCode()))\n    }\n\n    // To implement a manual refresh without modifying your existing LiveData logic.\n    private fun refreshMyCryptocurrencyResourceList(liveData: LiveData&lt;Resource&lt;List&lt;MyCryptocurrency&gt;&gt;&gt;) {\n        mediatorLiveDataMyCryptocurrencyResourceList.removeSource(liveDataMyCryptocurrencyResourceList)\n        liveDataMyCryptocurrencyResourceList = liveData\n        mediatorLiveDataMyCryptocurrencyResourceList.addSource(liveDataMyCryptocurrencyResourceList)\n        { mediatorLiveDataMyCryptocurrencyResourceList.value = it }\n    }\n\n    private suspend fun updateMyCryptocurrencyList(newFiatCurrencyCode: String? = null, callDelay: Long = 0) {\n\n        val fiatCurrencyCode: String = newFiatCurrencyCode\n                ?: cryptocurrencyRepository.getCurrentFiatCurrencyCode()\n\n        isSwipeRefreshing = true\n\n        // The function withContext is a suspend function. The withContext immediately shifts\n        // execution of the block into different thread inside the block, and back when it\n        // completes. IO dispatcher is suitable for execution the network requests in IO thread.\n        val myCryptocurrencyIds = withContext(Dispatchers.IO) {\n            // Suspend until getMyCryptocurrencyIds() returns a result.\n            cryptocurrencyRepository.getMyCryptocurrencyIds()\n        }\n\n        // Here we come back to main worker thread. As soon as myCryptocurrencyIds has a result\n        // and main looper is available, coroutine resumes on main thread, and\n        // [getMyCryptocurrencyLiveDataResourceList] is called.\n        // We wait for background operations to complete, without blocking the original thread.\n        refreshMyCryptocurrencyResourceList(\n                cryptocurrencyRepository.getMyCryptocurrencyLiveDataResourceList\n                (fiatCurrencyCode, true, myCryptocurrencyIds, callDelay))\n    }\n\n    ...\n}</code></pre><p>Here we call a function marked with a special Kotlin keyword <code>suspend</code> for coroutines. This means that the function suspends execution until the result is ready, then it resumes where it left off with the result. While it is suspended waiting for a result, it unblocks the thread that it is running on.</p><p>Also, in one suspend function we can call another suspend function. As you see we do that by calling new suspend function marked <code>withContext</code> that is executed on different thread.</p><p>The idea of all this code is that we can combine multiple calls to form nice-looking sequential code. First we request to get the ids of the cryptocurrencies we own from the local database and wait for the response. Only after we get it do we use the response ids to make a new call with Retrofit to get those updated cryptocurrency values. That is our retry functionality.</p><h3 id=\"we-made-it-final-thoughts-repository-app-presentation\">We made it! Final thoughts, repository, app &amp; presentation</h3><p>Congratulations, I am happy if you managed to reach to the end. All the most significant points for creating this app have been covered. There was plenty of new stuff done in this part and a lot of that is not covered by this article, but I commented my code everywhere very well so you should not get lost in it. Check out final code for this part 5 here on GitHub:</p><p><a href=\"https://github.com/baruckis/Kriptofolio/tree/Part-5\" rel=\"noopener\">View Source On GitHub</a>.</p><p>The biggest challenge for me personally was not to learn new technologies, not to develop the app, but to write all these articles. Actually I am very happy with myself that I completed this challenge. Learning and developing is easy compared to teaching others, but that is where you can understand the topic even better. My advice if you are looking for the best way to learn new things is to start creating something yourself immediately. I promise you will learn a lot and quickly.</p><p>All these articles are based on version 1.0.0 of \u201cKriptofolio\u201d (previously \u201cMy Crypto Coins\u201d) app which you can download as a separate APK file <a href=\"https://github.com/baruckis/Kriptofolio/releases\" rel=\"noopener\">here</a>. But I will be very happy if you install and rate the latest app version from the store directly:</p><h4 id=\"get-it-on-google-play\"><a href=\"https://play.google.com/store/apps/details?id=com.baruckis.kriptofolio\" rel=\"noopener\">Get It On Google Play</a></h4><p>Also please feel free to visit this simple presentation website that I made for this project:</p><h4 id=\"kriptofolio-app\"><a href=\"https://kriptofolio.app/\" rel=\"noopener\">Kriptofolio.app</a></h4><figure><img alt=\"xeMQGQ5yGL06eNvYuuDFjGw0cmNBU85dBjXE\" height=\"710\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/xeMQGQ5yGL06eNvYuuDFjGw0cmNBU85dBjXE\" width=\"800\"/></figure><hr/><p><strong><em>A\u010di\u016b! Thanks for reading! I originally published this post for my personal blog <a href=\"https://www.baruckis.com/android/kriptofolio-app-series-part-5/\" rel=\"noopener\">www.baruckis.com</a> on May 11, 2019.</em></strong></p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nKriptofolio app series \u2014 Part 5These days almost every Android app connects to internet to get/send data. You should definitely learn how to handle RESTful Web Services, as their correct implementation is the core knowledge while creating modern apps.This part is going to be complicated. We are going to combine multiple libraries at once to get a working result. I am not going to talk about the native Android way to handle internet requests, because in the real world nobody uses it. Every good app does not try to reinvent the wheel but instead uses the most popular third party libraries to solve common problems. It would be too complicated to recreate the functionality that these well-made libraries have to offer.Series contentIntroduction: A roadmap to build a modern Android app in 2018\u20132019Part 1: An introduction to the SOLID principlesPart 2: How to start building your Android app: creating Mockups, UI, and XML layoutsPart 3: All about that Architecture: exploring different architecture patterns and how to use them in your appPart 4: How to implement Dependency Injection in your app with Dagger 2Part 5: Handle RESTful Web Services using Retrofit, OkHttp, Gson, Glide and Coroutines (you\u2019re here)What is Retrofit, OkHttp and Gson?Retrofit is a REST Client for Java and Android. This library, in my opinion, is the most important one to learn, as it will do the main job. It makes it relatively easy to retrieve and upload JSON (or other structured data) via a REST based webservice.In Retrofit you configure which converter is used for the data serialization. Typically to serialize and deserialize objects to and from JSON you use an open-source Java library \u2014 Gson. Also if you need, you can add custom converters to Retrofit to process XML or other protocols.For making HTTP requests Retrofit uses the OkHttp library. OkHttp is a pure HTTP/SPDY client responsible for any low-level network operations, caching, requests and responses manipulation. In contrast, Retrofit is a high-level REST abstraction build on top of OkHttp. Retrofit is strongly coupled with OkHttp and makes intensive use of it.Now that you know that everything is closely related, we are going to use all these 3 libraries at once. Our first goal is to get all the cryptocurrencies list using Retrofit from the Internet. We will use a special OkHttp interceptor class for CoinMarketCap API authentication when making a call to the server. We will get back a JSON data result and then convert it using the Gson library.Quick setup for Retrofit 2 just to try it firstWhen learning something new, I like to try it out in practice as soon as I can. We will apply a similar approach with Retrofit 2 for you to understand it better more quickly. Don\u2019t worry right now about code quality or any programming principles or optimizations \u2014 we\u2019ll just write some code to make Retrofit 2 work in our project and discuss what it does.Follow these steps to set up Retrofit 2 on My Crypto Coins app project:First, give INTERNET permission for the appWe are going to execute HTTP requests on a server accessible via the Internet. Give this permission by adding these lines to your Manifest file:<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.baruckis.mycryptocoins\">\n\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    ...\n</manifest>Then you should add library dependenciesFind the latest Retrofit version. Also you should know that Retrofit doesn\u2019t ship with an integrated JSON converter. Since we will get responses in JSON format, we need to include the converter manually in the dependencies too. We are going to use latest Google\u2019s JSON converter Gson version. Let\u2019s add these lines to your gradle file:// 3rd party\n// HTTP client - Retrofit with OkHttp\nimplementation \"com.squareup.retrofit2:retrofit:$versions.retrofit\"\n// JSON converter Gson for JSON to Java object mapping\nimplementation \"com.squareup.retrofit2:converter-gson:$versions.retrofit\"As you noticed from my comment, the OkHttp dependency is already shipped with the Retrofit 2 dependency. Versions is just a separate gradle file for convenience:def versions = [:]\n\nversions.retrofit = \"2.4.0\"\n\next.versions = versionsNext set up the Retrofit interfaceIt\u2019s an interface that declares our requests and their types. Here we define the API on the client side./**\n * REST API access points.\n */\ninterface ApiService {\n\n    // The @GET annotation tells retrofit that this request is a get type request.\n    // The string value tells retrofit that the path of this request is\n    // baseUrl + v1/cryptocurrency/listings/latest + query parameter.\n    @GET(\"v1/cryptocurrency/listings/latest\")\n    // Annotation @Query is used to define query parameter for request. Finally the request url will\n    // look like that https://sandbox-api.coinmarketcap.com/v1/cryptocurrency/listings/latest?convert=EUR.\n    fun getAllCryptocurrencies(@Query(\"convert\") currency: String): Call<CryptocurrenciesLatest>\n    // The return type for this function is Call with its type CryptocurrenciesLatest.\n}And set up the data classData classes are POJOs (Plain Old Java Objects) that represent the responses of the API calls we\u2019re going to make./**\n * Data class to handle the response from the server.\n */\ndata class CryptocurrenciesLatest(\n        val status: Status,\n        val data: List<Data>\n) {\n\n    data class Data(\n            val id: Int,\n            val name: String,\n            val symbol: String,\n            val slug: String,\n            // The annotation to a model property lets you pass the serialized and deserialized\n            // name as a string. This is useful if you don't want your model class and the JSON\n            // to have identical naming.\n            @SerializedName(\"circulating_supply\")\n            val circulatingSupply: Double,\n            @SerializedName(\"total_supply\")\n            val totalSupply: Double,\n            @SerializedName(\"max_supply\")\n            val maxSupply: Double,\n            @SerializedName(\"date_added\")\n            val dateAdded: String,\n            @SerializedName(\"num_market_pairs\")\n            val numMarketPairs: Int,\n            @SerializedName(\"cmc_rank\")\n            val cmcRank: Int,\n            @SerializedName(\"last_updated\")\n            val lastUpdated: String,\n            val quote: Quote\n    ) {\n\n        data class Quote(\n                // For additional option during deserialization you can specify value or alternative\n                // values. Gson will check the JSON for all names we specify and try to find one to\n                // map it to the annotated property.\n                @SerializedName(value = \"USD\", alternate = [\"AUD\", \"BRL\", \"CAD\", \"CHF\", \"CLP\",\n                    \"CNY\", \"CZK\", \"DKK\", \"EUR\", \"GBP\", \"HKD\", \"HUF\", \"IDR\", \"ILS\", \"INR\", \"JPY\",\n                    \"KRW\", \"MXN\", \"MYR\", \"NOK\", \"NZD\", \"PHP\", \"PKR\", \"PLN\", \"RUB\", \"SEK\", \"SGD\",\n                    \"THB\", \"TRY\", \"TWD\", \"ZAR\"])\n                val currency: Currency\n        ) {\n\n            data class Currency(\n                    val price: Double,\n                    @SerializedName(\"volume_24h\")\n                    val volume24h: Double,\n                    @SerializedName(\"percent_change_1h\")\n                    val percentChange1h: Double,\n                    @SerializedName(\"percent_change_24h\")\n                    val percentChange24h: Double,\n                    @SerializedName(\"percent_change_7d\")\n                    val percentChange7d: Double,\n                    @SerializedName(\"market_cap\")\n                    val marketCap: Double,\n                    @SerializedName(\"last_updated\")\n                    val lastUpdated: String\n            )\n        }\n    }\n\n    data class Status(\n            val timestamp: String,\n            @SerializedName(\"error_code\")\n            val errorCode: Int,\n            @SerializedName(\"error_message\")\n            val errorMessage: String,\n            val elapsed: Int,\n            @SerializedName(\"credit_count\")\n            val creditCount: Int\n    )\n}Create a special interceptor class for authentication when making a call to the serverThis is the case particular for any API that requires authentication to get a successful response. Interceptors are a powerful way to customize your requests. We are going to intercept the actual request and to add individual request headers, which will validate the call with an API Key provided by CoinMarketCap Professional API Developer Portal. To get yours, you need to register there./**\n * Interceptor used to intercept the actual request and\n * to supply your API Key in REST API calls via a custom header.\n */\nclass AuthenticationInterceptor : Interceptor {\n\n    override fun intercept(chain: Interceptor.Chain): Response {\n\n        val newRequest = chain.request().newBuilder()\n                // TODO: Use your API Key provided by CoinMarketCap Professional API Developer Portal.\n                .addHeader(\"X-CMC_PRO_API_KEY\", \"CMC_PRO_API_KEY\")\n                .build()\n\n        return chain.proceed(newRequest)\n    }\n}Finally, add this code to our activity to see Retrofit workingI wanted to get your hands dirty as soon as possible, so I put everything in one place. This is not the correct way, but it\u2019s the fastest instead just to see a visual result quickly.class AddSearchActivity : AppCompatActivity(), Injectable {\n\n    private lateinit var listView: ListView\n    private lateinit var listAdapter: AddSearchListAdapter\n\n    ...\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        ...\n\n        // Later we will setup Retrofit correctly, but for now we do all in one place just for quick start.\n        setupRetrofitTemporarily()\n    }\n\n    ...\n\n    private fun setupRetrofitTemporarily() {\n\n        // We need to prepare a custom OkHttp client because need to use our custom call interceptor.\n        // to be able to authenticate our requests.\n        val builder = OkHttpClient.Builder()\n        // We add the interceptor to OkHttpClient.\n        // It will add authentication headers to every call we make.\n        builder.interceptors().add(AuthenticationInterceptor())\n        val client = builder.build()\n\n\n        val api = Retrofit.Builder() // Create retrofit builder.\n                .baseUrl(\"https://sandbox-api.coinmarketcap.com/\") // Base url for the api has to end with a slash.\n                .addConverterFactory(GsonConverterFactory.create()) // Use GSON converter for JSON to POJO object mapping.\n                .client(client) // Here we set the custom OkHttp client we just created.\n                .build().create(ApiService::class.java) // We create an API using the interface we defined.\n\n\n        val adapterData: MutableList<Cryptocurrency> = ArrayList<Cryptocurrency>()\n\n        val currentFiatCurrencyCode = \"EUR\"\n\n        // Let's make asynchronous network request to get all latest cryptocurrencies from the server.\n        // For query parameter we pass \"EUR\" as we want to get prices in euros.\n        val call = api.getAllCryptocurrencies(\"EUR\")\n        val result = call.enqueue(object : Callback<CryptocurrenciesLatest> {\n\n            // You will always get a response even if something wrong went from the server.\n            override fun onFailure(call: Call<CryptocurrenciesLatest>, t: Throwable) {\n\n                Snackbar.make(findViewById(android.R.id.content),\n                        // Throwable will let us find the error if the call failed.\n                        \"Call failed! \" + t.localizedMessage,\n                        Snackbar.LENGTH_INDEFINITE).show()\n            }\n\n            override fun onResponse(call: Call<CryptocurrenciesLatest>, response: Response<CryptocurrenciesLatest>) {\n\n                // Check if the response is successful, which means the request was successfully\n                // received, understood, accepted and returned code in range [200..300).\n                if (response.isSuccessful) {\n\n                    // If everything is OK, let the user know that.\n                    Toast.makeText(this@AddSearchActivity, \"Call OK.\", Toast.LENGTH_LONG).show();\n\n                    // Than quickly map server response data to the ListView adapter.\n                    val cryptocurrenciesLatest: CryptocurrenciesLatest? = response.body()\n                    cryptocurrenciesLatest!!.data.forEach {\n                        val cryptocurrency = Cryptocurrency(it.name, it.cmcRank.toShort(),\n                                0.0, it.symbol, currentFiatCurrencyCode, it.quote.currency.price,\n                                0.0, it.quote.currency.percentChange1h,\n                                it.quote.currency.percentChange7d, it.quote.currency.percentChange24h,\n                                0.0)\n                        adapterData.add(cryptocurrency)\n                    }\n\n                    listView.visibility = View.VISIBLE\n                    listAdapter.setData(adapterData)\n\n                }\n                // Else if the response is unsuccessful it will be defined by some special HTTP\n                // error code, which we can show for the user.\n                else Snackbar.make(findViewById(android.R.id.content),\n                        \"Call error with HTTP status code \" + response.code() + \"!\",\n                        Snackbar.LENGTH_INDEFINITE).show()\n\n            }\n\n        })\n\n    }\n\n   ...\n}You can explore the code here. Remember this is only an initial simplified implementation version for you to get the idea better.Final correct setup for Retrofit 2 with OkHttp 3 and GsonOk after a quick experiment, it is time to bring this Retrofit implementation to the next level. We already got the data successfully but not correctly. We are missing the states like loading, error and success. Our code is mixed without separation of concerns. It\u2019s a common mistake to write all your code in an activity or a fragment. Our activity class is UI based and should only contain logic that handles UI and operating system interactions.Actually, after this quick setup, I worked a lot and made many changes. There is no point to put all the code that was changed in the article. Better instead you should browse the final Part 5 code repo here. I have commented everything very well and my code should be clear for you to understand. But I am going to talk about most important things I have done and why I did them.The first step to improve was to start using Dependency Injection. Remember from the previous part we already have Dagger 2 implemented inside the project correctly. So I used it for the Retrofit setup./**\n * AppModule will provide app-wide dependencies for a part of the application.\n * It should initialize objects used across our application, such as Room database, Retrofit, Shared Preference, etc.\n */\n@Module(includes = [ViewModelsModule::class])\nclass AppModule() {\n    ...\n\n    @Provides\n    @Singleton\n    fun provideHttpClient(): OkHttpClient {\n        // We need to prepare a custom OkHttp client because need to use our custom call interceptor.\n        // to be able to authenticate our requests.\n        val builder = OkHttpClient.Builder()\n        // We add the interceptor to OkHttpClient.\n        // It will add authentication headers to every call we make.\n        builder.interceptors().add(AuthenticationInterceptor())\n\n        // Configure this client not to retry when a connectivity problem is encountered.\n        builder.retryOnConnectionFailure(false)\n\n        // Log requests and responses.\n        // Add logging as the last interceptor, because this will also log the information which\n        // you added or manipulated with previous interceptors to your request.\n        builder.interceptors().add(HttpLoggingInterceptor().apply {\n            // For production environment to enhance apps performance we will be skipping any\n            // logging operation. We will show logs just for debug builds.\n            level = if (BuildConfig.DEBUG) HttpLoggingInterceptor.Level.BODY else HttpLoggingInterceptor.Level.NONE\n        })\n        return builder.build()\n    }\n\n    @Provides\n    @Singleton\n    fun provideApiService(httpClient: OkHttpClient): ApiService {\n        return Retrofit.Builder() // Create retrofit builder.\n                .baseUrl(API_SERVICE_BASE_URL) // Base url for the api has to end with a slash.\n                .addConverterFactory(GsonConverterFactory.create()) // Use GSON converter for JSON to POJO object mapping.\n                .addCallAdapterFactory(LiveDataCallAdapterFactory())\n                .client(httpClient) // Here we set the custom OkHttp client we just created.\n                .build().create(ApiService::class.java) // We create an API using the interface we defined.\n    }\n\n    ...\n}Now as you see, Retrofit is separated from the activity class as it should be. It will be initialized only once and used app-wide.As you may have noticed while creating the Retrofit builder instance, we added a special Retrofit calls adapter using addCallAdapterFactory. By default, Retrofit returns a Call<T>, but for our project we require it to return a LiveData<T> type. In order to do that we need to add LiveDataCallAdapter by using LiveDataCallAdapterFactory./**\n * A Retrofit adapter that converts the Call into a LiveData of ApiResponse.\n * @param <R>\n</R> */\nclass LiveDataCallAdapter<R>(private val responseType: Type) :\n        CallAdapter<R, LiveData<ApiResponse<R>>> {\n\n    override fun responseType() = responseType\n\n    override fun adapt(call: Call<R>): LiveData<ApiResponse<R>> {\n        return object : LiveData<ApiResponse<R>>() {\n            private var started = AtomicBoolean(false)\n            override fun onActive() {\n                super.onActive()\n                if (started.compareAndSet(false, true)) {\n                    call.enqueue(object : Callback<R> {\n                        override fun onResponse(call: Call<R>, response: Response<R>) {\n                            postValue(ApiResponse.create(response))\n                        }\n\n                        override fun onFailure(call: Call<R>, throwable: Throwable) {\n                            postValue(ApiResponse.create(throwable))\n                        }\n                    })\n                }\n            }\n        }\n    }\n}class LiveDataCallAdapterFactory : CallAdapter.Factory() {\n    override fun get(\n            returnType: Type,\n            annotations: Array<Annotation>,\n            retrofit: Retrofit\n    ): CallAdapter<*, *>? {\n        if (CallAdapter.Factory.getRawType(returnType) != LiveData::class.java) {\n            return null\n        }\n        val observableType = CallAdapter.Factory.getParameterUpperBound(0, returnType as ParameterizedType)\n        val rawObservableType = CallAdapter.Factory.getRawType(observableType)\n        if (rawObservableType != ApiResponse::class.java) {\n            throw IllegalArgumentException(\"type must be a resource\")\n        }\n        if (observableType !is ParameterizedType) {\n            throw IllegalArgumentException(\"resource must be parameterized\")\n        }\n        val bodyType = CallAdapter.Factory.getParameterUpperBound(0, observableType)\n        return LiveDataCallAdapter<Any>(bodyType)\n    }\n}Now we will get LiveData<T> instead of Call<T> as the return type from Retrofit service methods defined in the ApiService interface.Another important step to make is to start using the Repository pattern. I have talked about it in Part 3. Check out our MVVM architecture schema from that post to remember where it goes.As you see in the picture, Repository is a separate layer for the data. It\u2019s our single source of contact for getting or sending data. When we use Repository, we are following the separation of concerns principle. We can have different data sources (like in our case persistent data from an SQLite database and data from web services), but Repository is always going to be single source of truth for all app data.Instead of communicating with our Retrofit implementation directly, we are going to use Repository for that. For each kind of entity, we are going to have a separate Repository./**\n * The class for managing multiple data sources.\n */\n@Singleton\nclass CryptocurrencyRepository @Inject constructor(\n        private val context: Context,\n        private val appExecutors: AppExecutors,\n        private val myCryptocurrencyDao: MyCryptocurrencyDao,\n        private val cryptocurrencyDao: CryptocurrencyDao,\n        private val api: ApiService,\n        private val sharedPreferences: SharedPreferences\n) {\n\n    // Just a simple helper variable to store selected fiat currency code during app lifecycle.\n    // It is needed for main screen currency spinner. We set it to be same as in shared preferences.\n    var selectedFiatCurrencyCode: String = getCurrentFiatCurrencyCode()\n\n\n    ...\n  \n\n    // The Resource wrapping of LiveData is useful to update the UI based upon the state.\n    fun getAllCryptocurrencyLiveDataResourceList(fiatCurrencyCode: String, shouldFetch: Boolean = false, callDelay: Long = 0): LiveData<Resource<List<Cryptocurrency>>> {\n        return object : NetworkBoundResource<List<Cryptocurrency>, CoinMarketCap<List<CryptocurrencyLatest>>>(appExecutors) {\n\n            // Here we save the data fetched from web-service.\n            override fun saveCallResult(item: CoinMarketCap<List<CryptocurrencyLatest>>) {\n\n                val list = getCryptocurrencyListFromResponse(fiatCurrencyCode, item.data, item.status?.timestamp)\n\n                cryptocurrencyDao.reloadCryptocurrencyList(list)\n                myCryptocurrencyDao.reloadMyCryptocurrencyList(list)\n            }\n\n            // Returns boolean indicating if to fetch data from web or not, true means fetch the data from web.\n            override fun shouldFetch(data: List<Cryptocurrency>?): Boolean {\n                return data == null || shouldFetch\n            }\n\n            override fun fetchDelayMillis(): Long {\n                return callDelay\n            }\n\n            // Contains the logic to get data from the Room database.\n            override fun loadFromDb(): LiveData<List<Cryptocurrency>> {\n\n                return Transformations.switchMap(cryptocurrencyDao.getAllCryptocurrencyLiveDataList()) { data ->\n                    if (data.isEmpty()) {\n                        AbsentLiveData.create()\n                    } else {\n                        cryptocurrencyDao.getAllCryptocurrencyLiveDataList()\n                    }\n                }\n            }\n\n            // Contains the logic to get data from web-service using Retrofit.\n            override fun createCall(): LiveData<ApiResponse<CoinMarketCap<List<CryptocurrencyLatest>>>> = api.getAllCryptocurrencies(fiatCurrencyCode)\n\n        }.asLiveData()\n    }\n\n\n    ...\n\n\n    fun getCurrentFiatCurrencyCode(): String {\n        return sharedPreferences.getString(context.resources.getString(R.string.pref_fiat_currency_key), context.resources.getString(R.string.pref_default_fiat_currency_value))\n                ?: context.resources.getString(R.string.pref_default_fiat_currency_value)\n    }\n\n\n    ...\n\n\n    private fun getCryptocurrencyListFromResponse(fiatCurrencyCode: String, responseList: List<CryptocurrencyLatest>?, timestamp: Date?): ArrayList<Cryptocurrency> {\n\n        val cryptocurrencyList: MutableList<Cryptocurrency> = ArrayList()\n\n        responseList?.forEach {\n            val cryptocurrency = Cryptocurrency(it.id, it.name, it.cmcRank.toShort(),\n                    it.symbol, fiatCurrencyCode, it.quote.currency.price,\n                    it.quote.currency.percentChange1h,\n                    it.quote.currency.percentChange7d, it.quote.currency.percentChange24h, timestamp)\n            cryptocurrencyList.add(cryptocurrency)\n        }\n\n        return cryptocurrencyList as ArrayList<Cryptocurrency>\n    }\n\n}As you notice in the CryptocurrencyRepository class code, I am using the NetworkBoundResource abstract class. What is it and why do we need it?NetworkBoundResource is a small but very important helper class that will allow us to maintain a synchronization between the local database and the web service. Our goal is to build a modern application that will work smoothly even when our device is offline. Also with the help of this class we will be able to present different network states like errors or loading for the user visually.NetworkBoundResource starts by observing the database for the resource. When the entry is loaded from the database for the first time, it checks whether the result is good enough to be dispatched or if it should be re-fetched from the network. Note that both of these situations can happen at the same time, given that you probably want to show cached data while updating it from the network.If the network call completes successfully, it saves the response into the database and re-initializes the stream. If the network request fails, the NetworkBoundResource dispatches a failure directly./**\n * A generic class that can provide a resource backed by both the sqlite database and the network.\n *\n *\n * You can read more about it in the [Architecture\n * Guide](https://developer.android.com/arch).\n * @param <ResultType> - Type for the Resource data.\n * @param <RequestType> - Type for the API response.\n</RequestType></ResultType> */\n\n// It defines two type parameters, ResultType and RequestType,\n// because the data type returned from the API might not match the data type used locally.\nabstract class NetworkBoundResource<ResultType, RequestType>\n@MainThread constructor(private val appExecutors: AppExecutors) {\n\n    // The final result LiveData.\n    private val result = MediatorLiveData<Resource<ResultType>>()\n\n    init {\n        // Send loading state to UI.\n        result.value = Resource.loading(null)\n        @Suppress(\"LeakingThis\")\n        val dbSource = loadFromDb()\n        result.addSource(dbSource) { data ->\n            result.removeSource(dbSource)\n            if (shouldFetch(data)) {\n                fetchFromNetwork(dbSource)\n            } else {\n                result.addSource(dbSource) { newData ->\n                    setValue(Resource.successDb(newData))\n                }\n            }\n        }\n    }\n\n    @MainThread\n    private fun setValue(newValue: Resource<ResultType>) {\n        if (result.value != newValue) {\n            result.value = newValue\n        }\n    }\n\n    // Fetch the data from network and persist into DB and then send it back to UI.\n    private fun fetchFromNetwork(dbSource: LiveData<ResultType>) {\n        val apiResponse = createCall()\n        // We re-attach dbSource as a new source, it will dispatch its latest value quickly.\n        result.addSource(dbSource) { newData ->\n            setValue(Resource.loading(newData))\n        }\n\n        // Create inner function as we want to delay it.\n        fun fetch() {\n            result.addSource(apiResponse) { response ->\n                result.removeSource(apiResponse)\n                result.removeSource(dbSource)\n                when (response) {\n                    is ApiSuccessResponse -> {\n                        appExecutors.diskIO().execute {\n                            saveCallResult(processResponse(response))\n                            appExecutors.mainThread().execute {\n                                // We specially request a new live data,\n                                // otherwise we will get immediately last cached value,\n                                // which may not be updated with latest results received from network.\n                                result.addSource(loadFromDb()) { newData ->\n                                    setValue(Resource.successNetwork(newData))\n                                }\n                            }\n                        }\n                    }\n                    is ApiEmptyResponse -> {\n                        appExecutors.mainThread().execute {\n                            // reload from disk whatever we had\n                            result.addSource(loadFromDb()) { newData ->\n                                setValue(Resource.successDb(newData))\n                            }\n                        }\n                    }\n                    is ApiErrorResponse -> {\n                        onFetchFailed()\n                        result.addSource(dbSource) { newData ->\n                            setValue(Resource.error(response.errorMessage, newData))\n                        }\n                    }\n                }\n            }\n        }\n\n        // Add delay before call if needed.\n        val delay = fetchDelayMillis()\n        if (delay > 0) {\n            Handler().postDelayed({ fetch() }, delay)\n        } else fetch()\n\n    }\n\n    // Called when the fetch fails. The child class may want to reset components\n    // like rate limiter.\n    protected open fun onFetchFailed() {}\n\n    // Returns a LiveData object that represents the resource that's implemented\n    // in the base class.\n    fun asLiveData() = result as LiveData<Resource<ResultType>>\n\n    @WorkerThread\n    protected open fun processResponse(response: ApiSuccessResponse<RequestType>) = response.body\n\n    // Called to save the result of the API response into the database.\n    @WorkerThread\n    protected abstract fun saveCallResult(item: RequestType)\n\n    // Called with the data in the database to decide whether to fetch\n    // potentially updated data from the network.\n    @MainThread\n    protected abstract fun shouldFetch(data: ResultType?): Boolean\n\n    // Make a call to the server after some delay for better user experience.\n    protected open fun fetchDelayMillis(): Long = 0\n\n    // Called to get the cached data from the database.\n    @MainThread\n    protected abstract fun loadFromDb(): LiveData<ResultType>\n\n    // Called to create the API call.\n    @MainThread\n    protected abstract fun createCall(): LiveData<ApiResponse<RequestType>>\n}Under the hood, the NetworkBoundResource class is made by using MediatorLiveData and its ability to observe multiple LiveData sources at once. Here we have two LiveData sources: the database and the network call response. Both of those LiveData are wrapped into one MediatorLiveData which is exposed by NetworkBoundResource.NetworkBoundResourceLet\u2019s take a closer look how the NetworkBoundResource will work in our app. Imagine the user will launch the app and click on a floating action button on the bottom right corner. The app will launch the add crypto coins screen. Now we can analyze NetworkBoundResource's usage inside it.If the app is freshly installed and it is its first launch, then there will not be any data stored inside the local database. Because there is no data to show, a loading progress bar UI will be shown. Meanwhile the app is going to make a request call to the server via a web service to get all the cryptocurrencies list.If the response is unsuccessful then the error message UI will be shown with the ability to retry a call by pressing a button. When a request call is successful at last, then the response data will be saved to a local SQLite database.If we come back to the same screen the next time, the app will load data from the database instead of making a call to the internet again. But the user can ask for a new data update by implementing pull-to-refresh functionality. Old data information will be shown whilst the network call is happening. All this is done with the help of NetworkBoundResource.Another class used in our Repository and LiveDataCallAdapter where all the \"magic\" happens is ApiResponse. Actually ApiResponse is just a simple common wrapper around the Retrofit2.Response class that converts each response to an instance of LiveData./**\n * Common class used by API responses. ApiResponse is a simple wrapper around the Retrofit2.Call\n * class that convert responses to instances of LiveData.\n * @param <CoinMarketCapType> the type of the response object\n</T> */\n@Suppress(\"unused\") // T is used in extending classes\nsealed class ApiResponse<CoinMarketCapType> {\n    companion object {\n        fun <CoinMarketCapType> create(error: Throwable): ApiErrorResponse<CoinMarketCapType> {\n            return ApiErrorResponse(error.message ?: \"Unknown error.\")\n        }\n\n        fun <CoinMarketCapType> create(response: Response<CoinMarketCapType>): ApiResponse<CoinMarketCapType> {\n            return if (response.isSuccessful) {\n                val body = response.body()\n                if (body == null || response.code() == 204) {\n                    ApiEmptyResponse()\n                } else {\n                    ApiSuccessResponse(body = body)\n                }\n            } else {\n\n                // Convert error response to JSON object.\n                val gson = Gson()\n                val type = object : TypeToken<CoinMarketCap<CoinMarketCapType>>() {}.type\n                val errorResponse: CoinMarketCap<CoinMarketCapType> = gson.fromJson(response.errorBody()!!.charStream(), type)\n\n                val msg = errorResponse.status?.errorMessage ?: errorResponse.message\n                val errorMsg = if (msg.isNullOrEmpty()) {\n                    response.message()\n                } else {\n                    msg\n                }\n                ApiErrorResponse(errorMsg ?: \"Unknown error.\")\n            }\n        }\n    }\n}\n\n/**\n * Separate class for HTTP 204 resposes so that we can make ApiSuccessResponse's body non-null.\n */\nclass ApiEmptyResponse<CoinMarketCapType> : ApiResponse<CoinMarketCapType>()\n\ndata class ApiSuccessResponse<CoinMarketCapType>(val body: CoinMarketCapType) : ApiResponse<CoinMarketCapType>()\n\ndata class ApiErrorResponse<CoinMarketCapType>(val errorMessage: String) : ApiResponse<CoinMarketCapType>()Inside this wrapper class, if our response has an error, we use the Gson library to convert the error to a JSON object. However, if the response was successful, then the Gson converter for JSON to POJO object mapping is used. We already added it when creating the retrofit builder instance with GsonConverterFactory inside the Dagger AppModule function provideApiService.Glide for image loadingWhat is Glide? From the docs:Glide is a fast and efficient open source media management and image loading framework for Android that wraps media decoding, memory and disk caching, and resource pooling into a simple and easy to use interface.Glide\u2019s primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but it is also effective for almost any case where you need to fetch, resize, and display a remote image.Sounds like a complicated library which offers many useful features that you would not want to develop all by yourself. In My Crypto Coins app, we have several list screens where we need to show multiple cryptocurrency logos \u2014 pictures taken from the internet all at once \u2014 and still ensure a smooth scrolling experience for the user. So this library fits our needs perfectly. Also this library is very popular among Android developers.Steps to setup Glide on My Crypto Coins app project:Declare dependenciesGet the latest Glide version. Again versions is a separate file versions.gradle for the project.// Glide\nimplementation \"com.github.bumptech.glide:glide:$versions.glide\"\nkapt \"com.github.bumptech.glide:compiler:$versions.glide\"\n// Glide's OkHttp3 integration.\nimplementation \"com.github.bumptech.glide:okhttp3-integration:$versions.glide\"+\"@aar\"Because we want to use the networking library OkHttp in our project for all network operations, we need to include the specific Glide integration for it instead of the default one. Also since Glide is going to perform a network request to load images via the internet, we need to include the permission INTERNET in our AndroidManifest.xml file \u2014 but we already did that with the Retrofit setup.Create AppGlideModuleGlide v4, which we will be using, offers a generated API for Applications. It will use an annotation processor to generate an API that allows applications to extend Glide\u2019s API and include components provided by integration libraries. For any app to access the generated Glide API we need to include an appropriately annotated AppGlideModule implementation. There can be only a single implementation of the generated API and only one AppGlideModule per application.Let\u2019s create a class extending AppGlideModule somewhere in your app project:/**\n * Glide v4 uses an annotation processor to generate an API that allows applications to access all\n * options in RequestBuilder, RequestOptions and any included integration libraries in a single\n * fluent API.\n *\n * The generated API serves two purposes:\n * Integration libraries can extend Glide\u2019s API with custom options.\n * Applications can extend Glide\u2019s API by adding methods that bundle commonly used options.\n *\n * Although both of these tasks can be accomplished by hand by writing custom subclasses of\n * RequestOptions, doing so is challenging and produces a less fluent API.\n */\n@GlideModule\nclass AppGlideModule : AppGlideModule()Even if our application is not changing any additional settings or implementing any methods in AppGlideModule, we still need to have its implementation to use Glide. You're not required to implement any of the methods in AppGlideModule for the API to be generated. You can leave the class blank as long as it extends AppGlideModule and is annotated with @GlideModule.Use Glide-generated APIWhen using AppGlideModule, applications can use the API by starting all loads with GlideApp.with(). This is the code that shows how I have used Glide to load and show cryptocurrency logos in the add crypto coins screen all cryptocurrencies list.class AddSearchListAdapter(val context: Context, private val cryptocurrencyClickCallback: ((Cryptocurrency) -> Unit)?) : BaseAdapter() {\n\n    ...\n\n    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {\n        ...\n\n        val itemBinding: ActivityAddSearchListItemBinding\n\n        ...\n\n        // We make an Uri of image that we need to load. Every image unique name is its id.\n        val imageUri = Uri.parse(CRYPTOCURRENCY_IMAGE_URL).buildUpon()\n                .appendPath(CRYPTOCURRENCY_IMAGE_SIZE_PX)\n                .appendPath(cryptocurrency.id.toString() + CRYPTOCURRENCY_IMAGE_FILE)\n                .build()\n\n        // Glide generated API from AppGlideModule.\n        GlideApp\n                // We need to provide context to make a call.\n                .with(itemBinding.root)\n                // Here you specify which image should be loaded by providing Uri.\n                .load(imageUri)\n                // The way you combine and execute multiple transformations.\n                // WhiteBackground is our own implemented custom transformation.\n                // CircleCrop is default transformation that Glide ships with.\n                .transform(MultiTransformation(WhiteBackground(), CircleCrop()))\n                // The target ImageView your image is supposed to get displayed in.\n                .into(itemBinding.itemImageIcon.imageview_front)\n\n        ...\n\n        return itemBinding.root\n    }\n\n    ...\n\n}As you see, you can start using Glide with just few lines of code and let it do all the hard work for you. It is pretty straightforward.Kotlin CoroutinesWhile building this app, we are going to face situations when we will run time consuming tasks such as writing data to a database or reading from it, fetching data from the network and other. All these common tasks take longer to complete than allowed by the Android framework\u2019s main thread.The main thread is a single thread that handles all updates to the UI. Developers are required not to block it to avoid the app freezing or even crashing with an Application Not Responding dialog. Kotlin coroutines is going to solve this problem for us by introducing main thread safety. It is the last missing piece that we want to add for My Crypto Coins app.Coroutines are a Kotlin feature that convert async callbacks for long-running tasks, such as database or network access, into sequential code. With coroutines, you can write asynchronous code, which was traditionally written using the Callback pattern, using a synchronous style. The return value of a function will provide the result of the asynchronous call. Code written sequentially is typically easier to read, and can even use language features such as exceptions.So we are going to use coroutines everywhere in this app where we need to wait until a result is available from a long-running task and than continue execution. Let\u2019s see one exact implementation for our ViewModel where we will retry getting the latest data from the server for our cryptocurrencies presented on the main screen.First add coroutines to the project:// Coroutines support libraries for Kotlin.\n\n// Dependencies for coroutines.\nimplementation \"org.jetbrains.kotlinx:kotlinx-coroutines-core:$versions.coroutines\"\n\n// Dependency is for the special UI context that can be passed to coroutine builders that use\n// the main thread dispatcher to dispatch events on the main thread.\nimplementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:$versions.coroutines\"Then we will create abstract class which will become the base class to be used for any ViewModel that needs to have common functionality like coroutines in our case:abstract class BaseViewModel : ViewModel() {\n\n    // In Kotlin, all coroutines run inside a CoroutineScope.\n    // A scope controls the lifetime of coroutines through its job.\n    private val viewModelJob = Job()\n    // Since uiScope has a default dispatcher of Dispatchers.Main, this coroutine will be launched\n    // in the main thread.\n    val uiScope = CoroutineScope(Dispatchers.Main + viewModelJob)\n\n\n    // onCleared is called when the ViewModel is no longer used and will be destroyed.\n    // This typically happens when the user navigates away from the Activity or Fragment that was\n    // using the ViewModel.\n    override fun onCleared() {\n        super.onCleared()\n        // When you cancel the job of a scope, it cancels all coroutines started in that scope.\n        // It's important to cancel any coroutines that are no longer required to avoid unnecessary\n        // work and memory leaks.\n        viewModelJob.cancel()\n    }\n}Here we create specific coroutine scope, which will control the lifetime of coroutines through its job. As you see, scope allows you to specify a default dispatcher that controls which thread runs a coroutine. When the ViewModel is no longer used, we cancel viewModelJob and with that every coroutine started by uiScope will be cancelled as well.Finally, implement the retry functionality:/**\n * The ViewModel class is designed to store and manage UI-related data in a lifecycle conscious way.\n * The ViewModel class allows data to survive configuration changes such as screen rotations.\n */\n\n// ViewModel will require a CryptocurrencyRepository so we add @Inject code into ViewModel constructor.\nclass MainViewModel @Inject constructor(val context: Context, val cryptocurrencyRepository: CryptocurrencyRepository) : BaseViewModel() {\n\n    ...\n\n    val mediatorLiveDataMyCryptocurrencyResourceList = MediatorLiveData<Resource<List<MyCryptocurrency>>>()\n    private var liveDataMyCryptocurrencyResourceList: LiveData<Resource<List<MyCryptocurrency>>>\n    private val liveDataMyCryptocurrencyList: LiveData<List<MyCryptocurrency>>\n\n    ...\n\n    // This is additional helper variable to deal correctly with currency spinner and preference.\n    // It is kept inside viewmodel not to be lost because of fragment/activity recreation.\n    var newSelectedFiatCurrencyCode: String? = null\n\n    // Helper variable to store state of swipe refresh layout.\n    var isSwipeRefreshing: Boolean = false\n\n\n    init {\n        ...\n\n        // Set a resource value for a list of cryptocurrencies that user owns.\n        liveDataMyCryptocurrencyResourceList = cryptocurrencyRepository.getMyCryptocurrencyLiveDataResourceList(cryptocurrencyRepository.getCurrentFiatCurrencyCode())\n\n\n        // Declare additional variable to be able to reload data on demand.\n        mediatorLiveDataMyCryptocurrencyResourceList.addSource(liveDataMyCryptocurrencyResourceList) {\n            mediatorLiveDataMyCryptocurrencyResourceList.value = it\n        }\n\n        ...\n    }\n\n   ...\n\n    /**\n     * On retry we need to run sequential code. First we need to get owned crypto coins ids from\n     * local database, wait for response and only after it use these ids to make a call with\n     * retrofit to get updated owned crypto values. This can be done using Kotlin Coroutines.\n     */\n    fun retry(newFiatCurrencyCode: String? = null) {\n\n        // Here we store new selected currency as additional variable or reset it.\n        // Later if call to server is unsuccessful we will reuse it for retry functionality.\n        newSelectedFiatCurrencyCode = newFiatCurrencyCode\n\n        // Launch a coroutine in uiScope.\n        uiScope.launch {\n            // Make a call to the server after some delay for better user experience.\n            updateMyCryptocurrencyList(newFiatCurrencyCode, SERVER_CALL_DELAY_MILLISECONDS)\n        }\n    }\n\n    // Refresh the data from local database.\n    fun refreshMyCryptocurrencyResourceList() {\n        refreshMyCryptocurrencyResourceList(cryptocurrencyRepository.getMyCryptocurrencyLiveDataResourceList(cryptocurrencyRepository.getCurrentFiatCurrencyCode()))\n    }\n\n    // To implement a manual refresh without modifying your existing LiveData logic.\n    private fun refreshMyCryptocurrencyResourceList(liveData: LiveData<Resource<List<MyCryptocurrency>>>) {\n        mediatorLiveDataMyCryptocurrencyResourceList.removeSource(liveDataMyCryptocurrencyResourceList)\n        liveDataMyCryptocurrencyResourceList = liveData\n        mediatorLiveDataMyCryptocurrencyResourceList.addSource(liveDataMyCryptocurrencyResourceList)\n        { mediatorLiveDataMyCryptocurrencyResourceList.value = it }\n    }\n\n    private suspend fun updateMyCryptocurrencyList(newFiatCurrencyCode: String? = null, callDelay: Long = 0) {\n\n        val fiatCurrencyCode: String = newFiatCurrencyCode\n                ?: cryptocurrencyRepository.getCurrentFiatCurrencyCode()\n\n        isSwipeRefreshing = true\n\n        // The function withContext is a suspend function. The withContext immediately shifts\n        // execution of the block into different thread inside the block, and back when it\n        // completes. IO dispatcher is suitable for execution the network requests in IO thread.\n        val myCryptocurrencyIds = withContext(Dispatchers.IO) {\n            // Suspend until getMyCryptocurrencyIds() returns a result.\n            cryptocurrencyRepository.getMyCryptocurrencyIds()\n        }\n\n        // Here we come back to main worker thread. As soon as myCryptocurrencyIds has a result\n        // and main looper is available, coroutine resumes on main thread, and\n        // [getMyCryptocurrencyLiveDataResourceList] is called.\n        // We wait for background operations to complete, without blocking the original thread.\n        refreshMyCryptocurrencyResourceList(\n                cryptocurrencyRepository.getMyCryptocurrencyLiveDataResourceList\n                (fiatCurrencyCode, true, myCryptocurrencyIds, callDelay))\n    }\n\n    ...\n}Here we call a function marked with a special Kotlin keyword suspend for coroutines. This means that the function suspends execution until the result is ready, then it resumes where it left off with the result. While it is suspended waiting for a result, it unblocks the thread that it is running on.Also, in one suspend function we can call another suspend function. As you see we do that by calling new suspend function marked withContext that is executed on different thread.The idea of all this code is that we can combine multiple calls to form nice-looking sequential code. First we request to get the ids of the cryptocurrencies we own from the local database and wait for the response. Only after we get it do we use the response ids to make a new call with Retrofit to get those updated cryptocurrency values. That is our retry functionality.We made it! Final thoughts, repository, app & presentationCongratulations, I am happy if you managed to reach to the end. All the most significant points for creating this app have been covered. There was plenty of new stuff done in this part and a lot of that is not covered by this article, but I commented my code everywhere very well so you should not get lost in it. Check out final code for this part 5 here on GitHub:View Source On GitHub.The biggest challenge for me personally was not to learn new technologies, not to develop the app, but to write all these articles. Actually I am very happy with myself that I completed this challenge. Learning and developing is easy compared to teaching others, but that is where you can understand the topic even better. My advice if you are looking for the best way to learn new things is to start creating something yourself immediately. I promise you will learn a lot and quickly.All these articles are based on version 1.0.0 of \u201cKriptofolio\u201d (previously \u201cMy Crypto Coins\u201d) app which you can download as a separate APK file here. But I will be very happy if you install and rate the latest app version from the store directly:Get It On Google PlayAlso please feel free to visit this simple presentation website that I made for this project:Kriptofolio.appA\u010di\u016b! Thanks for reading! I originally published this post for my personal blog www.baruckis.com on May 11, 2019.\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 50273, "excerpt": "Kriptofolio app series \u2014 Part 5\nThese days almost every Android app connects to internet to get/send data. You\nshould definitely learn how to handle RESTful Web Services, as their correct\nimplementation is the core knowledge while creating modern apps.\n\nThis part is going to be complicated. We are going to combine multiple libraries\nat once to get a working result. I am not going to talk about the native Android\nway to handle internet requests, because in the real world nobody uses it. Every\ngoo", "siteName": "freeCodeCamp.org", "publishedTime": "2019-05-11T08:26:24.000Z", "id": "88d719a13bf6ed462b861e256880dab62dda4da2", "url": "https://www.freecodecamp.org/news/kriptofolio-app-series-part-5/", "domain": "freecodecamp.org", "date": "2023-12-27T18:10:05.791480", "resultUri": "http://localhost:3000/result/88d719a13bf6ed462b861e256880dab62dda4da2", "query": {"url": ["https://www.freecodecamp.org/news/kriptofolio-app-series-part-5/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "How to handle RESTful web Services using Retrofit, OkHttp, Gson, Glide and Coroutines", "description": "Kriptofolio app series \u2014 Part 5 These days almost every Android app connects to internet to get/send data. You should definitely learn how to handle RESTful Web Services, as their correct implementation is the core knowledge while creating modern apps. This part is going to be complicated. We are going", "url": "https://www.freecodecamp.org/news/kriptofolio-app-series-part-5/", "image": "https://cdn-media-1.freecodecamp.org/images/1*F9gJTRqiq_YPvga0sPu_qw.png", "image:width": "800", "image:height": "463"}, "twitter": {"card": "summary_large_image", "title": "How to handle RESTful web Services using Retrofit, OkHttp, Gson, Glide and Coroutines", "description": "Kriptofolio app series \u2014 Part 5 These days almost every Android app connects to internet to get/send data. You should definitely learn how to handle RESTful Web Services, as their correct implementation is the core knowledge while creating modern apps. This part is going to be complicated. We are going", "url": "https://www.freecodecamp.org/news/kriptofolio-app-series-part-5/", "image": "https://cdn-media-1.freecodecamp.org/images/1*F9gJTRqiq_YPvga0sPu_qw.png", "label1": "Written by", "data1": "Andrius Baruckis", "label2": "Filed under", "data2": "Android, Cryptocurrency, Web Services, Tech, Programming", "site": "@freecodecamp", "creator": "@baruckis"}}}