{"title": "HTML vs Body: How to Set Width and Height for Full Page Size", "byline": "Dave Gray", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>HTML vs Body: How to Set Width and Height for Full Page Size</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>CSS is difficult but also forgiving. And this forgiveness allows us to haphazardly throw styles into our CSS. </p><p>Our page still loads. There is no \"crash\". </p><p>When it comes to page width and height, do you know what to set on the HTML element? How about the body element? </p><p>Do you just slap the styles into both elements and hope for the best?</p><p>If you do, you're not alone.</p><p>The answers to those questions are not intuitive. </p><p>I'm 100% guilty of applying styles to both elements in the past without considering exactly which property should be applied to which element. \ud83e\udd26\u200d\u2642\ufe0f</p><p>It is not uncommon to see CSS properties applied to both the HTML and body elements like this:</p><!--kg-card-begin: markdown--><pre><code>html, body {\n     min-height: 100%;\n}\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"does-it-matter\">Does It Matter?</h2><p>Yes, yes it does.</p><p>The above style definition creates a problem:</p><p>Setting min-height to 100% on both elements does not allow the body element to fill the page like you might expect. If you check the computed style values in dev tools, the body element has a height of zero. </p><p>Meanwhile, the HTML element has a height equal to the visible part of the page in the browser.</p><p>Look at the following screenshot from Chrome Dev Tools:</p><figure><img alt=\"empty_body\" height=\"280\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2021/02/empty_body.png\" width=\"596\"/><figcaption>The body element has a default 8px margin indicated by the bar on top. The height value is 0.</figcaption></figure><h2 id=\"why-does-this-happen\">Why Does This Happen?</h2><p>Using a percentage as a size value requires the element to reference a parent to base that percentage on. </p><p>The HTML element references the viewport which has a height value equal to the visible viewport height. However, we only set a min-height on the HTML element... NOT a height property value. </p><p>Therefore, the body element has no parent height value to reference when deciding what 100% is equal to.</p><p>If you started out with enough content to fill the body of the page, you might not have noticed this issue. </p><p>And to make it more difficult to notice, if you set a background-color on both elements or even on just one of them, the viewport is full of that color. This gives the impression the body element is as tall as the viewport.</p><p>It's not. It's still at zero.</p><p>The image above is taken from a page with the following CSS: </p><!--kg-card-begin: markdown--><pre><code>html, body {\n    min-height: 100%;\n}\nbody { background-color: dodgerblue; }\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"reverse-inheritance\">Reverse-inheritance?</h3><p>In a strange twist, the HTML element assumes the background-color of the body element if you don't set a separate background-color on the html element. </p><h2 id=\"so-what-is-the-ideal-height-setting-for-a-full-responsive-page\">So What is the Ideal Height Setting for a Full Responsive Page?</h2><p>For years, the answer was the following:</p><!--kg-card-begin: markdown--><pre><code>html {\n    height: 100%;\n}\nbody {\n    min-height: 100%;\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>This allows the HTML element to reference the parent viewport and have a height value equal to 100% of the viewport value. </p><p>With the HTML element receiving a height value, the min-height value assigned to the body element gives it an initial height that matches the HTML element. </p><p>This also allows the body to to grow taller if the content outgrows the visible page. </p><p>The only drawback is the HTML element does not grow beyond the height of the visible viewport. However, allowing the body element to outgrow the HTML element has been considered acceptable.</p><h2 id=\"the-modern-solution-is-simplified\"><strong>The Modern Solution is Simplified</strong></h2><!--kg-card-begin: markdown--><pre><code>body { min-height: 100vh; }\n</code></pre>\n<!--kg-card-end: markdown--><p>This example uses <code>vh</code> (viewport height) units to allow the body to set a minimum height value based upon the full height of the viewport. </p><p>Like the previously discussed background-color, if we do not set a height value for the HTML element, it will assume the same value for height that is given to the body element. </p><p>Therefore, this solution avoids the HTML element overflow present in the previous solution and both elements grow with your content! </p><p>The use of <code>vh</code> units did cause some mobile browser issues in the past, but <a href=\"https://developers.google.com/web/updates/2016/12/url-bar-resizing\">it appears that Chrome and Safari are consistent with viewport units now</a>.</p><h2 id=\"page-height-may-cause-a-horizontal-scrollbar\">Page Height May Cause a Horizontal Scrollbar</h2><p>Wait, what? </p><p>Shouldn't this say \"Page Width\"? </p><p>In another strange series of events, your page height may activate the horizontal scrollbar in your browser. </p><p>When your page content grows taller than the viewport height, the vertical scrollbar on the right is activated. This can cause your page to instantly have a horizontal scrollbar as well.</p><h2 id=\"so-what-is-the-fix\">So What is the Fix?</h2><p>You may sleep better knowing it starts with a page width setting.</p><p>This problem arises when any element - not just the HTML or body element - is set to 100vw (viewport width) units. </p><p>The viewport units do not account for the approximate 10 pixels that the vertical scrollbar takes up. </p><p>Therefore, when the vertical scrollbar activates you also get a horizontal scrollbar.</p><p>Maybe just don't. </p><p>Not setting a width on the HTML and body elements will default to the full size of the screen. If you do set a width value other than auto, consider utilizing a CSS reset first.</p><p>Remember, by default the body element has 8px of margin on all sides. </p><p>A CSS reset removes this. Otherwise, setting the width to 100% before removing the margins will cause the body element to overflow. Here's the CSS reset I use:</p><!--kg-card-begin: markdown--><pre><code>* { \n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"how-to-set-width-to-your-preference\">How to Set Width to Your Preference</h2><p>While it may not always be necessary to set a width, I usually do. </p><p>It may simply be a habit.</p><p>If you set the width to 100% on the body element you will have a full page width. This is essentially equivalent to not setting a width value and allowing the default.</p><p>If you want to use the body element as a smaller container and let the HTML element fill the page, you could set a max-width value on the body. </p><p>Here's an example: </p><!--kg-card-begin: markdown--><pre><code>html { background-color: #000; } \nbody {\n    min-height: 100vh;\n    max-width: 400px;\n    background-color: papayawhip; \n    margin: 0 auto;\n}</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"conclusion\">Conclusion</h2><p>With no height value provided for the HTML element, setting the height and/or min-height of the body element to 100% results in no height (before you add content).</p><p>However, with no width value provided for the HTML element, setting the width of the body element to 100% results in full page width.</p><p>This can be counterintuitive and confusing. </p><p>For a responsive full page height, set the body element min-height to 100vh.</p><p>If you set a page width, choose 100% over 100vw to avoid surprise horizontal scrollbars.</p><p>I'll leave you with a tutorial from my YouTube channel demonstrating the CSS height and width settings for an HTML page that is full screen size and grows with the content it contains:</p><figure data-test-label=\"fitted\">\n\n</figure><p>Do you have a different way of setting the CSS width and height that you prefer?</p><p>Let me know your method!</p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nCSS is difficult but also forgiving. And this forgiveness allows us to haphazardly throw styles into our CSS. Our page still loads. There is no \"crash\". When it comes to page width and height, do you know what to set on the HTML element? How about the body element? Do you just slap the styles into both elements and hope for the best?If you do, you're not alone.The answers to those questions are not intuitive. I'm 100% guilty of applying styles to both elements in the past without considering exactly which property should be applied to which element. \ud83e\udd26\u200d\u2642\ufe0fIt is not uncommon to see CSS properties applied to both the HTML and body elements like this:html, body {\n     min-height: 100%;\n}\n\nDoes It Matter?Yes, yes it does.The above style definition creates a problem:Setting min-height to 100% on both elements does not allow the body element to fill the page like you might expect. If you check the computed style values in dev tools, the body element has a height of zero. Meanwhile, the HTML element has a height equal to the visible part of the page in the browser.Look at the following screenshot from Chrome Dev Tools:The body element has a default 8px margin indicated by the bar on top. The height value is 0.Why Does This Happen?Using a percentage as a size value requires the element to reference a parent to base that percentage on. The HTML element references the viewport which has a height value equal to the visible viewport height. However, we only set a min-height on the HTML element... NOT a height property value. Therefore, the body element has no parent height value to reference when deciding what 100% is equal to.If you started out with enough content to fill the body of the page, you might not have noticed this issue. And to make it more difficult to notice, if you set a background-color on both elements or even on just one of them, the viewport is full of that color. This gives the impression the body element is as tall as the viewport.It's not. It's still at zero.The image above is taken from a page with the following CSS: html, body {\n    min-height: 100%;\n}\nbody { background-color: dodgerblue; }\n\nReverse-inheritance?In a strange twist, the HTML element assumes the background-color of the body element if you don't set a separate background-color on the html element. So What is the Ideal Height Setting for a Full Responsive Page?For years, the answer was the following:html {\n    height: 100%;\n}\nbody {\n    min-height: 100%;\n}\n\nThis allows the HTML element to reference the parent viewport and have a height value equal to 100% of the viewport value. With the HTML element receiving a height value, the min-height value assigned to the body element gives it an initial height that matches the HTML element. This also allows the body to to grow taller if the content outgrows the visible page. The only drawback is the HTML element does not grow beyond the height of the visible viewport. However, allowing the body element to outgrow the HTML element has been considered acceptable.The Modern Solution is Simplifiedbody { min-height: 100vh; }\n\nThis example uses vh (viewport height) units to allow the body to set a minimum height value based upon the full height of the viewport. Like the previously discussed background-color, if we do not set a height value for the HTML element, it will assume the same value for height that is given to the body element. Therefore, this solution avoids the HTML element overflow present in the previous solution and both elements grow with your content! The use of vh units did cause some mobile browser issues in the past, but it appears that Chrome and Safari are consistent with viewport units now.Page Height May Cause a Horizontal ScrollbarWait, what? Shouldn't this say \"Page Width\"? Nope. In another strange series of events, your page height may activate the horizontal scrollbar in your browser. When your page content grows taller than the viewport height, the vertical scrollbar on the right is activated. This can cause your page to instantly have a horizontal scrollbar as well.So What is the Fix?You may sleep better knowing it starts with a page width setting.This problem arises when any element - not just the HTML or body element - is set to 100vw (viewport width) units. The viewport units do not account for the approximate 10 pixels that the vertical scrollbar takes up. Therefore, when the vertical scrollbar activates you also get a horizontal scrollbar.Maybe just don't. Not setting a width on the HTML and body elements will default to the full size of the screen. If you do set a width value other than auto, consider utilizing a CSS reset first.Remember, by default the body element has 8px of margin on all sides. A CSS reset removes this. Otherwise, setting the width to 100% before removing the margins will cause the body element to overflow. Here's the CSS reset I use:* { \n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nHow to Set Width to Your PreferenceWhile it may not always be necessary to set a width, I usually do. It may simply be a habit.If you set the width to 100% on the body element you will have a full page width. This is essentially equivalent to not setting a width value and allowing the default.If you want to use the body element as a smaller container and let the HTML element fill the page, you could set a max-width value on the body. Here's an example: html { background-color: #000; } \nbody {\n    min-height: 100vh;\n    max-width: 400px;\n    background-color: papayawhip; \n    margin: 0 auto;\n}\nConclusionWith no height value provided for the HTML element, setting the height and/or min-height of the body element to 100% results in no height (before you add content).However, with no width value provided for the HTML element, setting the width of the body element to 100% results in full page width.This can be counterintuitive and confusing. For a responsive full page height, set the body element min-height to 100vh.If you set a page width, choose 100% over 100vw to avoid surprise horizontal scrollbars.I'll leave you with a tutorial from my YouTube channel demonstrating the CSS height and width settings for an HTML page that is full screen size and grows with the content it contains:\n        \n          \n            \n          \n        \n      Do you have a different way of setting the CSS width and height that you prefer?Let me know your method!\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 7102, "excerpt": "CSS is difficult but also forgiving. And this forgiveness allows us to\nhaphazardly throw styles into our CSS. \n\nOur page still loads. There is no \"crash\". \n\nWhen it comes to page width and height, do you know what to set on the HTML\nelement? How about the body element? \n\nDo you just slap the styles into both elements and hope for the best?\n\nIf you do, you're not alone.\n\nThe answers to those questions are not intuitive. \n\nI'm 100% guilty of applying styles to both elements in the past without\ncon", "siteName": "freeCodeCamp.org", "publishedTime": "2021-02-17T17:06:50.000Z", "id": "c847b5cbae112d7050e3d9aad12fe3798042688e", "url": "https://www.freecodecamp.org/news/html-page-width-height/", "domain": "freecodecamp.org", "date": "2023-12-27T18:06:12.933407", "resultUri": "http://localhost:3000/result/c847b5cbae112d7050e3d9aad12fe3798042688e", "query": {"url": ["https://www.freecodecamp.org/news/html-page-width-height/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "HTML vs Body: How to Set Width and Height for Full Page Size", "description": "CSS is difficult but also forgiving. And this forgiveness allows us to haphazardly throw styles into our CSS.  Our page still loads. There is no \"crash\".  When it comes to page width and height, do you know what to set on the HTML element? How about the body", "url": "https://www.freecodecamp.org/news/html-page-width-height/", "image": "https://www.freecodecamp.org/news/content/images/2021/02/william-warby-WahfNoqbYnM-unsplash--1-.jpg", "image:width": "2000", "image:height": "1500"}, "twitter": {"card": "summary_large_image", "title": "HTML vs Body: How to Set Width and Height for Full Page Size", "description": "CSS is difficult but also forgiving. And this forgiveness allows us to haphazardly throw styles into our CSS.  Our page still loads. There is no \"crash\".  When it comes to page width and height, do you know what to set on the HTML element? How about the body", "url": "https://www.freecodecamp.org/news/html-page-width-height/", "image": "https://www.freecodecamp.org/news/content/images/2021/02/william-warby-WahfNoqbYnM-unsplash--1-.jpg", "label1": "Written by", "data1": "Dave Gray", "label2": "Filed under", "data2": "Programming, Web Development, Design, CSS, HTML", "site": "@freecodecamp", "creator": "@yesdavidgray"}}}