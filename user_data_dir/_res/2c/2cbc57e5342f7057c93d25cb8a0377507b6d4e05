{"title": "The Fibonacci Sequence \u2013  Explained in Python, JavaScript, C++, Java, and Swift", "byline": "freeCodeCamp.org", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>The Fibonacci Sequence \u2013  Explained in Python, JavaScript, C++, Java, and Swift</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>by Pau Pav\u00f3n</p><p>The Fibonacci sequence is, by definition, the integer sequence in which every number after the first two is the sum of the two preceding numbers. To simplify:</p><p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \u2026</p><p>It has many applications in mathematics and even trading (yes, you read that right: trading), but that\u2019s not the point of this article. My goal today is to show you how you can compute any term of this series of numbers in five different programming languages using recursive functions.</p><p>Recursive functions are those functions which, basically, call themselves.</p><p>I want to note that this isn\u2019t the best method to do it \u2014 in fact, it could be considered the most basic method for this purpose. This is because the computing power required to calculate larger terms of the series is immense. The number of times the function is called causes a stack overflow in most languages.</p><p>All the same, for the purposes of this tutorial, let\u2019s begin.</p><p>First of all, let\u2019s think about what the code is going to look like. It\u2019ll include:</p><p>\u00b7 A recursive function F (F for Fibonacci): to compute the value of the next term.</p><p>\u00b7 Nothing else: I warned you it was quite basic.</p><p>Our function will take <em>n</em> as an input, which will refer to the <em>n</em>th term of the sequence that we want to be computed. So, F(4) should return the fourth term of the sequence.</p><p>Let\u2019s plan it. The code should, regardless the language, look something like this:</p><p><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code>function F(n) \u00a0if n = 0</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0 \u00a0return 0 \u00a0if n = 1</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0 \u00a0return 1 \u00a0else</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0 \u00a0return F(n-1) + F(n-2)</code></a></p><p>Note: the term 0 of the sequence will be considered to be 0, so the first term will be 1; the second, 1; the third, 2; and so on. You get it.</p><p>Let\u2019s analyze the function for a moment. If it gets 0 as an input, it returns 0. If it gets 1, it returns 1. If it gets 2\u2026 Well, in that case it falls into the else statement, which will call the function again for terms 2\u20131 (1) and 2\u20132 (0). That will return 1 and 0, and the two results will be added, returning 1. Perfect.</p><p>Now you can see why recursive functions are a problem in some cases. Imagine you wanted the 100th term of the sequence. The function would call itself for the 99th and the 98th, which would themselves call the function again for the 98th and 97th, and 97th and 96th terms\u2026and so on. It would be <strong>really</strong> slow.</p><p>But the good news is that it actually works!</p><p>So let\u2019s start with the different languages. I won\u2019t give too much detail (actually, no detail at all) to make your reading experience better. There isn\u2019t too much to detail anyways.</p><p>Let\u2019s jump into it:</p><h3 id=\"python\">Python</h3><p><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code>def F(n): \u00a0if n == 0:</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0 \u00a0return 0 \u00a0if n == 1:</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0 \u00a0return 1 \u00a0else:</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0 \u00a0return F(n-1) + F(n-2)</code></a></p><h3 id=\"swift\">Swift</h3><p><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code>func F(_ n: Int) -&gt; Int { \u00a0if n == 0 { \u00a0 \u00a0return 0</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0} \u00a0if n == 1 { \u00a0 \u00a0return 1</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0} \u00a0else { \u00a0 \u00a0return F(n-1) + F(n-2)</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0}}</code></a></p><h3 id=\"javascript\">JavaScript</h3><p><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code>function F(n) { \u00a0if(n == 0) { \u00a0 \u00a0return 0;</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0} \u00a0if(n == 1) { \u00a0 \u00a0return 1;</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0} \u00a0else { \u00a0 \u00a0return F(n-1) + F(n-2);</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0}}</code></a></p><h3 id=\"java\">Java</h3><p><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code>public static int F(int n) { \u00a0if(n == 0) { \u00a0 \u00a0return 0;</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0} \u00a0if(n == 1) { \u00a0 \u00a0return 1;</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0} \u00a0else { \u00a0 \u00a0return F(n-1) + F(n-2);</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0}}</code></a></p><h3 id=\"c-\">C++</h3><p><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code>int F(int n) { \u00a0if(n == 0) { \u00a0 \u00a0return 0;</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0} \u00a0if(n == 1) { \u00a0 \u00a0return 1;</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0} \u00a0else { \u00a0 \u00a0return F(n-1) + F(n-2);</code></a><br/><a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\"><code> \u00a0}}</code></a></p><p>And that\u2019s it. I chose these languages just based on popularity \u2014 or at least because these 5 are the most common ones that I use They\u2019re in no particular order. They could be classified by syntax difficulty, in my opinion, from Python (easiest) to C++ (hardest). But that depends on your personal opinion and your experience with each language.</p><p>I hope you liked this article and, if you have any questions/recommendations or just want to say hi, comment below!</p>\n</section>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nby Pau Pav\u00f3nThe Fibonacci sequence is, by definition, the integer sequence in which every number after the first two is the sum of the two preceding numbers. To simplify:0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \u2026It has many applications in mathematics and even trading (yes, you read that right: trading), but that\u2019s not the point of this article. My goal today is to show you how you can compute any term of this series of numbers in five different programming languages using recursive functions.Recursive functions are those functions which, basically, call themselves.I want to note that this isn\u2019t the best method to do it \u2014 in fact, it could be considered the most basic method for this purpose. This is because the computing power required to calculate larger terms of the series is immense. The number of times the function is called causes a stack overflow in most languages.All the same, for the purposes of this tutorial, let\u2019s begin.First of all, let\u2019s think about what the code is going to look like. It\u2019ll include:\u00b7 A recursive function F (F for Fibonacci): to compute the value of the next term.\u00b7 Nothing else: I warned you it was quite basic.Our function will take n as an input, which will refer to the nth term of the sequence that we want to be computed. So, F(4) should return the fourth term of the sequence.Let\u2019s plan it. The code should, regardless the language, look something like this:function F(n) \u00a0if n = 0 \u00a0 \u00a0return 0 \u00a0if n = 1 \u00a0 \u00a0return 1 \u00a0else \u00a0 \u00a0return F(n-1) + F(n-2)Note: the term 0 of the sequence will be considered to be 0, so the first term will be 1; the second, 1; the third, 2; and so on. You get it.Let\u2019s analyze the function for a moment. If it gets 0 as an input, it returns 0. If it gets 1, it returns 1. If it gets 2\u2026 Well, in that case it falls into the else statement, which will call the function again for terms 2\u20131 (1) and 2\u20132 (0). That will return 1 and 0, and the two results will be added, returning 1. Perfect.Now you can see why recursive functions are a problem in some cases. Imagine you wanted the 100th term of the sequence. The function would call itself for the 99th and the 98th, which would themselves call the function again for the 98th and 97th, and 97th and 96th terms\u2026and so on. It would be really slow.But the good news is that it actually works!So let\u2019s start with the different languages. I won\u2019t give too much detail (actually, no detail at all) to make your reading experience better. There isn\u2019t too much to detail anyways.Let\u2019s jump into it:Pythondef F(n): \u00a0if n == 0: \u00a0 \u00a0return 0 \u00a0if n == 1: \u00a0 \u00a0return 1 \u00a0else: \u00a0 \u00a0return F(n-1) + F(n-2)Swiftfunc F(_ n: Int) -> Int { \u00a0if n == 0 { \u00a0 \u00a0return 0 \u00a0} \u00a0if n == 1 { \u00a0 \u00a0return 1 \u00a0} \u00a0else { \u00a0 \u00a0return F(n-1) + F(n-2) \u00a0}}JavaScriptfunction F(n) { \u00a0if(n == 0) { \u00a0 \u00a0return 0; \u00a0} \u00a0if(n == 1) { \u00a0 \u00a0return 1; \u00a0} \u00a0else { \u00a0 \u00a0return F(n-1) + F(n-2); \u00a0}}Javapublic static int F(int n) { \u00a0if(n == 0) { \u00a0 \u00a0return 0; \u00a0} \u00a0if(n == 1) { \u00a0 \u00a0return 1; \u00a0} \u00a0else { \u00a0 \u00a0return F(n-1) + F(n-2); \u00a0}}C++int F(int n) { \u00a0if(n == 0) { \u00a0 \u00a0return 0; \u00a0} \u00a0if(n == 1) { \u00a0 \u00a0return 1; \u00a0} \u00a0else { \u00a0 \u00a0return F(n-1) + F(n-2); \u00a0}}And that\u2019s it. I chose these languages just based on popularity \u2014 or at least because these 5 are the most common ones that I use They\u2019re in no particular order. They could be classified by syntax difficulty, in my opinion, from Python (easiest) to C++ (hardest). But that depends on your personal opinion and your experience with each language.I hope you liked this article and, if you have any questions/recommendations or just want to say hi, comment below!\n\n                        \n                    \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 4190, "excerpt": "by Pau Pav\u00f3n\n\nThe Fibonacci sequence is, by definition, the integer sequence in which every\nnumber after the first two is the sum of the two preceding numbers. To simplify:\n\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \u2026\n\nIt has many applications in mathematics and even trading (yes, you read that\nright: trading), but that\u2019s not the point of this article. My goal today is to\nshow you how you can compute any term of this series of numbers in five\ndifferent programming languages using recursive f", "siteName": "freeCodeCamp.org", "publishedTime": "2020-06-01T15:38:00.000Z", "id": "2cbc57e5342f7057c93d25cb8a0377507b6d4e05", "url": "https://www.freecodecamp.org/news/the-fibonacci-sequence-in-5-different-programming-languages-1c6514c749e5/", "domain": "freecodecamp.org", "date": "2023-12-27T18:06:50.071629", "resultUri": "http://localhost:3000/result/2cbc57e5342f7057c93d25cb8a0377507b6d4e05", "query": {"url": ["https://www.freecodecamp.org/news/the-fibonacci-sequence-in-5-different-programming-languages-1c6514c749e5/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "The Fibonacci Sequence \u2013  Explained in Python, JavaScript, C++, Java, and Swift", "description": "by Pau Pav\u00f3n The Fibonacci sequence is, by definition, the integer sequence in which every number after the first two is the sum of the two preceding numbers. To simplify: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \u2026 It has many applications in mathematics", "url": "https://www.freecodecamp.org/news/the-fibonacci-sequence-in-5-different-programming-languages-1c6514c749e5/", "image": "https://cdn-media-1.freecodecamp.org/images/0*74G0BbEUwrCaw8iQ.", "image:width": "800", "image:height": "533"}, "twitter": {"card": "summary_large_image", "title": "The Fibonacci Sequence \u2013  Explained in Python, JavaScript, C++, Java, and Swift", "description": "by Pau Pav\u00f3n The Fibonacci sequence is, by definition, the integer sequence in which every number after the first two is the sum of the two preceding numbers. To simplify: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \u2026 It has many applications in mathematics", "url": "https://www.freecodecamp.org/news/the-fibonacci-sequence-in-5-different-programming-languages-1c6514c749e5/", "image": "https://cdn-media-1.freecodecamp.org/images/0*74G0BbEUwrCaw8iQ.", "label1": "Written by", "data1": "freeCodeCamp.org", "label2": "Filed under", "data2": "Programming, Coding, JavaScript, Python, Tech", "site": "@freecodecamp"}}}