{"title": "The real difference between catch vs onRejected", "byline": "freeCodeCamp.org", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>The real difference between catch vs onRejected</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>by Max Belsky</p><p>Most popular articles describe the difference between catch and onRejected in a code snippet like this:</p><pre><code>const getPromise = () =&gt; new Promise((resolve, reject) =&gt; {  Math.round(Math.random()) ?     resolve('resolve #1') :     reject('reject #1')})</code></pre><pre><code>getPromise().then(result =&gt; {  throw new Error('reject #2')}, error =&gt; {  // Handles only 'reject #1'})</code></pre><pre><code>getPromise().then(result =&gt; {  throw new Error('reject #2')})  .catch(error =&gt; {    // Handles both 'reject #1',     // and 'reject #2'  }))</code></pre><p>onRejected never handles rejected promises from the same <code>.then(onFulfilled)</code> callback and <code>.catch</code> takes both. However besides the behavior difference, there is one more nuance. It\u2019s about how these ways will be translated to <a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\" rel=\"noopener\">microtasks</a> and how they will be queued.<br/>Let\u2019s see an example of the difference.</p><h4 id=\"promise-race\">Promise.race</h4><p>There is a task \u2014 write <code>Promise.race</code> polyfill. We use a common pattern in both functions to handle <code>resolved</code> promises and different tools to handle <code>rejected</code> promises.</p><pre><code>const promiseRaceOnRejected = (promises = []) =&gt; {  return new Promise((resolve, reject) =&gt; {    promises.forEach(promise =&gt; {      promise.then(        result =&gt; resolve(result),        error =&gt; reject(error)      )    })  })}</code></pre><pre><code>const promiseRaceCatch = (promises = []) =&gt; {  return new Promise((resolve, reject) =&gt; {    promises.forEach(promise =&gt; {      promise.then(result =&gt; resolve(result))        .catch(error =&gt; reject(error))    })  })}</code></pre><p>Try some tests to be sure that both solutions work well:</p><pre><code>// A helper function to create a delayed promiseconst getPromise = (resolveMs, rejectMs) =&gt; {  return new Promise((resolve, reject) =&gt; {    if ('number' === typeof rejectMs) {      setTimeout(() =&gt; reject(rejectMs), rejectMs)    }</code></pre><pre><code>    if ('number' === typeof resolveMs) {      setTimeout(() =&gt; resolve(resolveMs), resolveMs)    }  })}</code></pre><pre><code>const testRaces = async () =&gt; {  const r1 = await promiseRaceOnRejected([    getPromise(0),     getPromise(5)  ])  // 0</code></pre><pre><code>const r2 = await promiseRaceCatch([    getPromise(0),     getPromise(5)  ])  // 0</code></pre><pre><code>const r3 = await promiseRaceOnRejected([    getPromise(5),     getPromise(null, 2)  ])    .catch(e =&gt; e)  // 2</code></pre><pre><code>const r4 = await promiseRaceCatch([    getPromise(5),     getPromise(null, 2)  ])    .catch(e =&gt; e)  // 2}</code></pre><pre><code>testRaces()</code></pre><p>As you can see, both polyfills work as expected. Arguments order and <code>rejected</code> promises handler variation don\u2019t matter. Until we try it with the next set of tests:</p><pre><code>const r5 = await promiseRaceOnRejected([    Promise.resolve('Resolve'),     Promise.reject('Reject')  ])  // Resolve</code></pre><pre><code>const r6 = await promiseRaceCatch([    Promise.resolve('Resolve'),     Promise.reject('Reject')  ])  // Resolve</code></pre><pre><code>const r7 = await promiseRaceOnRejected([    Promise.reject('Reject'),     Promise.resolve('Resolve')  ])    .catch(e =&gt; e)  // Reject</code></pre><pre><code>const r8 = await promiseRaceCatch([    Promise.reject('Reject'),     Promise.resolve('Resolve')  ])    .catch(e =&gt; e)  // ???</code></pre><p>The fifth, sixth and seventh races return expected values. What about the eighth? Instead of <code>Reject</code> it returns <code>Resolve</code> and it is not a bug.</p><h4 id=\"microtasks-queue\">Microtasks queue</h4><p>Depending on the job\u2019s result, a pending promise changes its state to <code>resolved</code> or <code>rejected</code>. JS environment puts that promise in a microtasks queue. Like it described in ECMA 2015 <a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\" rel=\"noopener\">specification</a>, this queue works by the <a href=\"https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)\" rel=\"noopener\">FIFO</a> principle \u2014 first in, first out. Base on this, let\u2019s review the eighth race\u2019s case.</p><p>At the start of the race, we already have two queued promises, and the rejected is first. <code>.then</code> without a second argument cannot handle a rejected promise, so it puts the promise back into the queue. And instead of handling this promise with <code>.catch</code>, the JS environment switches to <code>p2</code> because it has higher priorities in the queue.</p><figure><img alt=\"-ZAASKNuYIOZwBQBwd7XpBdvYecTiE2n0ZWF\" height=\"524\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/-ZAASKNuYIOZwBQBwd7XpBdvYecTiE2n0ZWF\" width=\"535\"/><figcaption>Queue\u2019s second tick</figcaption></figure><p>On next tick <code>.then</code> handles <code>p2</code> and the race ends with <code>Resolve</code> result.</p><p>Next time when you\u2019re choosing between the catch and onRejected handlers, remember not only which rejected promises they catch, but about the queuing difference too!</p>\n</section>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nby Max BelskyMost popular articles describe the difference between catch and onRejected in a code snippet like this:const getPromise = () => new Promise((resolve, reject) => {  Math.round(Math.random()) ?     resolve('resolve #1') :     reject('reject #1')})getPromise().then(result => {  throw new Error('reject #2')}, error => {  // Handles only 'reject #1'})getPromise().then(result => {  throw new Error('reject #2')})  .catch(error => {    // Handles both 'reject #1',     // and 'reject #2'  }))onRejected never handles rejected promises from the same .then(onFulfilled) callback and .catch takes both. However besides the behavior difference, there is one more nuance. It\u2019s about how these ways will be translated to microtasks and how they will be queued.Let\u2019s see an example of the difference.Promise.raceThere is a task \u2014 write Promise.race polyfill. We use a common pattern in both functions to handle resolved promises and different tools to handle rejected promises.const promiseRaceOnRejected = (promises = []) => {  return new Promise((resolve, reject) => {    promises.forEach(promise => {      promise.then(        result => resolve(result),        error => reject(error)      )    })  })}const promiseRaceCatch = (promises = []) => {  return new Promise((resolve, reject) => {    promises.forEach(promise => {      promise.then(result => resolve(result))        .catch(error => reject(error))    })  })}Try some tests to be sure that both solutions work well:// A helper function to create a delayed promiseconst getPromise = (resolveMs, rejectMs) => {  return new Promise((resolve, reject) => {    if ('number' === typeof rejectMs) {      setTimeout(() => reject(rejectMs), rejectMs)    }    if ('number' === typeof resolveMs) {      setTimeout(() => resolve(resolveMs), resolveMs)    }  })}const testRaces = async () => {  const r1 = await promiseRaceOnRejected([    getPromise(0),     getPromise(5)  ])  // 0const r2 = await promiseRaceCatch([    getPromise(0),     getPromise(5)  ])  // 0const r3 = await promiseRaceOnRejected([    getPromise(5),     getPromise(null, 2)  ])    .catch(e => e)  // 2const r4 = await promiseRaceCatch([    getPromise(5),     getPromise(null, 2)  ])    .catch(e => e)  // 2}testRaces()As you can see, both polyfills work as expected. Arguments order and rejected promises handler variation don\u2019t matter. Until we try it with the next set of tests:const r5 = await promiseRaceOnRejected([    Promise.resolve('Resolve'),     Promise.reject('Reject')  ])  // Resolveconst r6 = await promiseRaceCatch([    Promise.resolve('Resolve'),     Promise.reject('Reject')  ])  // Resolveconst r7 = await promiseRaceOnRejected([    Promise.reject('Reject'),     Promise.resolve('Resolve')  ])    .catch(e => e)  // Rejectconst r8 = await promiseRaceCatch([    Promise.reject('Reject'),     Promise.resolve('Resolve')  ])    .catch(e => e)  // ???The fifth, sixth and seventh races return expected values. What about the eighth? Instead of Reject it returns Resolve and it is not a bug.Microtasks queueDepending on the job\u2019s result, a pending promise changes its state to resolved or rejected. JS environment puts that promise in a microtasks queue. Like it described in ECMA 2015 specification, this queue works by the FIFO principle \u2014 first in, first out. Base on this, let\u2019s review the eighth race\u2019s case.At the start of the race, we already have two queued promises, and the rejected is first. .then without a second argument cannot handle a rejected promise, so it puts the promise back into the queue. And instead of handling this promise with .catch, the JS environment switches to p2 because it has higher priorities in the queue.Queue\u2019s second tickOn next tick .then handles p2 and the race ends with Resolve result.Next time when you\u2019re choosing between the catch and onRejected handlers, remember not only which rejected promises they catch, but about the queuing difference too!\n\n                        \n                    \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 4544, "excerpt": "by Max Belsky\n\nThe real difference between catch vs onRejected\nMost popular articles describe the difference between catch and onRejected in a\ncode snippet like this:\n\nconst getPromise = () => new Promise((resolve, reject) => {  Math.round(Math.random()) ?     resolve('resolve #1') :     reject('reject #1')})\n\ngetPromise().then(result => {  throw new Error('reject #2')}, error => {  // Handles only 'reject #1'})\n\ngetPromise().then(result => {  throw new Error('reject #2')})  .catch(error => {", "siteName": "freeCodeCamp.org", "publishedTime": "2019-04-24T22:08:33.000Z", "id": "fb4e572940e387b41959aeb3ac9a41b7e4079e22", "url": "https://www.freecodecamp.org/news/the-real-difference-between-catch-vs-onrejected-15cab8978e92/", "domain": "freecodecamp.org", "date": "2023-12-27T18:11:25.696416", "resultUri": "http://localhost:3000/result/fb4e572940e387b41959aeb3ac9a41b7e4079e22", "query": {"url": ["https://www.freecodecamp.org/news/the-real-difference-between-catch-vs-onrejected-15cab8978e92/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "The real difference between catch vs onRejected", "description": "by Max Belsky The real difference between catch vs onRejected Most popular articles describe the difference between catch and onRejected in a code snippet like this: const getPromise = () => new Promise((resolve, reject) => {  Math.round(Math.random()) ?     resolve('resolve #1') :    ", "url": "https://www.freecodecamp.org/news/the-real-difference-between-catch-vs-onrejected-15cab8978e92/", "image": "https://cdn-media-1.freecodecamp.org/images/1*JLtSGRqnw1wIR-o3LPziwA.png", "image:width": "533", "image:height": "417"}, "twitter": {"card": "summary_large_image", "title": "The real difference between catch vs onRejected", "description": "by Max Belsky The real difference between catch vs onRejected Most popular articles describe the difference between catch and onRejected in a code snippet like this: const getPromise = () => new Promise((resolve, reject) => {  Math.round(Math.random()) ?     resolve('resolve #1') :    ", "url": "https://www.freecodecamp.org/news/the-real-difference-between-catch-vs-onrejected-15cab8978e92/", "image": "https://cdn-media-1.freecodecamp.org/images/1*JLtSGRqnw1wIR-o3LPziwA.png", "label1": "Written by", "data1": "freeCodeCamp.org", "label2": "Filed under", "data2": "JavaScript, Promises, Tech, Programming, Technology", "site": "@freecodecamp"}}}