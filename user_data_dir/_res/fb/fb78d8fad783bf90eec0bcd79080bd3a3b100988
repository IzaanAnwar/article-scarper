{"title": "An introduction to Angular Reactive Forms", "byline": "freeCodeCamp.org", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>An introduction to Angular Reactive Forms</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>by Gulfam Ansari</p><p>Angular uses two different approaches to handle forms. The first one is the Template Driven Approach and the other one is the Reactive Approach. Both approaches use different techniques to handle your form data. In the Template Driven Approach, we define the form structure in our HTML code. On the other hand, in the Reactive Approach, the structure of the form is defined in the component class.</p><p>The Reactive Approach is more complex as compared to the Template Driven Approach, because it can provide lots of other functionalities. In this article, we will create a contact form using the Angular Reactive Approach. So what are we waiting for? Let\u2019s dive deep into it.</p><h3 id=\"how-to-use-reactive-forms-in-angular\"><strong>How To Use Reactive Forms In Angular?</strong></h3><p>To implement Reactive Forms in Angular, we follow the below steps.</p><ol><li>Import the Reactive Form Module in the <code>app.module.ts</code> file.</li><li>Create an instance of <code>FormGroup</code> class in the component file and initialize the default values of all <code>FormControls</code>.</li><li>Bind the <code>FormGroup</code> and <code>FormConrtol</code> in the HTML code.</li></ol><h3 id=\"1-importing-the-reactiveformsmodule\">1. Importing The ReactiveFormsModule</h3><p>To use Reactive forms in your application you need to import <code>ReactiveFormsModule</code> in your parent <code>module.ts</code> file. This is just like how we import <code>FormsModule</code> in our<code>app.module.ts</code> file to use Template Driven forms.</p><pre><code>import { AppComponent } from './app.component';</code></pre><pre><code>import { BrowserModule } from '@angular/platform-browser';</code></pre><pre><code>import { NgModule } from '@angular/core';</code></pre><pre><code>import { BrowserAnimationsModule } from '@angular/platform-browser/animations';</code></pre><pre><code>import { ReactiveFormsModule } from '@angular/forms';</code></pre><pre><code>@NgModule({</code></pre><pre><code>declarations: [AppComponent],</code></pre><pre><code>imports: [</code></pre><pre><code>  BrowserModule,</code></pre><pre><code>  BrowserAnimationsModule,</code></pre><pre><code>  ReactiveFormsModule</code></pre><pre><code>],</code></pre><pre><code>providers: [],</code></pre><pre><code>bootstrap: [AppComponent]</code></pre><pre><code>})</code></pre><pre><code>export class AppModule { }</code></pre><h3 id=\"2-define-formgroup-in-the-component\">2. Define FormGroup In The Component</h3><p>As we know, in the Reactive Form Approach, the structure of the form is defined in the component file, and this structure is synced with HTML code using <code>formGroup</code> directive. So to create our contact form, we first need to define our form model in the component class.</p><p><strong>Form Control </strong>is the smallest building block of a reactive form which keeps track of all HTML input value and their validations.</p><p><strong>Form Group </strong>is a collection of FormControls which combines all the HTML input values into a single object.</p><p>Now it\u2019s time to create our contact form component file.</p><pre><code>import { Component, OnInit } from '@angular/core';</code></pre><pre><code>import { FormGroup, FormControl } from '@angular/forms';</code></pre><pre><code>@Component({</code></pre><pre><code>  selector: 'app-contact',</code></pre><pre><code>  templateUrl: './contact.component.html',</code></pre><pre><code>  styleUrls: ['./contact.component.scss']</code></pre><pre><code>})</code></pre><pre><code>export class ContactFormComponent implements OnInit {</code></pre><pre><code>  public contactForm: FormGroup;</code></pre><pre><code>  constructor() { } </code></pre><pre><code>  ngOnInit() {</code></pre><pre><code>    this.contactForm = new FormGroup({</code></pre><pre><code>      'name': new FormControl(null),</code></pre><pre><code>      'email': new FormControl(null),</code></pre><pre><code>      'subject': new FormControl(null),</code></pre><pre><code>      'message': new FormControl(null)</code></pre><pre><code>    });</code></pre><pre><code>  }</code></pre><pre><code>}</code></pre><p>In the above code, we import FormGroup class from <code>@angular/forms</code> and declare the <code>FormGroup</code> property named as <code>contactform</code>.</p><p>Define all the <code>FormControl</code> and group them using <code>FormGroup</code> and assign it to <code>contactForm</code>.</p><h3 id=\"3-bind-the-formcontrols-in-the-html-file\">3. Bind the FormControls in the HTML File</h3><p>Bind our FormGroup property in the Template using the <code>formGroup</code> directive.</p><p>Wire up all FormControls in the Template using <code>formControlName</code> directive to map each input element of the HTML.</p><p>We are also using <code>ngSubmit</code> directive to post the form data by clicking on the submit button.</p><pre><code>&lt;form [formGroup]=\"contactForm\" (ngSubmit)=\"onSubmit()\"&gt;</code></pre><pre><code>&lt;input type=\"text\" name=\"name\" placeholder=\"Your name\"    formControlName=\"name\"&gt;</code></pre><pre><code>&lt;input type=\"text\" name=\"email\" placeholder=\"Your email\" formControlName=\"email\"&gt;</code></pre><pre><code>&lt;input type=\"text\" name=\"subject\" placeholder=\"Subject\" formControlName=\"subject\"&gt;</code></pre><pre><code>&lt;textarea name=\"message\" placeholder=\"Your Message\" formControlName=\"message\"&gt;&lt;/textarea&gt;</code></pre><pre><code>&lt;button type=\"submit\" class=\"btn btn-large\"&gt;Send Message&lt;/button&gt;</code></pre><pre><code>&lt;/form&gt;</code></pre><h3 id=\"validation\">Validation</h3><p>You have implemented the basic version of a Reactive form. Now take a step upward and validate your input values before sending them to the database.</p><p>Actually, we do lots of validation in the backend layer before sending the data to the database, but to make our app faster we introduce some validation at the client side as well. Angular ReactiveForm module does this validation job very effectively. So let's validate our inputs before sending them to the database.</p><p>To add validators in your form, we need to import <code>Validators</code> class from <code>@angular/form.</code> and add validators while creating new FormControl object.</p><p>The FormControl class constructor takes 3 arguments.</p><ol><li>The default value of an input</li><li>Validator or Array of Validators</li><li>Async Validators</li></ol><p>For form validation, we are using the 2nd argument of the FormControl class constructor.</p><pre><code>this.contactForm = new FormGroup({</code></pre><pre><code>  'name': new FormControl(Enter Name, Validators.required),</code></pre><pre><code>  'email': new FormControl(null, [Validators.email,           Validators.pattern('[a-z0-9.@]*')]),</code></pre><pre><code>  'subject': new FormControl(null, Validators.minLength(10)),</code></pre><pre><code>  'message': new FormControl(null, Validators.required)</code></pre><pre><code>});</code></pre><p>You can add more Validators by adding them into the array of Validators.</p><h3 id=\"custom-validators\">Custom Validators</h3><p>The FormControl class gives you lots of built-in validator functions that cover lots of your use cases. But if you want to add some custom checks for your input values, then you can easily do this using your own validator functions.</p><p>You can pass custom validator functions along with built-in validators while creating the FormControl object.</p><pre><code>export class ContactFormComponent implements OnInit {</code></pre><pre><code>  public contactForm: FormGroup;  public forbiddenUserNames = ['Mack', 'John'];</code></pre><pre><code>  constructor() { }</code></pre><pre><code>  ngOnInit() {</code></pre><pre><code>    this.contactForm = new FormGroup({</code></pre><pre><code>      'name': new FormControl(Enter Name, [Validators.required, this.forbiddenNames.bind(this)]),</code></pre><pre><code>      'email': new FormControl(null, [Validators.email,           Validators.pattern('[a-z0-9.@]*')]),</code></pre><pre><code>      'subject': new FormControl(null, Validators.minLength(10)),</code></pre><pre><code>      'message': new FormControl(null, Validators.required)</code></pre><pre><code>   });</code></pre><pre><code> }</code></pre><pre><code>public forbiddenNames(formControl: FormControl): any {   if ( this.forbiddenUserNames.indexOf(formControl.value)){     return { 'nameForbidden': true };    }   }}</code></pre><p>In the above code, we are creating our custom validator function which checks whether the name of the user is valid or not. The <code>forbiddenNames</code> function takes an argument of FormControl type and checks whether the input name is present in the <code>forbiddenUserNames</code> array.</p><h3 id=\"async-validators\">Async Validators</h3><p>As the name defines that the validation is done in an asynchronous manner. When the result of input validators takes some time to validate the input values then we use Async Validators.</p><p>Let's create a validator function which responds after 1 second and returns the status of the input whether the input is valid or not. For async validators, we have to return a Promise or an Observable in place of return an object.</p><pre><code>export class ContactFormComponent implements OnInit {</code></pre><pre><code>  public contactForm: FormGroup;  public forbiddenUserNames = ['Mack', 'John'];</code></pre><pre><code>  constructor() { }</code></pre><pre><code>  ngOnInit() {</code></pre><pre><code>    this.contactForm = new FormGroup({</code></pre><pre><code>      'name': new FormControl(Enter Name, [Validators.required, this.forbiddenNames.bind(this)]),</code></pre><pre><code>      'email': new FormControl(null, [Validators.email,           Validators.pattern('[a-z0-9.@]*')], this.forbiddenEmail),</code></pre><pre><code>      'subject': new FormControl(null, Validators.minLength(10)),</code></pre><pre><code>      'message': new FormControl(null, Validators.required)</code></pre><pre><code>   });</code></pre><pre><code>}</code></pre><pre><code>public forbiddenNames(formControl: FormControl): any {   if ( this.forbiddenUserNames.indexOf(formControl.value)){       return { 'nameForbidden': true };    } else {      retunr null;    }</code></pre><pre><code>  }</code></pre><pre><code>public forbiddenEmail(formControl: FormControl): Promise&lt;any&gt; {   return new Promise((resolve, reject)=&gt;{     setTimeout(()=&gt;{       if (formControl.value === 'abc@gmail.com'){         resolve({ 'emailForbidden': true });       } else {        resolve(null);       }</code></pre><pre><code>     }, 1000);</code></pre><pre><code>   });  }}</code></pre><p>We have to pass our newly created Async validator function into the third argument of <code>FormControl</code> object. We can pass a single Async validator or array of async validators as we pass in normal validators.</p><h3 id=\"formarray\">FormArray</h3><p>So till now, we have been creating the <code>FormControl</code> for every input. But what if the user has access to add their FormControls? <code>FormArray</code> is a class imported from <code>@angular/core</code> which is used to create dynamic FormControls.</p><p>Let's update our contact form with an additional input hobby and this input will be created by the user.</p><pre><code>ngOnInit() {  this.contactForm = new FormGroup({</code></pre><pre><code>    'name': new FormControl(Enter Name, [Validators.required, this.forbiddenNames.bind(this)]),</code></pre><pre><code>    'email': new FormControl(null, [Validators.email,           Validators.pattern('[a-z0-9.@]*')], this.forbiddenEmail),</code></pre><pre><code>    'subject': new FormControl(null, Validators.minLength(10)),</code></pre><pre><code>    'message': new FormControl(null, Validators.required),    'hobbies': new FormArray([])</code></pre><pre><code>  });}</code></pre><pre><code>public addHobby() {  (&lt;FormArray&gt;this.contactForm.get('hobbies')).push(new FormControl(null));}</code></pre><p>In the above code the <code>addHobby</code> function will be executed whenever the user clicks on the <code>Add Hobby</code> button. This function will push the new FormControl into the FormArray. Now bind the hobbies FormArray with our Template.</p><pre><code>&lt;div formArrayName=\"hobbies\"&gt;  &lt;button type=\"button\"&gt;Add Hobby&lt;/button&gt;  &lt;div *ngFor=\"let hobbyControl of this.contactForm.get('hobbies');  let i=index\"&gt;    &lt;input type=\"text\" [formControlName\"]=\"i\"&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><p>In the above code, we are using <code>formArrayName</code> directive to bind the FormArray like <code>formControlName</code> for binding the FormControls.</p><p>I hope this article answered most of your questions regarding Angular Reactive Forms. If you have any queries or doubts, feel free to reach out to me in the comment box.</p>\n</section>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nby Gulfam AnsariAngular uses two different approaches to handle forms. The first one is the Template Driven Approach and the other one is the Reactive Approach. Both approaches use different techniques to handle your form data. In the Template Driven Approach, we define the form structure in our HTML code. On the other hand, in the Reactive Approach, the structure of the form is defined in the component class.The Reactive Approach is more complex as compared to the Template Driven Approach, because it can provide lots of other functionalities. In this article, we will create a contact form using the Angular Reactive Approach. So what are we waiting for? Let\u2019s dive deep into it.How To Use Reactive Forms In Angular?To implement Reactive Forms in Angular, we follow the below steps.Import the Reactive Form Module in the app.module.ts file.Create an instance of FormGroup class in the component file and initialize the default values of all FormControls.Bind the FormGroup and FormConrtol in the HTML code.1. Importing The ReactiveFormsModuleTo use Reactive forms in your application you need to import ReactiveFormsModule in your parent module.ts file. This is just like how we import FormsModule in ourapp.module.ts file to use Template Driven forms.import { AppComponent } from './app.component';import { BrowserModule } from '@angular/platform-browser';import { NgModule } from '@angular/core';import { BrowserAnimationsModule } from '@angular/platform-browser/animations';import { ReactiveFormsModule } from '@angular/forms';@NgModule({declarations: [AppComponent],imports: [  BrowserModule,  BrowserAnimationsModule,  ReactiveFormsModule],providers: [],bootstrap: [AppComponent]})export class AppModule { }2. Define FormGroup In The ComponentAs we know, in the Reactive Form Approach, the structure of the form is defined in the component file, and this structure is synced with HTML code using formGroup directive. So to create our contact form, we first need to define our form model in the component class.Form Control is the smallest building block of a reactive form which keeps track of all HTML input value and their validations.Form Group is a collection of FormControls which combines all the HTML input values into a single object.Now it\u2019s time to create our contact form component file.import { Component, OnInit } from '@angular/core';import { FormGroup, FormControl } from '@angular/forms';@Component({  selector: 'app-contact',  templateUrl: './contact.component.html',  styleUrls: ['./contact.component.scss']})export class ContactFormComponent implements OnInit {  public contactForm: FormGroup;  constructor() { }   ngOnInit() {    this.contactForm = new FormGroup({      'name': new FormControl(null),      'email': new FormControl(null),      'subject': new FormControl(null),      'message': new FormControl(null)    });  }}In the above code, we import FormGroup class from @angular/forms and declare the FormGroup property named as contactform.Define all the FormControl and group them using FormGroup and assign it to contactForm.3. Bind the FormControls in the HTML FileBind our FormGroup property in the Template using the formGroup directive.Wire up all FormControls in the Template using formControlName directive to map each input element of the HTML.We are also using ngSubmit directive to post the form data by clicking on the submit button.<form [formGroup]=\"contactForm\" (ngSubmit)=\"onSubmit()\"><input type=\"text\" name=\"name\" placeholder=\"Your name\"    formControlName=\"name\"><input type=\"text\" name=\"email\" placeholder=\"Your email\" formControlName=\"email\"><input type=\"text\" name=\"subject\" placeholder=\"Subject\" formControlName=\"subject\"><textarea name=\"message\" placeholder=\"Your Message\" formControlName=\"message\"></textarea><button type=\"submit\" class=\"btn btn-large\">Send Message</button></form>ValidationYou have implemented the basic version of a Reactive form. Now take a step upward and validate your input values before sending them to the database.Actually, we do lots of validation in the backend layer before sending the data to the database, but to make our app faster we introduce some validation at the client side as well. Angular ReactiveForm module does this validation job very effectively. So let's validate our inputs before sending them to the database.To add validators in your form, we need to import Validators class from @angular/form. and add validators while creating new FormControl object.The FormControl class constructor takes 3 arguments.The default value of an inputValidator or Array of ValidatorsAsync ValidatorsFor form validation, we are using the 2nd argument of the FormControl class constructor.this.contactForm = new FormGroup({  'name': new FormControl(Enter Name, Validators.required),  'email': new FormControl(null, [Validators.email,           Validators.pattern('[a-z0-9.@]*')]),  'subject': new FormControl(null, Validators.minLength(10)),  'message': new FormControl(null, Validators.required)});You can add more Validators by adding them into the array of Validators.Custom ValidatorsThe FormControl class gives you lots of built-in validator functions that cover lots of your use cases. But if you want to add some custom checks for your input values, then you can easily do this using your own validator functions.You can pass custom validator functions along with built-in validators while creating the FormControl object.export class ContactFormComponent implements OnInit {  public contactForm: FormGroup;  public forbiddenUserNames = ['Mack', 'John'];  constructor() { }  ngOnInit() {    this.contactForm = new FormGroup({      'name': new FormControl(Enter Name, [Validators.required, this.forbiddenNames.bind(this)]),      'email': new FormControl(null, [Validators.email,           Validators.pattern('[a-z0-9.@]*')]),      'subject': new FormControl(null, Validators.minLength(10)),      'message': new FormControl(null, Validators.required)   }); }public forbiddenNames(formControl: FormControl): any {   if ( this.forbiddenUserNames.indexOf(formControl.value)){     return { 'nameForbidden': true };    }   }}In the above code, we are creating our custom validator function which checks whether the name of the user is valid or not. The forbiddenNames function takes an argument of FormControl type and checks whether the input name is present in the forbiddenUserNames array.Async ValidatorsAs the name defines that the validation is done in an asynchronous manner. When the result of input validators takes some time to validate the input values then we use Async Validators.Let's create a validator function which responds after 1 second and returns the status of the input whether the input is valid or not. For async validators, we have to return a Promise or an Observable in place of return an object.export class ContactFormComponent implements OnInit {  public contactForm: FormGroup;  public forbiddenUserNames = ['Mack', 'John'];  constructor() { }  ngOnInit() {    this.contactForm = new FormGroup({      'name': new FormControl(Enter Name, [Validators.required, this.forbiddenNames.bind(this)]),      'email': new FormControl(null, [Validators.email,           Validators.pattern('[a-z0-9.@]*')], this.forbiddenEmail),      'subject': new FormControl(null, Validators.minLength(10)),      'message': new FormControl(null, Validators.required)   });}public forbiddenNames(formControl: FormControl): any {   if ( this.forbiddenUserNames.indexOf(formControl.value)){       return { 'nameForbidden': true };    } else {      retunr null;    }  }public forbiddenEmail(formControl: FormControl): Promise<any> {   return new Promise((resolve, reject)=>{     setTimeout(()=>{       if (formControl.value === 'abc@gmail.com'){         resolve({ 'emailForbidden': true });       } else {        resolve(null);       }     }, 1000);   });  }}We have to pass our newly created Async validator function into the third argument of FormControl object. We can pass a single Async validator or array of async validators as we pass in normal validators.FormArraySo till now, we have been creating the FormControl for every input. But what if the user has access to add their FormControls? FormArray is a class imported from @angular/core which is used to create dynamic FormControls.Let's update our contact form with an additional input hobby and this input will be created by the user.ngOnInit() {  this.contactForm = new FormGroup({    'name': new FormControl(Enter Name, [Validators.required, this.forbiddenNames.bind(this)]),    'email': new FormControl(null, [Validators.email,           Validators.pattern('[a-z0-9.@]*')], this.forbiddenEmail),    'subject': new FormControl(null, Validators.minLength(10)),    'message': new FormControl(null, Validators.required),    'hobbies': new FormArray([])  });}public addHobby() {  (<FormArray>this.contactForm.get('hobbies')).push(new FormControl(null));}In the above code the addHobby function will be executed whenever the user clicks on the Add Hobby button. This function will push the new FormControl into the FormArray. Now bind the hobbies FormArray with our Template.<div formArrayName=\"hobbies\">  <button type=\"button\">Add Hobby</button>  <div *ngFor=\"let hobbyControl of this.contactForm.get('hobbies');  let i=index\">    <input type=\"text\" [formControlName\"]=\"i\">  </div></div>In the above code, we are using formArrayName directive to bind the FormArray like formControlName for binding the FormControls.I hope this article answered most of your questions regarding Angular Reactive Forms. If you have any queries or doubts, feel free to reach out to me in the comment box.\n\n                        \n                    \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 10255, "excerpt": "by Gulfam Ansari\n\nAn introduction to Angular Reactive Forms\nAngular uses two different approaches to handle forms. The first one is the\nTemplate Driven Approach and the other one is the Reactive Approach. Both\napproaches use different techniques to handle your form data. In the Template\nDriven Approach, we define the form structure in our HTML code. On the other\nhand, in the Reactive Approach, the structure of the form is defined in the\ncomponent class.\n\nThe Reactive Approach is more complex as", "siteName": "freeCodeCamp.org", "publishedTime": "2019-05-04T11:40:11.000Z", "id": "fb78d8fad783bf90eec0bcd79080bd3a3b100988", "url": "https://www.freecodecamp.org/news/angular-reactive-forms-an-introduction-f9d988ae9251/", "domain": "freecodecamp.org", "date": "2023-12-27T18:10:37.974644", "resultUri": "http://localhost:3000/result/fb78d8fad783bf90eec0bcd79080bd3a3b100988", "query": {"url": ["https://www.freecodecamp.org/news/angular-reactive-forms-an-introduction-f9d988ae9251/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "An introduction to Angular Reactive Forms", "description": "by Gulfam Ansari An introduction to Angular Reactive Forms Angular uses two different approaches to handle forms. The first one is the Template Driven Approach and the other one is the Reactive Approach. Both approaches use different techniques to handle your form data. In the Template Driven Approach, we define", "url": "https://www.freecodecamp.org/news/angular-reactive-forms-an-introduction-f9d988ae9251/", "image": "https://cdn-media-1.freecodecamp.org/images/1*NwUCxqLzu4PfMDwsfA8Bvw.jpeg", "image:width": "800", "image:height": "480"}, "twitter": {"card": "summary_large_image", "title": "An introduction to Angular Reactive Forms", "description": "by Gulfam Ansari An introduction to Angular Reactive Forms Angular uses two different approaches to handle forms. The first one is the Template Driven Approach and the other one is the Reactive Approach. Both approaches use different techniques to handle your form data. In the Template Driven Approach, we define", "url": "https://www.freecodecamp.org/news/angular-reactive-forms-an-introduction-f9d988ae9251/", "image": "https://cdn-media-1.freecodecamp.org/images/1*NwUCxqLzu4PfMDwsfA8Bvw.jpeg", "label1": "Written by", "data1": "freeCodeCamp.org", "label2": "Filed under", "data2": "JavaScript, Angular, HTML, Tech, Programming", "site": "@freecodecamp"}}}