{"title": "How to Sort a List Recursively in Python", "byline": "P S Mohammed Ali", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>How to Sort a List Recursively in Python</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>When you want to sort a list or array in Python, there are many sorting algorithms you can use. </p><p>Some use looping concepts like Insertion Sort, Bubble Sort, and Selection Sort. On the other hand, you can also sort the same list or array using Merge Sort with the help of recursion.</p><p>In this article, you will learn how the Merge Sort algorithm works. You will also learn how recursion plays an important role in Merge Sort. </p><h2 id=\"how-recursion-works\">How Recursion Works</h2><p>As a prerequisite, we will first understand how recursion works, as it's the backbone of the merge sort algorithm.</p><p>First, you should know that a recursive function is one that calls itself until it reaches its desired outcome.</p><p>Now, unless you set some condition to stop this process, it'll go on forever \u2013 or until your JS code throws an error. This is known as a base case, and it will stop the function from calling itself when its condition is met.</p><p>Now that you know the basics of recursion, let's get into the weeds a bit and understand how it works under the hood:</p><p>In general, recursion works based on a concept called Principal Mathematical Induction (PMI). In simple words, PMI is a technique which is used to prove certain statements from a basic set of proven statements. </p><p>Usually, there are three steps in this process.</p><p>Let's prove that the formula of n natural number is <code>P(n)= n*(n+1)/2</code> using PMI:</p><figure><img alt=\"123\" height=\"98\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2022/09/123.PNG\" width=\"183\"/><figcaption>To prove that P(n) is true</figcaption></figure><p>Step 1: The first step is also known as the <strong>base case</strong>. During this step, you specify the proven statements. Universally, we know that the sum of the first 1 natural number is <code>1</code>. Let's consider it the left-hand side of the equation (LHS).</p><p>When we apply <code>n = 1</code> in the the formula, we get <code>p(1) = 1*(1+1)/2 =&gt; 1</code> as the right-hand side (RHS).</p><figure><img alt=\"1234\" height=\"177\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2022/09/1234.PNG\" width=\"307\"/><figcaption>Applying 1 in formula</figcaption></figure><p>This means that LHS = RHS. This step confirms it's a valid base case.</p><p>Step 2: This step is known as the <strong>Induction Hypothesis</strong>. In this step, we simply assume that this formula is true for some integer <code>k</code> where <code>1 &lt; k &lt; n</code>. So, we substitute k in the formula and we get <code>p(k) = k*(k+1)/2</code>:</p><figure><img alt=\"12345\" height=\"102\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2022/09/12345.PNG\" width=\"232\"/><figcaption>Induction Hypothesis step for some Integer value k</figcaption></figure><p>Step 3: This step is known as<strong> the Induction Step</strong>. At this point, we have to prove that this will work for the integer <code>k+1</code>. </p><p>When we substitute <code>k + 1</code> in the formula and consider it as the LHS, then we get the following: </p><figure><img alt=\"125\" height=\"169\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2022/09/125.PNG\" width=\"401\"/><figcaption>LHS Statement for P(k+1)</figcaption></figure><p>For the RHS, we know that the sum of the natural number <code>k+1</code> integer is equal to the sum of the natural number of <code>k</code> integer and <code>k+1</code>th integer. We can write it like this: </p><figure><img alt=\"21\" height=\"142\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2022/09/21.PNG\" width=\"349\"/><figcaption>Sum of k+1 integers is equal to (k+1)th integer and sum of k Integers</figcaption></figure><p>The above equation can be rewritten like this:</p><figure><img alt=\"22\" height=\"126\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2022/09/22.PNG\" width=\"359\"/><figcaption>sum of k natural integers is rewritten as p(k) from step-2</figcaption></figure><p>At this point, we know the value of p(k) from step-2 (Induction Hypothesis). When we substitute the value of p(k), we get this:</p><figure><img alt=\"23\" height=\"107\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2022/09/23.PNG\" width=\"427\"/><figcaption>Substitute p(k) from step-2</figcaption></figure><p>We can take the common denominator and simplify the equation, and we get:</p><figure><img alt=\"37\" height=\"228\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2022/09/37.PNG\" width=\"503\"/><figcaption>Simplifying the equation</figcaption></figure><p>On comparing the LHS and RHS, we get the same result and we have proved that this formula works for <code>k+1</code> integers. </p><p>Also, when we substitute <code>n</code> in the place of <code>k+1</code>, we get the end result as:</p><figure><img alt=\"45\" height=\"244\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2022/09/45.PNG\" width=\"402\"/><figcaption>Substituting k+1 with n</figcaption></figure><p> We have proven that formula for n natural number is n*(n+1)/2.</p><p>When we observe all the steps in PMI, we did a simple assumption at step-2 and and therefore, we proved the statement at step-3. </p><p>This is how recursion works: we initialize a base case for a problem at the start of the function and we assume that this function works for small values of the same problem. Then as the final step, we prove that this works for the existing problem. </p><h2 id=\"how-the-merge-sort-algorithm-works\">How the Merge Sort Algorithm Works</h2><p>The Merge Sort algorithm works by breaking down an unsorted list into two halves. You then call the merge sort on each of these two parts. </p><p>Since, we know recursion works based on Principal Mathematical Induction (PMI), we assume that the smaller lists gets sorted on calling merge sort on these 2 smaller lists.</p><blockquote><strong>Note:</strong> Before calling recursion in smaller lists, it's more important to define a base case for the function as it acts as a stopping point for the recursive call. </blockquote><p>Here, the base case for the merge sort will be if the length of the list is 1. In that case (if the length is 1, it means there's only one item in the list), the list is already sorted so we have to just return the list as it is.</p><p>For more clarity, let's take an example and implement merge sort over the unsorted list.</p><figure><pre tabindex=\"0\"><code>my_list = [3,8,2,7,1,4,5] </code></pre><figcaption>unsorted list</figcaption></figure><p>In the code above, you can see that the variable <code>my_list</code> contains a list which is unsorted.</p><p>Now, since the length of my_list is not 1, we can't assume that it is sorted. So, we call merge sort on first half <code>list1 = [3,8,2]</code> and also call merge sort on second half <code>list2 = [7,1,4,5]</code>.</p><p>We assume that <code>list1</code> and <code>list2</code> are sorted as per the induction step. Now, the list looks like <code>list1 = [2,3,8]</code> and <code>list2 = [1,4,5,7]</code>. Now, all we have to do is just merge those two sorted lists into one using the two pointer technique.</p><p>In order to combine and sort the two smaller sorted lists, we take 2 pointers, pointing at the start of each list.</p><figure><img alt=\"56\" height=\"200\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2022/09/56.PNG\" width=\"526\"/><figcaption>Pointers at start index of list and empty list to append the new list while comparing</figcaption></figure><figure><img alt=\"333\" height=\"207\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2022/09/333.PNG\" width=\"518\"/><figcaption>Intermediate step in comparing pointer value process</figcaption></figure><p>We are comparing the value at each place the pointer points, and whichever is smaller we append that value next in the final list. Then we move the pointer place to the next index. </p><p>After looping through this process, when we reach the first final index (in one of the two loops we're joining) we stop the loop. Then we append all the values in the other list (if any remain) to the final list. </p><p>Using this technique, we can merge and sort the two small pre-sorted lists.</p><figure><img alt=\"Blank-diagram--1-\" height=\"609\" loading=\"lazy\" sizes=\"(min-width: 720px) 720px\" src=\"https://www.freecodecamp.org/news/content/images/2022/09/Blank-diagram--1-.png\" srcset=\"https://www.freecodecamp.org/news/content/images/size/w600/2022/09/Blank-diagram--1-.png 600w, https://www.freecodecamp.org/news/content/images/2022/09/Blank-diagram--1-.png 740w\" width=\"740\"/><figcaption>Working Flow of Merge Sort</figcaption></figure><p>When we're using recursion, we assume that it works when we call the same function for a smaller problem. This assumption comes from the induction hypothesis step in PMI. </p><p>So when we declare the base case for the problem, we similarly assume that the function will return the correct answer for smaller problems. All we have to do is prove that this works for larger problems, too.</p><p>In this algorithm, we declared that the base case is that for a list length of 1, the list is sorted. In the induction hypothesis step, we assumed that algorithm would work for half of the list. In the third step, we just merged the sorted list and proved that this will work on a larger list.</p><h2 id=\"python-code-for-the-merge-sort-algorithm\">Python Code for the Merge Sort Algorithm</h2><figure><pre tabindex=\"0\"><code>def merge_sort(my_list):\n\n\t# Base Case\n    if len(my_list) &lt;= 1:\n        return my_list\n   \n    list_1 = my_list[0:len(my_list) // 2]\n    list_2 = my_list[len(my_list) // 2:]\n    \n   \t# Induction Step\n    ans_1 = merge_sort(list_1)\n    ans_2 = merge_sort(list_2)\n    \n    # Sorting and merging two sorted list\n    sort_list = sort_two_list(ans_1, ans_2)\n    return sort_list\n\n\n\n# Separate Function to sort and merge 2 sorted lists\ndef sort_two_list(list_1, list_2):\n    final_list = []\n    i = 0\n    j = 0\n    while i &lt; len(list_1) and j &lt; len(list_2):\n        if list_1[i] &lt;= list_2[j]:\n            final_list.append(list_1[i])\n            i += 1\n            continue\n        final_list.append(list_2[j])\n        j += 1\n\n    while i &lt; len(list_1):\n        final_list.append(list_1[i])\n        i = i + 1\n        \n    while j &lt; len(list_2):\n        final_list.append(list_2[j])\n        j = j + 1\n        \n    return final_list\n\n\nmy_list = [3, 8, 2, 7, 1, 4, 5]\nans = merge_sort(my_list)\nprint(ans)\n# prints [1, 2, 3, 4, 5, 7, 8]</code></pre><figcaption>Implementation of Merge Sort Algorithm in Python</figcaption></figure><p>As you see in the above code, I have implemented two separate functions for sorting and merging the two sorted lists. This leads to better readability and easier code reviews.</p><p>The main drawback in merge sort is it uses more space. This is because, at every recursive call, a new list gets created and recursion is called on that new list. So space complexity for the worst case scenario is <code>O(n)</code> and time complexity is <code>O(n log n)</code>.</p><h2 id=\"conclusion\">Conclusion</h2><p>Merge Sort is pretty quick in sorting a list recursively from a time complexity perspective. This is useful for counting inversions in lists and it's widely used for external sorting applications than other sorting algorithms.</p><p>Happy programming...</p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nWhen you want to sort a list or array in Python, there are many sorting algorithms you can use. Some use looping concepts like Insertion Sort, Bubble Sort, and Selection Sort. On the other hand, you can also sort the same list or array using Merge Sort with the help of recursion.In this article, you will learn how the Merge Sort algorithm works. You will also learn how recursion plays an important role in Merge Sort. How Recursion WorksAs a prerequisite, we will first understand how recursion works, as it's the backbone of the merge sort algorithm.First, you should know that a recursive function is one that calls itself until it reaches its desired outcome.Now, unless you set some condition to stop this process, it'll go on forever \u2013 or until your JS code throws an error. This is known as a base case, and it will stop the function from calling itself when its condition is met.Now that you know the basics of recursion, let's get into the weeds a bit and understand how it works under the hood:In general, recursion works based on a concept called Principal Mathematical Induction (PMI). In simple words, PMI is a technique which is used to prove certain statements from a basic set of proven statements. Usually, there are three steps in this process.Let's prove that the formula of n natural number is P(n)= n*(n+1)/2 using PMI:To prove that P(n) is trueStep 1: The first step is also known as the base case. During this step, you specify the proven statements. Universally, we know that the sum of the first 1 natural number is 1. Let's consider it the left-hand side of the equation (LHS).When we apply n = 1 in the the formula, we get p(1) = 1*(1+1)/2 => 1 as the right-hand side (RHS).Applying 1 in formulaThis means that LHS = RHS. This step confirms it's a valid base case.Step 2: This step is known as the Induction Hypothesis. In this step, we simply assume that this formula is true for some integer k where 1 < k < n. So, we substitute k in the formula and we get p(k) = k*(k+1)/2:Induction Hypothesis step for some Integer value kStep 3: This step is known as the Induction Step. At this point, we have to prove that this will work for the integer k+1. When we substitute k + 1 in the formula and consider it as the LHS, then we get the following: LHS Statement for P(k+1)For the RHS, we know that the sum of the natural number k+1 integer is equal to the sum of the natural number of k integer and k+1th integer. We can write it like this: Sum of k+1 integers is equal to (k+1)th integer and sum of k IntegersThe above equation can be rewritten like this:sum of k natural integers is rewritten as p(k) from step-2At this point, we know the value of p(k) from step-2 (Induction Hypothesis). When we substitute the value of p(k), we get this:Substitute p(k) from step-2We can take the common denominator and simplify the equation, and we get:Simplifying the equationOn comparing the LHS and RHS, we get the same result and we have proved that this formula works for k+1 integers. Also, when we substitute n in the place of k+1, we get the end result as:Substituting k+1 with n We have proven that formula for n natural number is n*(n+1)/2.When we observe all the steps in PMI, we did a simple assumption at step-2 and and therefore, we proved the statement at step-3. This is how recursion works: we initialize a base case for a problem at the start of the function and we assume that this function works for small values of the same problem. Then as the final step, we prove that this works for the existing problem. How the Merge Sort Algorithm WorksThe Merge Sort algorithm works by breaking down an unsorted list into two halves. You then call the merge sort on each of these two parts. Since, we know recursion works based on Principal Mathematical Induction (PMI), we assume that the smaller lists gets sorted on calling merge sort on these 2 smaller lists.Note: Before calling recursion in smaller lists, it's more important to define a base case for the function as it acts as a stopping point for the recursive call. Here, the base case for the merge sort will be if the length of the list is 1. In that case (if the length is 1, it means there's only one item in the list), the list is already sorted so we have to just return the list as it is.For more clarity, let's take an example and implement merge sort over the unsorted list.my_list = [3,8,2,7,1,4,5] unsorted listIn the code above, you can see that the variable my_list contains a list which is unsorted.Now, since the length of my_list is not 1, we can't assume that it is sorted. So, we call merge sort on first half list1 = [3,8,2] and also call merge sort on second half list2 = [7,1,4,5].We assume that list1 and list2 are sorted as per the induction step. Now, the list looks like list1 = [2,3,8] and list2 = [1,4,5,7]. Now, all we have to do is just merge those two sorted lists into one using the two pointer technique.In order to combine and sort the two smaller sorted lists, we take 2 pointers, pointing at the start of each list.Pointers at start index of list and empty list to append the new list while comparingIntermediate step in comparing pointer value processWe are comparing the value at each place the pointer points, and whichever is smaller we append that value next in the final list. Then we move the pointer place to the next index. After looping through this process, when we reach the first final index (in one of the two loops we're joining) we stop the loop. Then we append all the values in the other list (if any remain) to the final list. Using this technique, we can merge and sort the two small pre-sorted lists.Working Flow of Merge SortWhen we're using recursion, we assume that it works when we call the same function for a smaller problem. This assumption comes from the induction hypothesis step in PMI. So when we declare the base case for the problem, we similarly assume that the function will return the correct answer for smaller problems. All we have to do is prove that this works for larger problems, too.In this algorithm, we declared that the base case is that for a list length of 1, the list is sorted. In the induction hypothesis step, we assumed that algorithm would work for half of the list. In the third step, we just merged the sorted list and proved that this will work on a larger list.Python Code for the Merge Sort Algorithmdef merge_sort(my_list):\n\n\t# Base Case\n    if len(my_list) <= 1:\n        return my_list\n   \n    list_1 = my_list[0:len(my_list) // 2]\n    list_2 = my_list[len(my_list) // 2:]\n    \n   \t# Induction Step\n    ans_1 = merge_sort(list_1)\n    ans_2 = merge_sort(list_2)\n    \n    # Sorting and merging two sorted list\n    sort_list = sort_two_list(ans_1, ans_2)\n    return sort_list\n\n\n\n# Separate Function to sort and merge 2 sorted lists\ndef sort_two_list(list_1, list_2):\n    final_list = []\n    i = 0\n    j = 0\n    while i < len(list_1) and j < len(list_2):\n        if list_1[i] <= list_2[j]:\n            final_list.append(list_1[i])\n            i += 1\n            continue\n        final_list.append(list_2[j])\n        j += 1\n\n    while i < len(list_1):\n        final_list.append(list_1[i])\n        i = i + 1\n        \n    while j < len(list_2):\n        final_list.append(list_2[j])\n        j = j + 1\n        \n    return final_list\n\n\nmy_list = [3, 8, 2, 7, 1, 4, 5]\nans = merge_sort(my_list)\nprint(ans)\n# prints [1, 2, 3, 4, 5, 7, 8]Implementation of Merge Sort Algorithm in PythonAs you see in the above code, I have implemented two separate functions for sorting and merging the two sorted lists. This leads to better readability and easier code reviews.The main drawback in merge sort is it uses more space. This is because, at every recursive call, a new list gets created and recursion is called on that new list. So space complexity for the worst case scenario is O(n) and time complexity is O(n log n).ConclusionMerge Sort is pretty quick in sorting a list recursively from a time complexity perspective. This is useful for counting inversions in lists and it's widely used for external sorting applications than other sorting algorithms.Happy programming...\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 8826, "excerpt": "When you want to sort a list or array in Python, there are many sorting\nalgorithms you can use. \n\nSome use looping concepts like Insertion Sort, Bubble Sort, and Selection Sort.\nOn the other hand, you can also sort the same list or array using Merge Sort\nwith the help of recursion.\n\nIn this article, you will learn how the Merge Sort algorithm works. You will\nalso learn how recursion plays an important role in Merge Sort. \n\nHow Recursion Works\nAs a prerequisite, we will first understand how recur", "siteName": "freeCodeCamp.org", "publishedTime": "2022-09-23T14:35:00.000Z", "id": "0a98291c8802bb5b425a34035b806f851fb142e4", "url": "https://www.freecodecamp.org/news/how-to-sort-recursively-in-python/", "domain": "freecodecamp.org", "date": "2023-12-27T18:05:17.065304", "resultUri": "http://localhost:3000/result/0a98291c8802bb5b425a34035b806f851fb142e4", "query": {"url": ["https://www.freecodecamp.org/news/how-to-sort-recursively-in-python/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "How to Sort a List Recursively in Python", "description": "When you want to sort a list or array in Python, there are many sorting algorithms you can use.  Some use looping concepts like Insertion Sort, Bubble Sort, and Selection Sort. On the other hand, you can also sort the same list or array using Merge Sort with the", "url": "https://www.freecodecamp.org/news/how-to-sort-recursively-in-python/", "image": "https://www.freecodecamp.org/news/content/images/2022/09/max-harlynking-_QcLpud-gD0-unsplash-1.jpg", "image:width": "2000", "image:height": "1159"}, "twitter": {"card": "summary_large_image", "title": "How to Sort a List Recursively in Python", "description": "When you want to sort a list or array in Python, there are many sorting algorithms you can use.  Some use looping concepts like Insertion Sort, Bubble Sort, and Selection Sort. On the other hand, you can also sort the same list or array using Merge Sort with the", "url": "https://www.freecodecamp.org/news/how-to-sort-recursively-in-python/", "image": "https://www.freecodecamp.org/news/content/images/2022/09/max-harlynking-_QcLpud-gD0-unsplash-1.jpg", "label1": "Written by", "data1": "P S Mohammed Ali", "label2": "Filed under", "data2": "Python, Programming, Algorithms, Recursion", "site": "@freecodecamp"}}}