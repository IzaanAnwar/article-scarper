{"title": "Reintroducing React \u2013 Every React Update Since v16 [Full Handbook]", "byline": "Emmanuel Ohans", "dir": null, "lang": "en", "content": "<article><h1>Reintroducing React \u2013 Every React Update Since v16 [Full Handbook]</h1><div class=\"page\" id=\"readability-page-1\"><section data-test-label=\"post-content\">\n<p>In this article (and accompanying book), unlike any you may have come across before, I will deliver funny, unfeigned and dead serious comic strips about every React update since v16+. It\u2019ll be hilarious, either intentionally or unintentionally, easy on beginners as well as professionals, and will be very informative as a whole.</p><h4 id=\"why-comic-strips\">Why Comic Strips ?</h4><p>I have been writing software for over 5 years. But I have done other things, too. I\u2019ve been a graphics designer, a published author, teacher, and a long, long time ago, an amateur Illustrator.</p><p>I love the tech community, but sometimes as a group, we tend to be a little narrow-minded.</p><p>When people attempt to teach new technical concepts, they forget who they were before they became developers and just churn out a lot of technical jargon \u2014 like other developers they\u2019ve seen.</p><p>When you get to know people, it turns out so many of us have different diverse backgrounds! \u201cIf you were a comedian, why not explain technical concepts with some comedy?</p><p>Wouldn\u2019t that be so cool?</p><p>I want to show how we can become better as engineers, as teams, and as a community, by openly being our full, weird selves, and <strong>teaching others with all that personality.</strong> But instead of just talking, I want to make it noteworthy and lead by example. So, you\u2019re welcome to my rendition of a comic strip inspired book about every React update since v16.</p><p>With recently released v16.8 features, there\u2019s going to be a lot of informative comic strips to be delivered!</p><p>Inspired by <a href=\"https://twitter.com/jevakallio?lang=en\" rel=\"noopener\">Jani Ev\u00e4kallio</a>.</p><blockquote>This is a very interesting but long read. <a href=\"https://leanpub.com/reintroducing-react\" rel=\"noopener\">Please download the ebook</a> (PDF, Epub &amp; Mobi) <strong>absolutely free</strong> \u2014 without having to share your email with me. You can also pay whatever you want for the book if you wanna support my work.</blockquote><h4 id=\"how-to-read-this-article\">How to Read this Article</h4><p>First, <a href=\"https://leanpub.com/reintroducing-react\" rel=\"noopener\">get the ebook</a>. Apart from being able to read offline, the ebooks have syntax highlighted codes that make them easier to read as well. <a href=\"https://leanpub.com/reintroducing-react\" rel=\"noopener\">Go get it</a>.</p><figure><img alt=\"Nb9iorcKIAQebUWfWgs-JhbR289ENJvinibW\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/Nb9iorcKIAQebUWfWgs-JhbR289ENJvinibW\" width=\"600\"/><figcaption><a href=\"https://leanpub.com/reintroducing-react\" rel=\"noopener\" target=\"_blank\" title=\"\">https://leanpub.com/reintroducing-react</a></figcaption></figure><p>Secondly, please find the associated <a href=\"https://github.com/ohansemmanuel/Reintroducing-react\" rel=\"noopener\">code repository</a> for the book on Github. This will help you follow along with the examples allowing for more hands-on practice.</p><figure><img alt=\"YDMVHOQjYMiKVwqh5kWnebHeer10XphxEIIz\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/YDMVHOQjYMiKVwqh5kWnebHeer10XphxEIIz\" width=\"600\"/></figure><h4 id=\"why-reintroduce-react\">Why Reintroduce React?</h4><p>I wrote my first React application 3 to 4 years ago. Between then and now, the fundamental principles of React have remained the same. React is just as declarative and component-based today as it was then.</p><p>That\u2019s great news, however, the way we write React applications today has changed!</p><p>There\u2019s been a lot of new additions (and well, removals).</p><p>If you learned React a while back it\u2019s not impossible that you haven\u2019t been up to date with every new feature/release. It\u2019s also possible to get lost on all the new features. Where exactly do you start? How important are they for your day to day use?</p><p>Even as an experienced engineer, I sometimes find unlearning old concepts and relearning new ones just as intimidating as learning a new concept from the scratch.</p><p>If that\u2019s the case with you, I hope I can provide the right help for you via this guide.</p><p>The same applies if you\u2019re just learning React.</p><p>There\u2019s a lot of state information out there. If you learn React with some old resource, yes, you\u2019ll learn the fundamentals of React, but modern React has new interesting features that are worth your attention. It\u2019s best to know those now, and not have to unlearn and relearn newer concepts.</p><p>Whether you\u2019ve been writing React for a while, or new to developing React applications, I will be discussing <strong>every</strong> update to React since version 16.</p><p>This will keep you in sync with the recent changes to React, and help you write better software.</p><p>Remember, a reintroduction to React is important for not just beginners, but professionals alike. It all depends on how well you\u2019ve kept your ear to the ground, and really studied the many changes that have been released over the last 12 months.</p><p>On the bright side, I\u2019m bringing you a one-stop reference to all the changes.</p><p>In this book, I\u2019ll take you on a journey \u2014 alongside some humour and unique content to follow.</p><h4 id=\"what-s-changed-since-version-16\">What\u2019s Changed since version 16?</h4><p>If you think not much has changed, think again.</p><p>Here\u2019s a list of the relevant changes we\u2019ll be discussing in this guide:</p><ul><li>New Lifecycle Methods.</li><li>Simpler State Management with the Context API.</li><li>ContextType \u2014 Using Context without a Consumer.</li><li>The Profiler: Using Charts and Interactions.</li><li>Lazy Loading with React.Lazy and Suspense.</li><li>Functional PureComponent with React.memo</li><li>Simplifying React apps with Hooks!</li><li><strong>Advanced React Component Patterns with Hooks</strong>.</li></ul><p>It goes without saying that a lot has been introduced since version 16. For ease, each of these topics have been broken down into separate sections.</p><p>In the next section I\u2019ll begin to discuss these changes by having a look at the new lifecycle methods available from version 16.</p><h3 id=\"chapter-1-new-lifecycle-methods-\">Chapter 1: New Lifecycle Methods.</h3><figure><img alt=\"ADJ58ZyM2MbBszxgupJp7eX9XnrTXotbsHJR\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/ADJ58ZyM2MbBszxgupJp7eX9XnrTXotbsHJR\" width=\"600\"/></figure><p>He\u2019s been writing software for a while, but new to the React ecosystem.</p><p>Meet John.</p><figure><img alt=\"hLWHsySy2MjOixddCdxRPK5z9x5qZZWYq9Xm\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/hLWHsySy2MjOixddCdxRPK5z9x5qZZWYq9Xm\" width=\"600\"/></figure><p>For a long time he didn\u2019t fully understand what lifecycle truly meant in the context of React apps.</p><p>When you think of lifecycle what comes to mind?</p><h4 id=\"what-s-lifecycle-anyway\">What\u2019s Lifecycle Anyway?</h4><p>Well, consider humans.</p><figure><img alt=\"0Y37Fw7u57Bww8eMdVhbZz9mJthSVTF8xAJl\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/0Y37Fw7u57Bww8eMdVhbZz9mJthSVTF8xAJl\" width=\"600\"/></figure><p>The typical lifecycle for a human is something like, \u201cchild\u201d to \u201cadult\u201d to \u201celderly\u201d.</p><p>In the biological sense, lifecycle refers to the series of \u201cchanges in form\u201d an organism undergoes.</p><p>The same applies to React components. They undergo a series of \u201cchanges in form\u201d.</p><p>Here\u2019s what a simple graphical representation for React components would be.</p><figure><img alt=\"0ZXhBgvKYzQJ2ktWeLdw8Ep961sWLipbFI0b\" height=\"600\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/0ZXhBgvKYzQJ2ktWeLdw8Ep961sWLipbFI0b\" width=\"800\"/></figure><p>The four essential phases or lifecycle attributed to a React component include:</p><ul><li><strong>Mounting</strong> \u2014 like the birth of a child, at this phase the component is created (your code, and react\u2019s internals) then inserted into the DOM</li><li><strong>Updating</strong> \u2014 like humans \u201cgrow\u201d, in this phase a React component undergoes growth by being updated via changes in props or state.</li><li><strong>Unmounting</strong> \u2014 Like the death of a human, this is the phase the component is removed from the DOM.</li><li><strong>Error Handling</strong> \u2014 Think of this as being comparable to when humans fall sick and visit the doctor. Sometimes your code doesn\u2019t run or there\u2019s a bug somewhere. When this happens, the component is in the error handling phase. I intentionally skipped this phase in the illustration earlier.</li></ul><h4 id=\"lifecycle-methods-\">Lifecycle Methods.</h4><p>Now that you understand what lifecycle means, what are \u201clifecycle methods\u201d?</p><p>Knowing the phases /lifecycle a React component goes through is one part of the equation. The other part is understanding the methods React makes available (or invokes) at each phase.</p><p>The methods invoked during different phase/lifecycle of a component is what\u2019s popularly known as the component lifecycle methods e.g. In the mounting and updating phases, the <code>render</code> lifecycle method is always invoked.</p><p>There are lifecycle methods available on all 4 phases of a component \u2014 mounting, updating, unmounting and error handling.</p><p>Knowing when a lifecycle method is invoked (i.e the associated lifecycle/phase) means you can go ahead to write related logic within the method and know it\u2019ll be invoked at the right time.</p><p>With the basics out of the way, let\u2019s have a look at the actual new lifecycle methods available from version 16.</p><h4 id=\"static-getderivedstatefromprops-\">static getDerivedStateFromProps.</h4><p>Before explaining how this lifecycle method works, let me show you how the method is used.</p><p>The basic structure looks like this:</p><pre><code>const MyComponent extends React.Component {  ... </code></pre><pre><code>  static getDerivedStateFromProps() {     //do stuff here  }  }</code></pre><p>The method takes in <code>props</code> and <code>state</code>:</p><pre><code>... </code></pre><pre><code>  static getDerivedStateFromProps(props, state) {\t//do stuff here  }  </code></pre><pre><code>...</code></pre><p>And you can either return an object to update the state of the component:</p><pre><code>... </code></pre><pre><code>  static getDerivedStateFromProps(props, state) {      return {     \tpoints: 200 // update state with this     }  }  </code></pre><pre><code>  ...</code></pre><p>Or return null to make no updates:</p><pre><code>... </code></pre><pre><code>  static getDerivedStateFromProps(props, state) {    return null  }  </code></pre><pre><code>...</code></pre><p>I know what you\u2019re thinking. Why exactly is this lifecycle method important?</p><p>Well, it is one of the rarely used lifecycle methods, but it comes in handy in certain scenarios.</p><p>Firstly, this method is called (or invoked) <strong>before</strong> the component is rendered to the DOM on initial mount.</p><p>Below\u2019s a quick example.</p><p>Consider a simple component that renders the number of points scored by a football team.</p><p>As you may have expected, the number of points is stored in the component state object:</p><pre><code>class App extends Component {  state = {    points: 10  }  render() {    return (      &lt;div className=\"App\"&gt;        &lt;header className=\"App-header\"&gt;          &lt;img src={logo} className=\"App-logo\" alt=\"logo\" /&gt;          &lt;p&gt;            You've scored {this.state.points} points.          &lt;/p&gt;        &lt;/header&gt;      &lt;/div&gt;    );  }}</code></pre><figure><img alt=\"hfyqbWa079ilh8WNpff4fBknEmgMJY8r3JD7\" height=\"766\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/hfyqbWa079ilh8WNpff4fBknEmgMJY8r3JD7\" width=\"746\"/></figure><p>Note that the text reads, <em>you have scored 10 points</em> \u2014 where 10 is the number of points in the state object.</p><p>Just an as an example, if you put in the static getDerivedStateFromProps method as shown below, what number of points will be rendered?</p><pre><code>class App extends Component {  state = {    points: 10  }\t  // *******  //  NB: Not the recommended way to use this method. Just an example. Unconditionally overriding state here is generally considered a bad idea  // ********  static getDerivedStateFromProps(props, state) {    return {      points: 1000    }  }  render() {    return (      &lt;div className=\"App\"&gt;        &lt;header className=\"App-header\"&gt;          &lt;img src={logo} className=\"App-logo\" alt=\"logo\" /&gt;          &lt;p&gt;            You've scored {this.state.points} points.          &lt;/p&gt;        &lt;/header&gt;      &lt;/div&gt;    );  }}</code></pre><p>Right now, we have the static getDerivedStateFromProps component lifecycle method in there. If you remember from the previous explanation, this method is called before the component is mounted to the DOM. By returning an object, we update the state of the component before it is even rendered.</p><p>And here\u2019s what we get:</p><figure><img alt=\"zeyjZq0KXXLe1NcM7DTPaGo7CB45Y1t2Zc4x\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/zeyjZq0KXXLe1NcM7DTPaGo7CB45Y1t2Zc4x\" width=\"600\"/></figure><p>With the 1000 coming from updating state within the <code>static getDerivedStateFromProps</code> method.</p><p>Well, this example is contrived, and not really the way you\u2019d use the <code>static getDerivedStateFromProps</code> method. I just wanted to make sure you understood the basics first.</p><p>With this lifecycle method, just because you can update state doesn\u2019t mean you should go ahead and do this. There are specific use cases for the <code>static getDerivedStateFromProps</code> method, or you\u2019ll be solving a problem with the wrong tool.</p><p>So when should you use the <code>static getDerivedStateFromProps</code> lifecycle method?</p><p>The method name <code>getDerivedStateFromProps</code> comprises five different words, \u201cGet Derived State From Props\u201d.</p><figure><img alt=\"2CHM9AEB3-nVWe7YAaaTe4NxVCGc7bWO2i4w\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/2CHM9AEB3-nVWe7YAaaTe4NxVCGc7bWO2i4w\" width=\"600\"/></figure><p>Also, component state in this manner is referred to as Derived State.</p><p>As a rule of thumb, derived state should be used sparingly as you can introduce <a href=\"https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#common-bugs-when-using-derived-state\" rel=\"noopener\">subtle bugs</a> into your application if you aren\u2019t sure of what you\u2019re doing.</p><h4 id=\"getsnapshotbeforeupdate-\">getSnapshotBeforeUpdate.</h4><p>In the updating component phase, right after the render method is called, the <code>getSnapshotBeforeUpdate</code> lifecycle method is called next.</p><p>This one is a little tricky, but I\u2019ll take my time to explain how it works.</p><p>Chances are you may not always reach out for this lifecycle method, but it may come in handy in certain special cases. Specifically when you need to grab some information from the DOM (and potentially change it) just after an update is made.</p><p>Here\u2019s the important thing. The value queried from the DOM in <code>getSnapshotBeforeUpdate</code> will refer to the value just before the DOM is updated. Even though the render method was previously called.</p><p>An analogy that may help has to do with how you use version control systems such as git.</p><p>A basic example is that you write code, and stage your changes before pushing to the repo.</p><p>In this case, assume the render function was called to stage your changes before actually pushing to the DOM. So, before the actual DOM update, information retrieved from getSnapshotBeforeUpdate refers to those before the actual visual DOM update.</p><p>Actual updates to the DOM may be asynchronous, but the <code>getSnapshotBeforeUpdate</code> lifecycle method will always be called immediately before the DOM is updated.</p><p>Don\u2019t worry if you don\u2019t get it yet. I have an example for you.</p><figure><img alt=\"unerso1VTE24Qf7YMQqizDGDxGaF94tMQ8xB\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/unerso1VTE24Qf7YMQqizDGDxGaF94tMQ8xB\" width=\"600\"/></figure><p>The implementation of the chat pane is as simple as you may have imagined. Within the <code>App</code> component is an unordered list with a <code>Chats</code> component:</p><pre><code>&lt;ul className=\"chat-thread\"&gt;    &lt;Chats chatList={this.state.chatList} /&gt; &lt;/ul&gt;</code></pre><p>The <code>Chats</code> component renders the list of chats, and for this, it needs a chatList prop. This is basically an Array. In this case, an array of 3 string values, \"Hey\", \"Hello\", \"Hi\".</p><p>The <code>Chats</code> component has a simple implementation as follows:</p><pre><code>class Chats extends Component {  render() {    return (      &lt;React.Fragment&gt;        {this.props.chatList.map((chat, i) =&gt; (          &lt;li key={i} className=\"chat-bubble\"&gt;            {chat}          &lt;/li&gt;        ))}      &lt;/React.Fragment&gt;    );  }}</code></pre><p>It just maps through the <code>chatList</code> prop and renders a list item which is in turn styled to look like a chat bubble :).</p><p>There\u2019s one more thing though. Within the chat pane header is an \u201cAdd Chat\u201d button.</p><figure><img alt=\"1m1dDWKV78TsJqLZTkPCkLI0NCCm5WpxguEV\" height=\"538\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1m1dDWKV78TsJqLZTkPCkLI0NCCm5WpxguEV\" width=\"800\"/></figure><p>Clicking this button will add a new chat text, \u201cHello\u201d, to the list of rendered messages.</p><p>Here\u2019s that in action:</p><figure><img alt=\"lz7y-pZgh69oM8Qky58mc7Uy9GNuy-GEm4pw\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/lz7y-pZgh69oM8Qky58mc7Uy9GNuy-GEm4pw\" width=\"600\"/><figcaption>Adding new chat messages</figcaption></figure><p>The problem here, as with most chat applications, is that whenever the number of chat messages exceeds the available height of the chat window, the expected behaviour is to auto scroll down the chat pane so that the latest chat message is visible. That\u2019s not the case now.</p><figure><img alt=\"a54HCUsBP3ONIrJvrsiEE1H66BYTAdTZbu0o\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/a54HCUsBP3ONIrJvrsiEE1H66BYTAdTZbu0o\" width=\"600\"/><figcaption>I have to scroll manually to find the most recent message</figcaption></figure><p>Let\u2019s see how we may solve this using the getSnapshotBeforeUpdate lifecycle method.</p><p>The way the <code>getSnapshotBeforeUpdate</code> lifecycle method works is that when it is invoked, it gets passed the previous props and state as arguments.</p><p>So we can use the <code>prevProps</code> and <code>prevState</code> parameters as shown below:</p><pre><code>getSnapshotBeforeUpdate(prevProps, prevState) {   }</code></pre><p>Within this method, you\u2019re expected to either return a value or null:</p><pre><code>getSnapshotBeforeUpdate(prevProps, prevState) {   return value || null // where 'value' is a  valid JavaScript value    }</code></pre><p>Whatever value is returned here is then passed on to another lifecycle method. You\u2019ll get to see what I mean soon.</p><p>The <code>getSnapshotBeforeUpdate</code> lifecycle method doesn't work on its own. It is meant to be used in conjunction with the <code>componentDidUpdate</code> lifecycle method.</p><p>Whatever value is returned from the <code>getSnapshotBeforeUpdate</code> lifecycle method is passed as the third argument to the <code>componentDidUpdate</code> method.</p><p>Let\u2019s call the returned value from <code>getSnapshotBeforeUpdate</code>, <em>snapshot</em>, and here's what we get thereafter:</p><pre><code>componentDidUpdate(prevProps, prevState, snapshot) { }</code></pre><p>The <code>componentDidUpdate</code> lifecycle method is invoked after the <code>getSnapshotBeforeUpdate</code> is invoked. As with the getSnapshotBeforeUpdate method it receives the previous props and state as arguments. It also receives the returned value from <code>getSnapshotBeforeUpdate</code> as final argument.</p><p>Here\u2019s all the code required to maintain the scroll position within the chat pane:</p><pre><code>getSnapshotBeforeUpdate(prevProps, prevState) {    if (this.state.chatList &gt; prevState.chatList) {      const chatThreadRef = this.chatThreadRef.current;      return chatThreadRef.scrollHeight - chatThreadRef.scrollTop;    }    return null;  }  componentDidUpdate(prevProps, prevState, snapshot) {    if (snapshot !== null) {      const chatThreadRef = this.chatThreadRef.current;      chatThreadRef.scrollTop = chatThreadRef.scrollHeight - snapshot;    }  }</code></pre><p>Let me explain what\u2019s going on there.</p><p>Below\u2019s the chat window:</p><figure><img alt=\"OzgLAOVGpmNxBigrESPZYjEqWZvPr1j93kfh\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/OzgLAOVGpmNxBigrESPZYjEqWZvPr1j93kfh\" width=\"600\"/><figcaption>The full chat window</figcaption></figure><p>However, the graphic below highlights the actual region that holds the chat messages (the unordered list, <code>ul</code> which houses the messages).</p><figure><img alt=\"CHWDBo14-MfxpwtFUUkDjDN2Mwoq6eW-wuRq\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/CHWDBo14-MfxpwtFUUkDjDN2Mwoq6eW-wuRq\" width=\"600\"/><figcaption>The actual region holding the chat messages</figcaption></figure><p>It is this <code>ul</code> we hold a reference to using a React Ref:</p><pre><code>&lt;ul className=\"chat-thread\" ref={this.chatThreadRef}&gt;   ...&lt;/ul&gt;</code></pre><p>First off, because <code>getSnapshotBeforeUpdate</code> may be triggered for updates via any number of props or even a state update, we wrap to code in a conditional that checks if there\u2019s indeed a new chat message:</p><pre><code>getSnapshotBeforeUpdate(prevProps, prevState) {    if (this.state.chatList &gt; prevState.chatList) {      // write logic here    }  }</code></pre><p>The <code>getSnapshotBeforeUpdate</code> method above has to return a value yet. If no chat message was added, we will just return <code>null</code>:</p><pre><code>getSnapshotBeforeUpdate(prevProps, prevState) {    if (this.state.chatList &gt; prevState.chatList) {      // write logic here    }      return null }</code></pre><p>Now consider the full code for the <code>getSnapshotBeforeUpdate</code> method:</p><pre><code>getSnapshotBeforeUpdate(prevProps, prevState) {    if (this.state.chatList &gt; prevState.chatList) {      const chatThreadRef = this.chatThreadRef.current;      return chatThreadRef.scrollHeight - chatThreadRef.scrollTop;    }    return null;  }</code></pre><p>Does it make sense to you?</p><p>Not yet, I suppose.</p><p>First, consider a situation where the entire height of all chat messages doesn\u2019t exceed the height of the chat pane.</p><figure><img alt=\"c0Zb3kxJmFNPmbiPP6tlCgrbWcAJ7BIpSf9L\" height=\"513\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/c0Zb3kxJmFNPmbiPP6tlCgrbWcAJ7BIpSf9L\" width=\"800\"/></figure><p>Here, the expression <code>chatThreadRef.scrollHeight - chatThreadRef.scrollTop</code> will be equivalent to <code>chatThreadRef.scrollHeight - 0</code>.</p><p>When this is evaluated, it\u2019ll be equal to the <code>scrollHeight</code> of the chat pane \u2014 just before the new message is inserted to the DOM.</p><p>If you remember from the previous explanation, the value returned from the <code>getSnapshotBeforeUpdate</code> method is passed as the third argument to the <code>componentDidUpdate method</code>. We call this snapshot:</p><pre><code>componentDidUpdate(prevProps, prevState, snapshot) {}</code></pre><p>The value passed in here \u2014 at this time, is the previous <code>scrollHeight</code> before the update to the DOM.</p><p>In the <code>componentDidUpdate</code> we have the following code, but what does it do?</p><pre><code>componentDidUpdate(prevProps, prevState, snapshot) {    if (snapshot !== null) {      const chatThreadRef = this.chatThreadRef.current;      chatThreadRef.scrollTop = chatThreadRef.scrollHeight - snapshot;    }  }</code></pre><p>In actuality, we are programmatically scrolling the pane vertically <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop\" rel=\"noopener\">from the top down</a>, by a distance equal to <code>chatThreadRef.scrollHeight - snapshot</code>;</p><p>Since <code>snapshot</code> refers to the <code>scrollHeight</code> before the update, the above expression returns the <code>height</code> of the new chat message plus any other related height owing to the update.</p><p>Please see the graphic below:</p><figure><img alt=\"hoII8SAxbI6PJoKCgKovHu3ontCBLXb-xplp\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/hoII8SAxbI6PJoKCgKovHu3ontCBLXb-xplp\" width=\"600\"/></figure><p>When the entire chat pane height is occupied with messages (and already scrolled up a bit), the <code>snapshot</code> value returned by the <code>getSnapshotBeforeUpdate</code> method will be equal to the actual height of the chat pane.</p><p>The computation from <code>componentDidUpdate</code> will set to <code>scrollTop</code> value to the sum of the heights of extra messages - exactly what we want.</p><figure><img alt=\"aqEisKIrxOuOCQKOePljWG15E9GGXOu9CWG1\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/aqEisKIrxOuOCQKOePljWG15E9GGXOu9CWG1\" width=\"600\"/></figure><p>Yeah, that\u2019s it.</p><p>If you got stuck, I\u2019m sure going through the explanation (one more time) or checking the source code will help clarify your questions.</p><h4 id=\"the-error-handling-lifecycle-methods-\">The Error Handling Lifecycle Methods.</h4><p>Sometimes things go bad, errors are thrown. The error lifecycle methods are invoked when an error is thrown by a descendant component i.e a component below them.</p><p>Let\u2019s implement a simple component to catch errors in the demo app. For this, we\u2019ll create a new component called <code>ErrorBoundary</code>.</p><p>Here\u2019s the most basic implementation:</p><pre><code>import React, { Component } from 'react';class ErrorBoundary extends Component {  state = {};  render() {    return null;  }}export default ErrorBoundary;</code></pre><p>Now, let\u2019s incorporate the error lifecycle methods.</p><h4 id=\"static-getderivedstatefromerror-\">static getDerivedStateFromError.</h4><p>Whenever an error is thrown in a descendant component, this method is called first, and the error thrown passed as an argument.</p><p>Whatever value is returned from this method is used to update the state of the component.</p><p>Let\u2019s update the <code>ErrorBoundary</code> component to use this lifecycle method.</p><pre><code>import React, { Component } from \"react\";</code></pre><pre><code>class ErrorBoundary extends Component {  state = {};</code></pre><pre><code>  static getDerivedStateFromError(error) {    console.log(`Error log from getDerivedStateFromError: ${error}`);    return { hasError: true };  }</code></pre><pre><code>  render() {    return null;  }}</code></pre><pre><code>export default ErrorBoundary;</code></pre><p>Right now, whenever an error is thrown in a descendant component, the error will be logged to the console, <code>console.error(error</code>), and an object is returned from the <code>getDerivedStateFromError</code> method. This will be used to update the state of the ErrorBoundary component i.e with <code>hasError: true</code>.</p><h4 id=\"componentdidcatch-\">componentDidCatch.</h4><p>The <code>componentDidCatch</code> method is also called after an error in a descendant component is thrown. Apart from the error thrown, it is passed one more argument which represents more information about the error:</p><pre><code>componentDidCatch(error, info) {}</code></pre><p>In this method, you can send the <code>error</code> or <code>info</code> received to an external logging service. Unlike <code>getDerivedStateFromError</code>, the <code>componentDidCatch</code> allows for side-effects:</p><pre><code>componentDidCatch(error, info) {\tlogToExternalService(error, info) // this is allowed.         //Where logToExternalService may make an API call.}</code></pre><p>Let\u2019s update the <code>ErrorBoundary</code> component to use this lifecycle method:</p><pre><code>import React, { Component } from \"react\";</code></pre><pre><code>class ErrorBoundary extends Component {  state = { hasError: false };  static getDerivedStateFromError(error) {    console.log(`Error log from getDerivedStateFromError: ${error}`);    return { hasError: true };  }  componentDidCatch(error, info) {    console.log(`Error log from componentDidCatch: ${error}`);    console.log(info);  }  render() {    return null  }}export default ErrorBoundary;</code></pre><p>Also, since the <code>ErrorBoundary</code> can only catch errors from descendant components, we\u2019ll have the component render whatever is passed as <code>Children</code> or render a default error UI if something went wrong:</p><pre><code>... render() {    if (this.state.hasError) {      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;    }</code></pre><pre><code>    return this.props.children; }</code></pre><p>I have simulated a javascript error whenever you add a 5th chat message.</p><p>Have a look at the error boundary at work:</p><figure><img alt=\"7BtaANRXqMdWT3gmpWAAfpk4l5kOtAHhiPyP\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/7BtaANRXqMdWT3gmpWAAfpk4l5kOtAHhiPyP\" width=\"600\"/></figure><h4 id=\"conclusion-\">Conclusion.</h4><p>It is worth mentioning that while new additions were made to the component lifecycle methods, some other methods such as <code>componentWillMount</code> , <code>componentWillUpdate</code>, <code>componentWillReceiveProps</code> were deprecated.</p><figure><img alt=\"-k1Wn8Tyztlbj-iQi1JG5R9URhy4M5PZOsIl\" height=\"600\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/-k1Wn8Tyztlbj-iQi1JG5R9URhy4M5PZOsIl\" width=\"800\"/><figcaption>Deprecated lifecycle methods</figcaption></figure><p>Now you\u2019re up to date on the changes made to the component lifecycle methods since React version 16!</p><h3 id=\"chapter-2-simpler-state-management-with-the-context-api-\">Chapter 2: Simpler State Management with the Context API.</h3><figure><img alt=\"hkHwd2gLDsTYazf2aSM5EuPUTH5RvqoUHnMJ\" height=\"409\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/hkHwd2gLDsTYazf2aSM5EuPUTH5RvqoUHnMJ\" width=\"800\"/></figure><p>John\u2019s an amazing developer, and he loves what he does. However, he\u2019s frequently been facing the same problem when writing React applications.</p><figure><img alt=\"BasI49K5JaDLjeNq-W2ttxwZpcKjJZKY5ysr\" height=\"600\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/BasI49K5JaDLjeNq-W2ttxwZpcKjJZKY5ysr\" width=\"800\"/><figcaption>Props drilling</figcaption></figure><p><strong>Props drilling</strong>, the term used to describe passing down props needlessly through a deeply nested component tree, has plagued John for a while now!</p><p>Luckily, John has a friend who always has all the answers. Hopefully, she can suggest a way out.</p><p>John reaches out to Mia, and she steps in to offer some advice.</p><figure><img alt=\"h5fhv1i9F8pGKAwhUoIe78RVCPI6bPDHEmPB\" height=\"600\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/h5fhv1i9F8pGKAwhUoIe78RVCPI6bPDHEmPB\" width=\"800\"/><figcaption>Mia says, \u2018try Redux or MobX\u2019.</figcaption></figure><p>Mia is a fabulous engineer as well, and she suggests using some state management library such as <code>Redux</code> or <code>MobX</code>.</p><p>These are great choices, however, for most of John\u2019s use cases, he finds them a little too bloated for his need.</p><p>\u201c<em>Can\u2019t I have something simpler and native to React itself</em>\u201d, says John.</p><p>Mia goes on a desperate search to help a friend in need, and she finds the Context API.</p><figure><img alt=\"TsMolzLtPQlrPVEjJDm95t8VF3H6y6IvKb0v\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/TsMolzLtPQlrPVEjJDm95t8VF3H6y6IvKb0v\" width=\"600\"/></figure><p>Mia recommends using React\u2019s Context API to solve the problem. John is now happy, excited to see what the Context API could offer, and he goes about his work productively.</p><p>This marks the beginning of John\u2019s experience with the Context API.</p><h4 id=\"introduction-to-context-\">Introduction to Context.</h4><p>The Context API exists to make it easy to share data considered \u201cglobal\u201d within a component tree.</p><p>Let\u2019s have a look at an illustrated example before we delve into writing any code.</p><p>Well, John has began working with the Context API and has mostly been impressed with it so far. Today he has a new project to work on, and he intends to use the context API.</p><p>Let\u2019s see what this new project is about.</p><figure><img alt=\"jZg7XLI0pwdpiRkAftIRJu7I6ZP32I3pdJHx\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/jZg7XLI0pwdpiRkAftIRJu7I6ZP32I3pdJHx\" width=\"600\"/><figcaption>The new project: Benny Home Run</figcaption></figure><p>John is expected to build a game for a new client of his. This game is called <strong>Benny Home Run</strong>, and it seems like a great place to use the Context API.</p><p>The sole aim of the game is to move Benny from his start position to his new home.</p><figure><img alt=\"41X58zNSpcIFa-a5qIXo3CVlICGAoPaYwHLB\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/41X58zNSpcIFa-a5qIXo3CVlICGAoPaYwHLB\" width=\"600\"/><figcaption>The aim of the game</figcaption></figure><p>To build this game, John must keep track of the position of Benny.</p><p>Since Benny\u2019s position is such an integral part of the entire application, it may as well be tracked via some global application state.</p><figure><img alt=\"YCZQJwydNektrDR5gZ2IBwuCuZ-JRWUwJQOA\" height=\"600\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/YCZQJwydNektrDR5gZ2IBwuCuZ-JRWUwJQOA\" width=\"800\"/><figcaption>Tracking position values x and y in state</figcaption></figure><p>Did I just say \u201c<em>global application state</em>\u201d?</p><p>That sounds like a good fit for the Context API.</p><p>So, how may John build this?</p><figure><img alt=\"goXVPDOBLY69Gaf0NgifcVoilXOcZro-NWyy\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/goXVPDOBLY69Gaf0NgifcVoilXOcZro-NWyy\" width=\"600\"/></figure><p>First, there\u2019s the need to import the <code>createContext</code> method from <code>React</code></p><pre><code>import {createContext} from 'react';</code></pre><p>The <code>createContext</code> method allows you to create what\u2019s referred to as a context object. Consider this to be the data structure that powers retrieving and saving state values.</p><p>To create a context object, you invoke the <code>createContext</code> method with (or without) an initial state value to be saved in the context object.</p><pre><code>createContext(initialStateValue)</code></pre><p>Here\u2019s what that looks like in the Benny app:</p><pre><code>const BennyPositionContext = createContext({ \tx: 50, \ty: 50 })</code></pre><p>The <code>createContext</code> method is invoked with an initial state value corresponding to the initial position values (x and y) for Benny.</p><p>Looks good!</p><p>But, after creating a context object, how exactly do you gain access to the state values within your application?</p><p>Well, every context object comes with a <code>Provider</code> and <code>Consumer</code> component.</p><p>The <code>Provider</code> component \u201cprovides\u201d the value saved in the context object to its children, while the <code>Consumer</code> component \u201cconsumes\u201d the values from within any child component.</p><p>I know that was a mouth full, so let\u2019s break it apart slowly.</p><p>In the Benny example, we can go ahead and destructure the <code>BennyPositionContext</code> to retrieve the Provider and Consumer components.</p><pre><code>const BennyPositionContext = createContext({ \tx: 50, \ty: 50 })// get provider and consumerconst { Provider, Consumer } = BennyPositionContext</code></pre><p>Since <code>Provider</code> provides value saved in the context object to its <strong>children</strong>, we could wrap a tree of components with the <code>Provider</code> component as shown below:</p><pre><code>&amp;lt;Provider&gt;   &lt;Root /&gt; // the root component for the Benny app. &lt;/Provider&gt;</code></pre><p>Now, any child component within the <code>Root</code> component will have access to the default values stored in the context object.</p><p>Consider the following tree of components for the Benny app.</p><pre><code>&lt;Provider&gt;   &lt;Scene&gt;     &lt;Benny /&gt;   &amp;lt;/Scene&gt;&lt;/Provider&gt;</code></pre><p>Where <code>Scene</code> and <code>Benny</code> are children of the <code>Root</code> component and represent the game scene and benny character respectively.</p><p>In this example, the <code>Scene</code> or the even more nested <code>Benny</code> component will have access to the value provided by the <code>Provider</code> component.</p><p>It is worth mentioning that a <code>Provider</code> also takes in a <code>value</code> props.</p><p>This <code>value</code> prop is useful if you want to provide a value other than the initial value passed in at the context object creation time via <code>createContext(initialStateValue)</code></p><p>Here\u2019s an example where a new set of values are passed in to the <code>Provider</code> component.</p><pre><code>&lt;Provider value={x: 100, y: 150}&gt;   &lt;Scene&gt;     &lt;Benny /&gt;   &amp;lt;/Scene&gt;&lt;/Provider&gt;</code></pre><p>Now that we have values provided by the <code>Provider</code> component, how can a nested component such as <code>Benny</code> consume this value?</p><figure><img alt=\"Jy-XrFHSMdxF9UXcIxToIWMELABQqFMVtttE\" height=\"600\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/Jy-XrFHSMdxF9UXcIxToIWMELABQqFMVtttE\" width=\"800\"/></figure><p>The simple answer is by using the <code>Consumer</code> component.</p><p>Consider the <code>Benny</code> component being a simple component that renders some SVG.</p><pre><code>const Benny = () =&gt; {  return &lt;svg /&gt;}</code></pre><p>Now, within <code>Benny</code> we can go ahead and use the <code>Consumer</code> component like this:</p><pre><code>const Benny = () =&gt; {  return &lt;Consumer&gt;  {(position) =&gt; &lt;svg /&amp;gt;}&lt;/Consumer&gt;}</code></pre><p>Okay, what\u2019s going on there?</p><p>The <code>Consumer</code> component exposes a render prop API i.e <code>children</code> is a function. This function is then passed arguments corresponding to the values saved in the context object. In this case, the <code>position</code> object with the <code>x</code> and <code>y</code> coordinate values.</p><p>It is worth noting that whenever the value from a <code>Provider</code> component changes, the associated <code>Consumer</code> component and the children will be re-rendered to keep the value(s) consumed in sync.</p><p>Also, a <code>Consumer</code> will receive values from the closest <code>Provider</code> above it in the tree.</p><p>Consider the situation below:</p><pre><code>// create context object const BennyPositionContext = createContext({ \tx: 50, \ty: 50 })</code></pre><pre><code>// get provider and consumerconst { Provider, Consumer } = BennyPositionContext</code></pre><pre><code>// wrap Root component in a Provider&amp;lt;Provider&gt;  &lt;Root /&gt;;&lt;/Provider&gt;</code></pre><pre><code>// in Benny, within Root. const Benny = () =&gt; (  &lt;Provider value={x: 100, y: 100}&gt;    // do whatever  &lt;/Provider&gt;)</code></pre><p>Now, with a new provider component introduced in <code>Benny</code>, any <code>Consumer</code> within <code>Benny</code> will receive the value <code>{x: 100, y: 100}</code> NOT the initial value of <code>{x: 50, y: 50}</code>.</p><p>This is a contrived illustrated example, but it helps solidify the foundations of using the Context API.</p><p>Having understood the necessary building blocks for using the Context API, let\u2019s build an application utilizing all you\u2019ve learned so far, with extra use cases discussed.</p><h4 id=\"example-the-mini-bank-application-\">Example: The Mini-Bank Application.</h4><p>John\u2019s an all round focused guy. When he\u2019s not working on projects from his work place, he dabbles into side projects.</p><p>One of his many side projects is a bank application he thinks could shape the future of banking. How so.</p><p>I managed to get the source code for this application. You\u2019ll find it in the code repository for the book as well.</p><p>To get started, please Install the dependencies and run the application by following the commands below:</p><pre><code>cd 02-Context-API/bank-appyarn installyarn start</code></pre><p>Once that\u2019s done, the application starts off with a login screen as seen below:</p><figure><img alt=\"VAOjsusp1WiPZs5HJC8sMmgYVNiJEmbOYd1T\" height=\"438\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/VAOjsusp1WiPZs5HJC8sMmgYVNiJEmbOYd1T\" width=\"800\"/></figure><p>You can enter whatever username and password combination of your choosing.</p><p>Upon login in you\u2019ll be presented with the application\u2019s main screen shown below:</p><figure><img alt=\"Z6kaXqVc45pIKNLJZYfEFdWSsU0wQHrvhMil\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/Z6kaXqVc45pIKNLJZYfEFdWSsU0wQHrvhMil\" width=\"600\"/></figure><p>In the main screen you can perform actions such as viewing your bank account balance and making withdrawals as well.</p><figure><img alt=\"RHV3RbXZud6IXE8JkHInhr0gj1qLiFk3p6yV\" height=\"402\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/RHV3RbXZud6IXE8JkHInhr0gj1qLiFk3p6yV\" width=\"800\"/><figcaption>cliking yes from the previous screen displays the account balance</figcaption></figure><p>Our goal here is to manage the state in this application a lot better by introducing React\u2019s Context.</p><h4 id=\"identifying-props-being-drilled-\">Identifying Props being Drilled.</h4><p>The root component of the application is called <code>Root</code>, and has the implementation below:</p><pre><code>... import { USER } from './api'class Root extends Component {  state = {    loggedInUser: null  }  handleLogin = evt =&gt; {    evt.preventDefault()    this.setState({      loggedInUser: USER    })  }  render () {    const { loggedInUser } = this.state    return loggedInUser ? (      &amp;lt;App loggedInUser={loggedInUser} /&gt;    ) : (      &lt;Login handleLogin={this.handleLogin} /&amp;gt;    )  }}</code></pre><p>If the user is logged in, the main component <code>App</code> is rendered, else we show the <code>Login</code> component.</p><pre><code>... loggedInUser ? (      &amp;lt;App loggedInUser={loggedInUser} /&gt;    ) : (   &lt;Login handleLogin={this.handleLogin} /&gt;)...</code></pre><p>Upon a successful login (which doesn\u2019t require any particular username and password combinations), the <code>state</code> of the <code>Root</code> application is updated with a <code>loggedInUser</code>.</p><pre><code>...handleLogin = evt =&gt; {    ...    this.setState({      loggedInUser: USER    })  }...</code></pre><p>In the real world, this could come from an <code>api</code> call.</p><p>For this application, I\u2019ve created a fake user in the <code>api</code> directory that exports the following user object.</p><pre><code>export const USER = {  name: 'June',  totalAmount: 2500701}</code></pre><p>Basically, the <code>name</code> and <code>totalAmount</code> of the user\u2019s bank account are retrieved and set to state when you log in.</p><p>How\u2019s the user object used in the application?</p><p>Well, consider the main component, <code>App</code>. This is the component responsible for rendering everything in the app other than the <code>Login</code> screen.</p><p>Here\u2019s the implementation of that:</p><pre><code>class App extends Component {  state = {    showBalance: false  }  displayBalance = () =&gt; {    this.setState({ showBalance: true })  }  render () {    const { loggedInUser } = this.props    const { showBalance } = this.state    return (      &lt;div className='App'&gt;            &lt;User loggedInUser={loggedInUser} profilePic={photographer} /&gt;\t&lt;ViewAccountBalance          showBalance={showBalance}          loggedInUser={loggedInUser}          displayBalance={this.displayBalance}        /&gt;        &lt;section&gt;;          &lt;WithdrawButton amount={10000} /&gt;          &lt;WithdrawButton amount={5000} /&amp;gt;        &lt;/section&gt;        &lt;Charity /&gt;      &lt;/div&gt;    )  }}</code></pre><p>It\u2019s a lot simpler that it seems. Have a second look!</p><p>The <code>loggedInUser</code> is passed as props to <code>App</code> from <code>Root</code>, and is also passed down to both <code>User</code> and <code>ViewAccountBalance</code> components.</p><figure><img alt=\"g4akMtcB-co2ZRACtlN0C6vbATgsbQRcvu09\" height=\"353\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/g4akMtcB-co2ZRACtlN0C6vbATgsbQRcvu09\" width=\"800\"/></figure><p>The <code>User</code> component receives the <code>loggedInUser</code> prop and passes it down to another child component, <code>Greeting</code> which renders the text, \u201c<em>Welcome, June</em>\u201d.</p><pre><code>//User.js const User = ({ loggedInUser, profilePic }) =&gt; {  return (    &lt;div&gt;      &lt;img  src={profilePic} alt='user' /&gt;      &lt;Greeting loggedInUser={loggedInUser} /&gt;    &lt;/div&gt;  )}</code></pre><p>Also, <code>ViewAccountBalance</code> takes in a boolean prop <code>showBalance</code> which decides whether to show the account balance or not. This is toggled to <code>true</code> when you click the \u201cyes\u201d button.</p><figure><img alt=\"1RLdVLjZIkfAntk16bMgIyHNEtDgz8UYLlSz\" height=\"353\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1RLdVLjZIkfAntk16bMgIyHNEtDgz8UYLlSz\" width=\"800\"/></figure><pre><code>//ViewAccountBalance.jsconst ViewAccountBalance = ({ showBalance, loggedInUser, displayBalance }) =&gt; {  return (    &lt;Fragment&gt;      {!showBalance ? (        &lt;div&gt;          &lt;p&gt;            Would you love to view your account balance?          &lt;/p&gt;          &lt;button onClick={displayBalance}&gt;            Yes          &lt;/button&gt;        &lt;/div&gt;      ) : (        &lt;TotalAmount totalAmount={loggedInUser.totalAmount} /&gt;      )}    &lt;/Fragment&gt;  )}</code></pre><p>From the code block above, do you also see that <code>ViewAccountBalance</code> receives the <code>loggedInUser</code> prop only to pass it to <code>TotalAmount</code>?</p><figure><img alt=\"8I2fuTlfwAtBSTpcWD9d8oNMTwlfIXPPWsoN\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/8I2fuTlfwAtBSTpcWD9d8oNMTwlfIXPPWsoN\" width=\"600\"/></figure><p><code>TotalAmount</code> receives this prop, retrieves the <code>totalAmount</code> from the user object and renders the total amount.</p><p>I\u2019m pretty sure you can figure out whatever else is going on in the code snippets above.</p><p>Having explained the code so far, do you see the obvious props drilling here?</p><p><code>loggedInUser</code> is passed down way too many times to components that don\u2019t even need to know about it.</p><p>Let\u2019s fix that with the <code>Context</code> API.</p><h4 id=\"avoid-props-drilling-with-context-\">Avoid Props Drilling with Context.</h4><p>One easy solution is to look at the <code>Root</code> component where we began passing props down and finding a way to introduce a context object in there.</p><p>Going by that solution, we could create a context object with no initial default values above the <code>Root</code> class declaration:</p><pre><code>const { Provider, Consumer } = createContext()class Root extends Component {  state = {    loggedInUser: null  }  ... }</code></pre><p>Then we could wrap the main <code>App</code> component around the <code>Provider</code> with a value prop.</p><pre><code>class Root extends Component {  state = {    loggedInUser: null  }  ...   render () {    ...    return loggedInUser ? (      &lt;Provider value={this.state.loggedInUser}&gt;        &lt;App loggedInUser={loggedInUser} /&gt;      &lt;/Provider&gt;    ) ...</code></pre><p>Initially, the <code>Provider</code> <code>value</code> prop will be <code>null</code>, but as soon as a user logs in and the <code>state</code> is updated in <code>Root</code>, the <code>Provider</code> will also receive the current <code>loggedInUser</code>.</p><p>With this done we can import the <code>Consumer</code> wherever we want and do away with passing props needlessly down the component tree.</p><p>For example here\u2019s the <code>Consumer</code> used in the <code>Greeting</code> component:</p><pre><code>import { Consumer } from '../Root'const Greeting = () =&gt; {  return (    &lt;Consumer&gt;      {user =&gt; &lt;p&gt;Welcome, {user.name}! &lt;/p&gt;;}    &lt;/Consumer&gt;  )}</code></pre><p>We could go ahead and do the same everywhere else we\u2019ve passed the <code>loggedInUser</code> prop needlessly.</p><p>And the app works just as before, only we got rid of passing down <code>loggedInUser</code> over and over again .</p><h4 id=\"isolating-implementation-details-\">Isolating Implementation Details.</h4><p>The solution highlighted above works but not without some caveat.</p><p>A better solution will be to centralise the logic for the user state and Provider in one place.</p><p>This is pretty common practice. Let me show you what I mean.</p><p>Instead of having the <code>Root</code> component manage the state for <code>loggedInUser</code>, we will create a new file called <code>UserContext.js</code>.</p><p>This file will have the related logic for updating <code>loggedInUser</code> as well as expose a context <code>Provider</code> and <code>Consumer</code> to make sure <code>loggedInUser</code> and any updater functions are accessible from anywhere in the component tree.</p><p>This sort of modularity becomes important when you have many different context objects. For example, you could have a <code>ThemeContext</code> and <code>LanguageContext</code> object in the same app.</p><p>Extracting these into separate files and components proves more manageable and effective over time.</p><p>Consider the following:</p><pre><code>// UserContext.jsimport React, { createContext, Component } from 'react'import { USER } from '../api'const { Provider, Consumer } = createContext()class UserProvider extends Component {  state = {    loggedInUser: null  }  handleLogin = evt =&gt; {    evt.preventDefault()    this.setState({      loggedInUser: USER    })  }  render () {    const { loggedInUser } = this.state    return (      &lt;Provider        value={{          user: loggedInUser,          handleLogin: this.handleLogin        }}      &gt;        {this.props.children}      &lt;/Provider&gt;    )  }}export { UserProvider as default, Consumer as UserConsumer }</code></pre><p>This represents the content of the new <code>context/UserContext.js</code> file. The logic previously handled by the <code>Root</code> component has been moved here.</p><p>Note how it handles every logic regarding the <code>loggedInUser</code> state value, and passes the needed values to <code>children</code> via a <code>Provider</code>.</p><pre><code>...&lt;Provider     value={{       user: loggedInUser,       handleLogin: this.handleLogin      }}     &gt;      {this.props.children}&lt;/Provider&gt;...</code></pre><p>In this case, the <code>value</code> prop is an object with the <code>user</code> value, and function to update it, <code>handleLogin</code>.</p><p>Also note that the Provider and Consumer are both exported. This makes it easy to consume the values from any components in the application.</p><pre><code>export { UserProvider as default, Consumer as UserConsumer }</code></pre><p>With this decoupled setup, you can use the <code>loggedInUser</code> state value anywhere in your component tree, and have it updated from anywhere in your component tree as well.</p><p>Here\u2019s an example of using this in the <code>Greeting</code> component:</p><pre><code>import React from 'react'import { UserConsumer } from '../context/UserContext'const Greeting = () =&gt; {  return (    &lt;UserConsumer&gt;      {({ user }) =&gt; &lt;p&gt;Welcome, {user.name}! &lt;/p&gt;}    &lt;/UserConsumer&gt;  )}export default Greeting</code></pre><p>How easy.</p><p>Now, I\u2019ve taken the effort to delete every reference to <code>loggedInUser</code> where the prop had to be passed down needlessly. Thanks, Context!</p><p>For example:</p><pre><code>// before const User = ({ loggedInUser, profilePic }) =&gt; {  return (    &lt;div&gt;      &lt;img src={profilePic} alt='user' /&gt;      &lt;Greeting loggedInUser={loggedInUser} /&gt;    &lt;/div&gt;  )}// after: Greeting consumes UserContext const User = ({profilePic }) =&gt; {  return (    &lt;div&gt;      &lt;img src={profilePic} alt='user' /&gt;      &lt;Greeting /&gt;     &lt;/div&gt;  )}export default User</code></pre><p>Be sure to look in the accompanying code folder for the final implementation i.e. after stripping off the <code>loggedInUser</code> from being passed down needlessly.</p><h4 id=\"updating-context-values-\">Updating Context Values.</h4><p><em>What\u2019s a bank app if you can\u2019t make withdrawals, huh?</em></p><p>Well, this app has some buttons. You click them and voil\u00e0, a withdrawal is made.</p><figure><img alt=\"-o1b6Cx1S97BwM1GzYQ7mjCgyHOxtdVRhFZ2\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/-o1b6Cx1S97BwM1GzYQ7mjCgyHOxtdVRhFZ2\" width=\"600\"/><figcaption>The withdrawal buttons</figcaption></figure><p>Since the <code>totalAmount</code> value resides in the <code>loggedInUser</code> object, we may as well have the logic to make withdrawals in the <code>UserContext.js</code> file.</p><p>Remember we\u2019re trying to centralise all logic related to the user object in one place.</p><p>To do this, we\u2019ll extend the <code>UserProvider</code> in <code>UserContext.js</code> to include a <code>handleWithdrawal</code> method.</p><pre><code>// UserContext.js... handleWithdrawal = evt =&gt; {    const { name, totalAmount } = this.state.loggedInUser    const withdrawalAmount = evt.target.dataset.amount</code></pre><p>When you click any of the buttons, we will invoke this <code>handleWithdrawal</code> method.</p><p>From the <code>evt</code> click object passed as an argument to the <code>handleWithdrawal</code> method, we then pull out the amount to be withdrawn from the <code>dataset</code> object.</p><pre><code>const withdrawalAmount = evt.target.dataset.amount</code></pre><p>This is possible because both buttons have a <code>data-amount</code> attribute set on them. For example:</p><pre><code>&lt;button data-amount=1000 /&gt;</code></pre><p>Now that we have the <code>handleWithdrawal</code> method written out, we can expose it via the <code>values</code> prop passed to <code>Provider</code> as shown below:</p><pre><code>&lt;Provider    value={{       user: loggedInUser,       handleLogin: this.handleLogin       handleWithdrawal: this.handleWithdrawal     }}   &gt;  {this.props.children}&lt;/Provider&gt;</code></pre><p>Now, we\u2019re all set to consume the <code>handleWithdrawal</code> method from anywhere in the component tree.</p><p>In this case, our focus is on the <code>WithdrawButton</code> component. Go ahead and wrap that in a <code>UserConsumer</code>, deconstruct the <code>handleWithdrawal</code> method and make it the click handler for the buttons as shown below:</p><pre><code>const WithdrawButton = ({ amount }) =&gt; {  return (    &lt;UserConsumer&gt;      {({ handleWithdrawal }) =&gt; (        &lt;button          data-amount={amount}          onClick={handleWithdrawal}        &gt;          WITHDRAW {amount}        &lt;/button&gt;      )}    &lt;/UserConsumer&gt;  )}</code></pre><figure><img alt=\"FvzJEuO9sAL6RIJgSZ5a9WznJPMhhXcqrQl6\" height=\"534\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/FvzJEuO9sAL6RIJgSZ5a9WznJPMhhXcqrQl6\" width=\"800\"/><figcaption>On logging in, the withdrawal now works as expected.</figcaption></figure><p>And that works!</p><h4 id=\"conclusion\">Conclusion</h4><p>This illustrates that you can pass not only state values, but also their corresponding updater functions in a context Provider. These will be available to be consumed anywhere in your component tree.</p><p>Having made the bank app work well with the Context API, I\u2019m pretty sure John will be proud of the progress we\u2019ve made!</p><h3 id=\"chapter-3-contexttype-using-context-without-a-consumer-\">Chapter 3: ContextType \u2014 Using Context without a Consumer.</h3><figure><img alt=\"6P3dyJTbFpm4ovPY1u6MtSwKr-lCQ9Ef5y2N\" height=\"409\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/6P3dyJTbFpm4ovPY1u6MtSwKr-lCQ9Ef5y2N\" width=\"800\"/></figure><p>So far, John has had a great experience with the Context. Thanks to Mia who recommended such great tool.</p><p>However, there\u2019s a little problem.</p><p>As John uses the context API more often, he begins to realise a problem.</p><figure><img alt=\"p8ELt767Lxgpql6OJUMdrJTrM3-IeVyYcav7\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/p8ELt767Lxgpql6OJUMdrJTrM3-IeVyYcav7\" width=\"600\"/></figure><p>When you have multiple <code>Consumers</code> within a component, it results in having a lot of nested, not-so-pleasant code.</p><p>Here\u2019s an example.</p><p>While working on the <em>Benny Home Run</em> application, John had to create a new context object to hold the game level state of the current user.</p><pre><code>// initial context objectconst BennyPositionContext = createContext({ \tx: 50, \ty: 50 })</code></pre><pre><code>// another context object for game level i.e Level 0 - 5 const GameLevelContext = createContext(0)</code></pre><p>Remember, it\u2019s common practice to split related data into different context objects for reusability and performance (owing to the fact the every consumer is re-rendered when values within a <code>Provider</code> change)</p><p>With these context objects, John goes ahead to use both <code>Consumer</code> components within the <code>Benny</code> component as follows.</p><pre><code>//grab consumer for PositionContextconst { Consumer: PositionConsumer } = BennyPositionContext</code></pre><pre><code>// grab consumer for GameLevelContextconst { Consumer: GameLevelConsumer } = GameLevelContext</code></pre><pre><code>// use both Consumers here.const Benny = () =&gt; {  return &lt;PositionConsumer&gt;    {position =&gt; &lt;GameLevelConsumer&gt;        {gameLevel =&gt; &lt;svg /&amp;gt;}    &lt;/GameLevelConsumer&gt;}  &lt;/PositionConsumer&gt;}</code></pre><p>Do you notice that consuming values from both context objects results in very nested code?</p><p>Well, this is one of the more common problem with consuming data with the <code>Consumer</code> component. With multiple consumer components, you begin to have a lot of nesting.</p><p>So, what can we do about this?</p><p>Firstly, when we learn about Hooks in a later chapter, you\u2019ll come to see an almost perfect solution to this. In the mean time, let\u2019s consider the solution available to <code>Class</code> components via something called<code>contextType</code>.</p><h4 id=\"using-a-class-component-with-contexttype-\">Using a Class Component with contextType.</h4><p>To take advantage of <code>contextType</code> you\u2019re required to work with a class component.</p><p>Consider the <code>Benny</code> component rewritten as a class component.</p><pre><code>// create context objectconst { Provider, Consumer } = createContext({ x: 50, y: 50 })// Class componentclass Benny extends Component {  render () {    return &lt;Consumer&gt;    {position =&gt; &lt;svg /&gt;}  &amp;lt;/Consumer&gt;  }}</code></pre><p>In this example, <code>Benny</code> consumes the initial context values <code>{ x: 50, y: 50 }</code> from the context object.</p><p>However, using a <code>Consumer</code> forces you to use a render prop API that may lead to nested code.</p><p>Let\u2019s get rid of the <code>Consumer</code> component by using the <code>contextType</code> class property.</p><figure><img alt=\"-9MBEu7r7Ix1SwRWzIUmnem0PM7j-7iUC9pe\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/-9MBEu7r7Ix1SwRWzIUmnem0PM7j-7iUC9pe\" width=\"600\"/></figure><p>Getting this to work is fairly easy.</p><p>First, you set the <code>contextType</code> property on the class component to a context object.</p><pre><code>const BennyPositionContext = createContext({ x: 50, y: 50 })// Class Benny extends Component ... // look here ?Benny.contextType = BennyPositionContext </code></pre><p>After setting the <code>contextType</code> property, you can go ahead to consume values from the context object by using <code>this.context</code>.</p><p>For example, to retrieve the position values <code>{ x: 50, y: 50 }</code>:</p><pre><code>class Benny extends Component {  render () {    // look here. No nesting!    const position = this.context    return &lt;svg /&gt;  }}</code></pre><h4 id=\"the-perfect-solution\">The Perfect Solution?</h4><p>Using the <code>contextType</code> class property is great, but not particularly the best solution in the world. You can only use one <code>contextType</code> within a class component. This means if you need to introduce multiple <code>Consumers</code> you\u2019ll still have some nested code.</p><h4 id=\"conclusion-1\">Conclusion</h4><p>The <code>contextType</code> property is does solve the nesting problem a little bit.</p><p>However, when we discuss Hooks in a later chapter, you\u2019ll see how much better the solution hooks offer is.</p><h3 id=\"chapter-4-react-memo-functional-purecomponent-\">Chapter 4: React.memo === Functional PureComponent.</h3><figure><img alt=\"571cqFlK3HszMqIiZJpy0gBqveysWJ1rJPDQ\" height=\"409\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/571cqFlK3HszMqIiZJpy0gBqveysWJ1rJPDQ\" width=\"800\"/></figure><p>A few weeks ago John refactored the <code>Benny</code> component to a <code>PureComponent</code>.</p><p>Here\u2019s what his change looked like:</p><p>Well, that looks good.</p><p>However, the only reason he refactored the <code>Benny</code> component to a class component was because be needed to extend <code>React.PureComponent</code>.</p><figure><img alt=\"ziP13p9hVF0bwg2iRIbWX-cPgKHnqlJU2Hx8\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/ziP13p9hVF0bwg2iRIbWX-cPgKHnqlJU2Hx8\" width=\"600\"/></figure><p>The solution works, but what if we could achieve the same effect without having to refactor from functional to class components?</p><p>Refactoring large components just because you need a specific React feature isn\u2019t the most pleasant of experiences.</p><h4 id=\"how-react-memo-works-\">How React.memo works.</h4><p><code>React.memo</code> is the perfect replacement for the class\u2019 <code>PureComponent</code>. All you do is wrap your functional component in the <code>React.memo</code> function call and you get the exact behaviour <code>PureComponent</code> gives.</p><p>Here\u2019s a quick example:</p><pre><code>// before import React from 'react'function MyComponent ({name}) {     return ( &lt;div&gt;        Hello {name}.            &lt;/div&gt;    )}export default MyComponent</code></pre><pre><code>// after import React, { memo } from 'react'export default  memo(function MyComponent ({name}) {    return ( &lt;div&gt;        Hello {name}.            &lt;/div&amp;gt;    )})</code></pre><p>So simple, it couldn\u2019t get any easier.</p><p>Technically, <code>React.memo</code> is a higher order function that takes in a functional component and returns a new memoized component.</p><p>So, if props do not change, <code>react</code> will skip rendering the component and just use the previously memoized value.</p><p>With this new found information, John refactors the functional component, <code>Benny</code> to use <code>React.memo</code>.</p><h4 id=\"handling-deeply-nested-props-\">Handling Deeply Nested Props.</h4><p><code>React.memo</code> does a props <a href=\"https://stackoverflow.com/questions/36084515/how-does-shallow-compare-work-in-react\" rel=\"noopener\">shallow comparison</a>. By implication, if you have nested props objects, the comparison will fail.</p><p>To handle such cases, <code>React.memo</code> takes in a second argument, an equality check function.</p><p>Here\u2019s a basic example:</p><pre><code>import React, { memo } from 'react'export default  memo (function MyComponent (props) {      return ( &lt;div&gt;        Hello World from {props.name.surname.short}            &lt;/div&amp;gt;    )}, equalityCheck)</code></pre><pre><code>function equalityCheck(prevProps, nextProps) {  // return perform equality check &amp; return true || false}</code></pre><p>If the <code>equalityCheck</code> function returns <code>true</code>, no re-render will happen. This would mean that the current props and previous props are the same. If you return <code>false</code>, then a re-render will occur.</p><p>If you\u2019re concerned about incurring extra performance hits from doing a deep comparison, you may use the lodash <a href=\"https://lodash.com/docs/4.17.11#isEqual\" rel=\"noopener\">isEqual</a> utility method.</p><pre><code>import { isEqual } from 'lodash'function equalityCheck(prevProps, nextProps) {\treturn isEqual(prevProps, nextProps) }</code></pre><h4 id=\"conclusion--1\">Conclusion.</h4><p><code>React.memo</code> brings the class <code>PureComponent</code> behaviour to functional components. We\u2019ve also had a look at using the <code>equalityCheck</code> function as well. If you use the <code>equalityCheck</code> function, be sure to include checks for function props where applicable. Not doing so is a common source of bugs in many React applications.</p><h3 id=\"chapter-5-the-profiler-identifying-performance-bottlenecks-\">Chapter 5: The Profiler \u2014 Identifying Performance Bottlenecks.</h3><figure><img alt=\"zWaetnakr8Rws03aoH9p6-Y7CF75XxniARP6\" height=\"409\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/zWaetnakr8Rws03aoH9p6-Y7CF75XxniARP6\" width=\"800\"/></figure><p>It\u2019s Friday and Mia is headed back home. On her way home she can\u2019t help but think to herself.</p><figure><img alt=\"T0y1iNNOpJPISg5U9IRpgEifQ7RTQGRY8kj6\" height=\"600\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/T0y1iNNOpJPISg5U9IRpgEifQ7RTQGRY8kj6\" width=\"800\"/></figure><p>\u201c<em>What have I achieved today?</em>\u201d Mia says her to herself.</p><p>After a long careful thought, she comes to the conclusion that she accomplished just one thing the entire day.</p><figure><img alt=\"FFniQ2ufSTseN1CtbH8b9DEOZj9zVZK75B67\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/FFniQ2ufSTseN1CtbH8b9DEOZj9zVZK75B67\" width=\"600\"/></figure><p>Well, how is it possible that Mia only achieved one thing the entire day?</p><p>That \u2018one thing\u2019 had better be a worthy feat!</p><p>So, what was Mia\u2019s accomplishment for the day?</p><figure><img alt=\"PR3kr9PlZMki7Ea0sDH7SG3tbgLP6gDkBwey\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/PR3kr9PlZMki7Ea0sDH7SG3tbgLP6gDkBwey\" width=\"600\"/></figure><p>It turns out that all Mia accomplished today was sitting helplessly as her browser attempted to load a page for 7 hours!</p><figure><img alt=\"p436ow1UJo09-3-IHLllkrye9K3aNwyEjELS\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/p436ow1UJo09-3-IHLllkrye9K3aNwyEjELS\" width=\"600\"/></figure><h4 id=\"measuring-performance-in-react-apps-\">Measuring Performance in React Apps.</h4><p>Web performance is a big deal. Nobody has all the time in the world to sit through minutes waiting for your webpage to load.</p><p>In order to measure performance and identify performance bottlenecks in your apps, it\u2019s crucial to have some way to inspect how long it took your app\u2019s components to render, and why they were rendered.</p><p>This is exactly why the Profiler exists.</p><p>If you\u2019ve been writing react for sometime, you might remember the <code>react-addons-perf</code> module.</p><p>Well, that has been deprecated in favour of the Profiler.</p><figure><img alt=\"JSCb7hooD8c0awGqsL5gwBIyU3XLiLmbdXqU\" height=\"600\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/JSCb7hooD8c0awGqsL5gwBIyU3XLiLmbdXqU\" width=\"800\"/></figure><p>With the Profiler, you can:</p><ul><li>Collect timing information about each component</li><li>Easily identify performance bottlenecks</li><li>Be sure to have a tool compatible with concurrent rendering</li></ul><h4 id=\"getting-started-\">Getting Started.</h4><p>To keep this as pragmatic as possible, I have set up a tiny <a href=\"https://github.com/ohansemmanuel/fake-medium\" rel=\"noopener\">application</a> we\u2019re going to profile together. i.e measure performance. We\u2019ll do this with the aid of the Profiler.</p><p>I call the application <em>fake-medium</em>, and it looks like this:</p><figure><img alt=\"BKUaV-v1lOJWBCqmYBWQ1t9dGhK-PLhxa13K\" height=\"534\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/BKUaV-v1lOJWBCqmYBWQ1t9dGhK-PLhxa13K\" width=\"800\"/><figcaption>The Fake-medium app</figcaption></figure><p>You\u2019ll find the source code for the application in the code repository for this book.</p><p>To Install the dependencies and run the app, run the following from the<code>04-The-Profiler</code> directory:</p><pre><code>cd fake-mediumyarn install yarn start</code></pre><p>If you ran those commands, you should have the application running in your default browser, on port <code>3000</code> or similar.</p><figure><img alt=\"ArMFy-gNKE3TQnNHb18m087ww9yx7wmT2VZR\" height=\"612\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/ArMFy-gNKE3TQnNHb18m087ww9yx7wmT2VZR\" width=\"800\"/><figcaption>Application running on some local port.</figcaption></figure><p>Finally, open your chrome devtools by pressing Command+Option+J (Mac) or Control+Shift+J (Windows, Linux, and Chrome OS).</p><p>Then find the React <a href=\"https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en\" rel=\"noopener\">chrome devtools</a> extension tab and click it.</p><figure><img alt=\"i0jScYALcHijfkwCh7-4rstjV1R7cMNkVslV\" height=\"534\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/i0jScYALcHijfkwCh7-4rstjV1R7cMNkVslV\" width=\"800\"/></figure><p>You\u2019ll be presented with two tabs, elements and profiler.</p><p>You guessed right, our focus is on the profiler tab, so please click it.</p><figure><img alt=\"Ea5nQBoaX-Yam1aKnwXogZM4RnSobpwuuwF0\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/Ea5nQBoaX-Yam1aKnwXogZM4RnSobpwuuwF0\" width=\"600\"/></figure><p>Doing so will lead you to the following page:</p><figure><img alt=\"n25grg6bFRAZhVz1Pqup5QcaHO3kspVp5pX1\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/n25grg6bFRAZhVz1Pqup5QcaHO3kspVp5pX1\" width=\"600\"/></figure><h4 id=\"how-does-the-profiler-work\">How does the Profiler Work?</h4><p>The Profiler works by recording a session of actual usage of your application. In this recording session it gathers information about the components in your application and displays some interesting information you can exploit to find performance bottlenecks.</p><p>To get started, click the record button.</p><figure><img alt=\"475E6wqCElRnsNOj5i3V0zuEjSWu50Znu1zl\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/475E6wqCElRnsNOj5i3V0zuEjSWu50Znu1zl\" width=\"600\"/></figure><p>After clicking \u2018record\u2019, you then go ahead to use your application as you\u2019d expect a user to.</p><p>In this case, I\u2019ve gone ahead to click the medium clap button 3 times!</p><figure><img alt=\"ZS2LZOif-tK5y2jDZVzFKEql8DNPUaJcqrge\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/ZS2LZOif-tK5y2jDZVzFKEql8DNPUaJcqrge\" width=\"600\"/></figure><p>Once you\u2019re done interacting with your application, hit stop to view the information the Profiler provides.</p><h4 id=\"making-sense-of-the-profiler-results-\">Making Sense of the Profiler Results.</h4><p>On the far right of the profiler screen, you\u2019ll find a visual representation of the number of commits made during your interaction with your application.</p><figure><img alt=\"Fw0NAsuDAeeQhEVBaUxbvSybbwSgnKnZkh6z\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/Fw0NAsuDAeeQhEVBaUxbvSybbwSgnKnZkh6z\" width=\"600\"/></figure><p>Conceptually, react does work in 2 phases. The render phase where components are rendered and the virtual DOM <em>diffed</em>, and the commit phase where actual changes in the virtual DOM are committed to the DOM.</p><p>The graphical representation you see on the far right of the profiler represents the number of commits that were made to the DOM during your interaction with the app.</p><figure><img alt=\"vt00nWdS03-5irdzKMO2wrz-NzsoC9e2zDN8\" height=\"234\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/vt00nWdS03-5irdzKMO2wrz-NzsoC9e2zDN8\" width=\"800\"/></figure><p>The taller the bar is, the longer it took <code>React</code> to render the components in this commit.</p><p>In the example above, the Profiler recorded three commits. That make sense since I clicked the button only 3 times. So, there should be only 3 commits made to the DOM.</p><p>Also the first commit took much longer than the subsequent two commits.</p><p>The three bars represent the different commits made to the DOM, and you can click on any to investigate performance metrics for the particular commit.</p><figure><img alt=\"TvR2Lh4xKXyU1fZ9MBxtVRZUE6xDRZoGcS65\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/TvR2Lh4xKXyU1fZ9MBxtVRZUE6xDRZoGcS65\" width=\"600\"/></figure><h4 id=\"the-flame-chart-\">The Flame Chart.</h4><p>After a successful recording session, you\u2019ll be presented with a couple different bits of information about your components.</p><p>First, you have 3 tabs representing different groups of information \u2014 each relating to the selected commit on the right.</p><figure><img alt=\"C7RLaaqstiCC3EQX5BqSIqmyXX3bqQgGiOQL\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/C7RLaaqstiCC3EQX5BqSIqmyXX3bqQgGiOQL\" width=\"600\"/></figure><p>The first tab represents a flame chart.</p><p>The flame chart displays information on how long it took your component tree to render.</p><figure><img alt=\"NNlVjulXdYdxRBKtxJeGfA-CKyg19nbWXQ1x\" height=\"234\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/NNlVjulXdYdxRBKtxJeGfA-CKyg19nbWXQ1x\" width=\"800\"/></figure><p>You\u2019ll notice that each component in your application tree is represented by bars of varying lengths and colors.</p><p>The length of a bar defines how long it took the component (and its children) to render.</p><p>Judging by the bar length, it appears the <code>Provider</code> component took the longest time to render. That make sense since the <code>Provider</code> is the main root component of the app, so the time represented here is the time taken for <code>Provider</code> and all its children to render.</p><p>That\u2019s half the story.</p><p>Note that the colors of the bars are different.</p><figure><img alt=\"xCTIztG-igaUJS0bcwzJp9cazGEFNLhT2Vt2\" height=\"234\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/xCTIztG-igaUJS0bcwzJp9cazGEFNLhT2Vt2\" width=\"800\"/></figure><p>For example, <code>Provider</code> and a couple other components have a <em>grey</em> color.</p><p>What does that mean?</p><p>Well, first we are investing the first commit made to the DOM during the interaction with the application.</p><figure><img alt=\"CJj3CvGXLDJw8K4QlhvuSG2mYhXvybzjToQ1\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/CJj3CvGXLDJw8K4QlhvuSG2mYhXvybzjToQ1\" width=\"600\"/></figure><p>The components with a grey color means they weren\u2019t rendered in this commit. If the component is greyed out, it wasn\u2019t rendered in this commit. So, the length of the bar only represents how long it took the component to render <em>previously</em> before this commit i.e. before the interaction with the application.</p><p>If you think about it, that\u2019s reasonable.</p><p>On careful examination, you\u2019ll see that the only component with a different flame chart color here is the <code>Clap</code> component.</p><figure><img alt=\"Nxfa35snkv9yqhL7qH8BmnQzLNwl0Cfd1lUa\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/Nxfa35snkv9yqhL7qH8BmnQzLNwl0Cfd1lUa\" width=\"600\"/></figure><p>This component represents the Medium clap button that was clicked.</p><p>A yellow bar means the component took the most time to render in this commit.</p><p>Well, no other component is coloured which means the <code>Clap</code> button was the only component re-rendered in this commit.</p><p>That\u2019s perfect!</p><p>You don\u2019t want to click the <code>Clap</code> button and have a different component being re-rendered. That\u2019ll be a performance hit right there.</p><p>In more complex applications, you\u2019ll find flame charts with not just yellow and grey bars. You\u2019ll find some with blue bars.</p><p>What\u2019s worth noting is that, yellow longer bars took more time to render, followed by the blue ones, and finally grey bars weren\u2019t re-rendered in the particular commit being viewed.</p><p>It\u2019s also possible to click on a particular bar to view more information on why it rendered or not i.e. the props and state passed to the component.</p><figure><img alt=\"Zp6admN1LQ-my7sNhTyHOPuIy83tnfEDg4kE\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/Zp6admN1LQ-my7sNhTyHOPuIy83tnfEDg4kE\" width=\"600\"/></figure><figure><img alt=\"68c6x0Hkn1WUsZFUadliBQ4KFieNlHLygSdY\" height=\"231\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/68c6x0Hkn1WUsZFUadliBQ4KFieNlHLygSdY\" width=\"800\"/></figure><p>While zoomed in, you can also click the commit bars on top to see the difference in <code>props</code> or <code>state</code> across each commit render.</p><h4 id=\"the-ranked-chart-\">The Ranked Chart.</h4><p>Once you understand how the flame chart works, the ranked chart becomes a walk in the park.</p><p>The second tab option refers to the ranked chart.</p><figure><img alt=\"OzHE40WoR-zj50CdTEzoLtXA-RqwjOfA3HRo\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/OzHE40WoR-zj50CdTEzoLtXA-RqwjOfA3HRo\" width=\"600\"/></figure><p>The ranked chart displays every component that was rendered in the commit being viewed. It displays this components ranked from top to bottom \u2014 with component which took more time to render at the top.</p><p>In this example, we have just the <code>Clap</code> component displayed in the ranked chart view. That\u2019s okay as we only expect the <code>Clap</code> component to be re-rendered upon clicking.</p><figure><img alt=\"-4zbLrlGiQ7JV7hhz2ZOMrTXcCg730UhzLEF\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/-4zbLrlGiQ7JV7hhz2ZOMrTXcCg730UhzLEF\" width=\"600\"/></figure><p>A more complex ranked chart may look like this:</p><figure><img alt=\"sSqE66OzdqOUinWUWiX9cVwY3u65gsLToquC\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/sSqE66OzdqOUinWUWiX9cVwY3u65gsLToquC\" width=\"600\"/><figcaption>Ranked chart from an application we\u2019ll profile next</figcaption></figure><p>You can see how the longer yellow bars are right there at the top, and shorter blue bars at the bottom. If you look carefully, you\u2019ll notice that the colors fade as you go from top to bottom. From more yellow bars to pale yellow bars, to light blue bars and finally blue bars.</p><h4 id=\"component-chart-\">Component Chart.</h4><p>Whenever you zoom into a component within the Profiler i.e. by clicking its associated bar, a new option on the right pops up.</p><figure><img alt=\"24jjhxXViuYu7SwY4pzS-YmM4Kiapn-h6SJN\" height=\"168\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/24jjhxXViuYu7SwY4pzS-YmM4Kiapn-h6SJN\" width=\"800\"/></figure><p><strong>Clicking this button</strong> will bring you to what\u2019s called the component chart.</p><p>The component chart displays how many times a particular component was re-rendered during the recorded interaction.</p><p>In this example, I can click the button to view chart for the <code>Clap</code> component.</p><figure><img alt=\"NYtuqFfiwdiHnMazAfjh9qu4cSs4u9HmU-Z2\" height=\"262\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/NYtuqFfiwdiHnMazAfjh9qu4cSs4u9HmU-Z2\" width=\"800\"/></figure><p>This shows three bars representing the three times the <code>Clap</code> component was re-rendered. If I saw a fourth bar here, I\u2019d begin to get worried as I only clicked three times and expected only three re-renders.</p><p>If the selected component didn\u2019t re-render at all, you\u2019ll be presented with the empty screen below:</p><figure><img alt=\"r4jafAzBQZq-nNhFsmVR2v-71vFhWcboRcOf\" height=\"216\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/r4jafAzBQZq-nNhFsmVR2v-71vFhWcboRcOf\" width=\"800\"/></figure><p><strong>NB</strong>: you can either view the component chart by clicking the button on the far right, or by double clicking a component bar from the flame or ranked chart.</p><h4 id=\"interactions-\">Interactions.</h4><p>There\u2019s one final tab in the profiler, and by default it displays an empty screen:</p><figure><img alt=\"gK7ayEjVRfzz3a5sku7ySISv97r6llrO4NqS\" height=\"212\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/gK7ayEjVRfzz3a5sku7ySISv97r6llrO4NqS\" width=\"800\"/></figure><p><strong>Interactions</strong> let you tag actions performed during a recording session with a string identifier so they can be monitored and tracked within the profiling results.</p><p>The API for this is unstable, but here\u2019s how to enable interactions in your profiling results.</p><p>First install the <code>scheduler</code> module. From your terminal, run <code>yarn add scheduler</code> within the application directory .</p><p>Once the installation is done, you need to use <code>unstable_trace</code> function exported by the module as shown below:</p><pre><code>import { unstable_trace as trace } from 'scheduler/tracing'</code></pre><p>The function is exported as <code>unstable_trace</code> but you can rename it in the import statement as I have done above.</p><p>The <code>trace</code> function has a signature similar to this:</p><pre><code>trace(\"string identifier\", timestamp, () = {})</code></pre><p>It takes a string identifier, timestamp and a callback function. Ideally, you track whatever interaction you want by passing it into the callback.</p><p>For example, I have gone ahead to do this in the <code>fake-medium</code> application:</p><pre><code>// before _handleClick () {   // do something}</code></pre><pre><code>// after _handleClick () {   trace(\"Clap was clicked!\", window.performace.now(), () =&gt; {  \t  // do something   })}</code></pre><p>The medium clap when clicked calls the <code>_handleClick</code> method. Now, I\u2019ve wrapped the functionality within the <code>trace</code> method.</p><p>Here\u2019s what happens when the profiling result is now viewed:</p><figure><img alt=\"rFrMBm33GE-2KV4WKmxx5Z8ZmVcrEDUhTjdw\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/rFrMBm33GE-2KV4WKmxx5Z8ZmVcrEDUhTjdw\" width=\"600\"/></figure><p>Clicking three times now records 3 interactions and you can click on any of the interactions to view more details about them.</p><figure><img alt=\"xqP3wRyaTYbFwyIMdrrQ26ns3qmdVerQDDDZ\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/xqP3wRyaTYbFwyIMdrrQ26ns3qmdVerQDDDZ\" width=\"600\"/></figure><p>The interactions will also show up in the flame and ranked charts.</p><figure><img alt=\"VIdivXfnxkXhPZXQLNz0Ahp8mTDwO-gYM9rF\" height=\"179\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/VIdivXfnxkXhPZXQLNz0Ahp8mTDwO-gYM9rF\" width=\"800\"/></figure><h4 id=\"example-identifying-performance-bottlenecks-in-the-bank-application-\">Example: Identifying Performance BottleNecks in the Bank Application.</h4><p>\u201c<em>Hey John, what have you done?!!!</em>\u201d, said Mia as she stumped into John\u2019s office.</p><p>\u201c<em>I was just profiling the bank application, and it\u2019s so not performant\u201d,</em> she added.</p><p>John wasn\u2019t surprised. He had not spent a lot of time thinking about performance, but with Mia up in his face, he began to have a rethink.</p><p>\u201c<em>Okay, I\u2019ll have a look and fix whatever bottlenecks I find. Can we do that together?</em>\u201d, John said while thinking to himself how much help Mia would be since she spotted the problem anyway.</p><p>\u201c<em>Oh, sure</em>\u201d, she retorted.</p><p>After spending a couple hours, they found and fixed a coupe of performance bottlenecks in the application.</p><p>What did they do? What measures were taken?</p><p>In this example, we\u2019ll spin up the bank application and pick up from where we stopped in the earlier chapter. This time we\u2019ll fix the performance bottlenecks within the application.</p><p>Here\u2019s what the bank app looks like again:</p><figure><img alt=\"7Yzv8gVG3AnyrZh4J0r3Mo4vyNcLRp1Hm7QC\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/7Yzv8gVG3AnyrZh4J0r3Mo4vyNcLRp1Hm7QC\" width=\"600\"/></figure><h4 id=\"noting-the-expected-behaviour-\">Noting the Expected Behaviour.</h4><p>When I need to profile an application, specifically during a certain interaction with an app, I like to set the baseline for what I expect in terms of performance. This sort of expectation helps you retain your focus as you delve into interpreting the results from the Profiler.</p><p>Let\u2019s consider the bank application we want to profile. The interaction in the bank app is simple. You click a set of buttons, and the withdrawal amount is updated.</p><figure><img alt=\"wsUrSq6yFhdypOPmvWWN0YK47-0ElKftTPt2\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/wsUrSq6yFhdypOPmvWWN0YK47-0ElKftTPt2\" width=\"600\"/><figcaption>The basic interaction of the app</figcaption></figure><p>Now, what would you consider the expected behaviour of this app with respect to re-renders and updates?</p><p>Well, for me, it\u2019s quite simple.</p><p>The only part of the app visually changing is the withdrawal amount. Before going into the profiling session, my expectation for a performant application will be that no unnecessary components are re-rendered, just the component responsible for updating the total amount.</p><figure><img alt=\"EQ7JvduM5RuBWJdAmA8UsUmzqK1xk2psHuOq\" height=\"193\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/EQ7JvduM5RuBWJdAmA8UsUmzqK1xk2psHuOq\" width=\"800\"/><figcaption>Where I expect re-renders to happen. Nowhere else.</figcaption></figure><p>Give or take, I\u2019ll expect just the <code>TotalAmount</code> component to be re-rendered, or any other component directly connected with that update.</p><p>With this expectation set, let\u2019s go on and profile the application.</p><p>The steps are the same as discussed earlier. You open your <code>devtools</code>, record an interaction session, and begin to interpret the results.</p><p>Now, I have gone ahead to record a session. In this session, all I did was click the \u201cwithdraw $10,000\u201d button 3 times.</p><figure><img alt=\"nJ9QImh8qxEDpRSpoxqRJ4AvbVv886-8NWpD\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/nJ9QImh8qxEDpRSpoxqRJ4AvbVv886-8NWpD\" width=\"600\"/></figure><p>Here\u2019s the flame chart from the profiling session:</p><figure><img alt=\"ssqiTuWu9mm8YKwjYBS6cfhCabx2DznFkEg8\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/ssqiTuWu9mm8YKwjYBS6cfhCabx2DznFkEg8\" width=\"600\"/><figcaption>Flame chart results</figcaption></figure><p>Oh my! From the chart above, so many components were re-rendered. You see the many bar colours represented in the flame chart ?</p><p>This is far from ideal, so let\u2019s begin to fix the problem.</p><h4 id=\"interpreting-the-flame-chart-\">Interpreting the Flame chart.</h4><p>First let\u2019s consider what\u2019s likely the root of the problem here. By default, whenever a <code>Provider</code> has its <code>value</code> changed, every child component is forced to re-render. That\u2019s how the <code>Consumer</code> gets the latest values from the <code>context</code> object and stays in sync.</p><p>The problem here is that every component apart from <code>Root</code> is a child of <code>Provider</code> \u2014 and they all get re-rendered needlessly!</p><figure><img alt=\"uEpyKNJFol4T15woTC7xYqulFpPTT5663vXe\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/uEpyKNJFol4T15woTC7xYqulFpPTT5663vXe\" width=\"600\"/><figcaption>All children components re-rendered with a change in the Provider\u2019s value.</figcaption></figure><p>So, what can we do about this?</p><p>Some of the child components don\u2019t need to be re-rendered as they are not directly connected with the change.</p><p>First, let\u2019s consider the first child component, <code>App</code>.</p><figure><img alt=\"AQurw0t4lQ210joddkcWyiTrKqQjqs2PpiSb\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/AQurw0t4lQ210joddkcWyiTrKqQjqs2PpiSb\" width=\"600\"/></figure><p>The <code>App</code> component doesn\u2019t receive any <code>prop</code> and it only manages the state value <code>showBalance</code>.</p><pre><code>class App extends Component {  state = {    showBalance: false  }  displayBalance = () =&gt; {    this.setState({ showBalance: true })  }  render () {    const { showBalance } = this.state    ...  }}</code></pre><p>It isn\u2019t directly connected with the change, and it\u2019s pointless to re-render this component.</p><p>Let\u2019s fix this by making it a <code>PureComponent</code>.</p><pre><code>// before class App extends Component {  state = {    showBalance: false  } ... }// after class App extends PureComponent {  state = {    showBalance: false  } ... }</code></pre><p>Having made <code>App</code> a <code>PureComponent</code>, did we make any decent progress?</p><p>Well, have a look at the new flame chart generated after that simple (one-liner) change.</p><figure><img alt=\"39wb21xBzdec7MPDtiihvIqhLDOxFNokPfaD\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/39wb21xBzdec7MPDtiihvIqhLDOxFNokPfaD\" width=\"600\"/></figure><p>Can you see that?</p><p>A lot of App\u2019s children aren\u2019t re-rendered needlessly, and we have a more sane flame graph now.</p><h4 id=\"profile-different-interactions-\">Profile Different Interactions.</h4><p>It\u2019s easy to assume that because we had fewer re-renders in the \u201cwithdraw amount\u201d interaction we now have a performant app.</p><p>That\u2019s not correct.</p><p>App\u2019s now a <code>PureComponent</code>, but what happens when <code>App</code> gets rendered owing to a <code>state</code> change?</p><p>Well, let\u2019s profile a different interaction. This time, load up the application and profile the interaction for viewing an account balance.</p><figure><img alt=\"fiErzN0w3LSxjNeMoYkqBZuYKnzQI5PIor25\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/fiErzN0w3LSxjNeMoYkqBZuYKnzQI5PIor25\" width=\"600\"/></figure><p>If you go ahead and profile the interaction, we get a completely different result.</p><figure><img alt=\"qMp4Ks9sIm1nMwkZqcPn8ZqtQ8Ig3dUMr-7P\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/qMp4Ks9sIm1nMwkZqcPn8ZqtQ8Ig3dUMr-7P\" width=\"600\"/><figcaption>Screencast showing the interaction being profiled.</figcaption></figure><p>Now, what\u2019s changed?</p><figure><img alt=\"6vY2o4-trUJgVEOT9xbcAkP4xFitc0sQIUVC\" height=\"219\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/6vY2o4-trUJgVEOT9xbcAkP4xFitc0sQIUVC\" width=\"800\"/></figure><p>From the flame graph above, every child component of <code>App</code> as been re-rendered. They all had nothing to do with this visual update, so those are wasted rendered.</p><p>NB: If you need to check the hierarchy of components more clearly, remember you can always click the elements tab:</p><figure><img alt=\"1D22MNaRUJ4dNwTMURzFBV9agzNJVAVSyvaB\" height=\"220\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1D22MNaRUJ4dNwTMURzFBV9agzNJVAVSyvaB\" width=\"800\"/></figure><p>Well, since these child components are functional components, let\u2019s use <code>React.memo</code> to memoize the render results so they don\u2019t change except there\u2019s a change in props.</p><pre><code>// User.jsimport { memo } from 'react'const User = memo(({ profilePic }) =&gt; {  ...})</code></pre><pre><code>// ViewAccountBalance.jsimport { memo } from 'react'const ViewAccountBalance = memo(({ showBalance, displayBalance }) =&gt; {      ...})</code></pre><pre><code>// WithdrawButton.jsimport { memo } from 'react'const WithdrawButton = memo(({ amount }) =&gt; {    ...  )})</code></pre><p>Now, when you do that and re-profile the interaction, we get a much nicer flame chart:</p><figure><img alt=\"vWFaZzoArl9dpgS1Pnq81szMWgMnTxE5hXGW\" height=\"219\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/vWFaZzoArl9dpgS1Pnq81szMWgMnTxE5hXGW\" width=\"800\"/></figure><p>Now, only <code>ViewAccountBalance</code> and other child components are re-rendered. That\u2019s okay.</p><p>When you view your flame chart i.e if you\u2019re following along, you may see something slightly different.</p><p>The names of the component may not be shown. You get the generic name <code>Memo</code> and it becomes difficult to track which component is what.</p><figure><img alt=\"jvKxSY6aIsr2b5LaoGKexRg3jKOkH0GzvOqz\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/jvKxSY6aIsr2b5LaoGKexRg3jKOkH0GzvOqz\" width=\"600\"/></figure><p>To change this, set the <code>displayName</code> property for the memoized components.</p><p>Below\u2019s an example.</p><pre><code>// ViewAccountBalance.jsconst ViewAccountBalance = memo(({ showBalance, displayBalance }) =&gt; {  ...})</code></pre><pre><code>// set the displayName hereViewAccountBalance.displayName = 'ViewAccountBalance'</code></pre><p>You go ahead and do this for all the memoized functional components.</p><h4 id=\"the-provider-value-\">The Provider Value.</h4><p>We\u2019re pretty much done with resolving the performance leaks in the application, however, there\u2019s one more thing to do.</p><p>The effect isn\u2019t very obvious in this application, but will come handy as you face more cases in the real world such as in situations where a <code>Provider</code> is nested within other components.</p><p>The implementation of the <code>Provider</code> in the bank application had the following:</p><pre><code>...&lt;Provider    value={{       user: loggedInUser,       handleLogin: this.handleLogin       handleWithdrawal: this.handleWithdrawal     }}   &gt;  {this.props.children}&lt;/Provider&gt;...</code></pre><p>The problem here is that we\u2019re passing a new object to the <code>value</code> prop every single time. A better solution will be to keep a reference to these values via state. e.g.</p><pre><code>&lt;Provider value={this.state}&gt;\t{this.props.children}&lt;/Provider&gt;</code></pre><p>Doing this requires a bit of refactoring as shown below:</p><pre><code>// context/UserContext.jsclass UserProvider extends Component {  constructor () {    super()    this.state = {      user: null,      handleLogin: this.handleLogin,      handleWithdrawal: this.handleWithdrawal    }  }  ...  render () {    return &lt;Provider value={this.state}&gt;  \t\t{this.props.children}\t&lt;/Provider&gt;  }}</code></pre><p>Be sure to look in the associated code folder if you need more clarity on this.</p><h4 id=\"conclusion--2\">Conclusion.</h4><p>Profiling applications and identifying performance leaks is fun and rewarding. I hope you\u2019ve gained relevant knowledge in this section.</p><h3 id=\"chapter-6-lazy-loading-with-react-lazy-and-suspense-\">Chapter 6: Lazy Loading with React.Lazy and Suspense.</h3><figure><img alt=\"f4WHq-CWHVcLzpw3WmDmuTfOdZCbreBf4fRJ\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/f4WHq-CWHVcLzpw3WmDmuTfOdZCbreBf4fRJ\" width=\"600\"/></figure><p>\u201c<em>Hey John, we need to look into lazy loading some modules in the Benny application</em>\u201d, says Tunde, John\u2019s manager.</p><p>John\u2019s had great feedback from his manager for the past few months. Every now and then Tunde storms into the office with a new project idea. Today, it\u2019s lazy loading with <code>React.Lazy</code> and <code>Suspense</code>.</p><p>John\u2019s never lazy loaded a module with React.Lazy and Suspense before now. This is all new to him, so he ventures into a quick study to deliver on what his manager has requested.</p><h4 id=\"what-is-lazy-loading\">What is Lazy Loading?</h4><p>When you bundle your application, you likely have the entire application bundled in one large chunk.</p><p>As your app grows, so does the bundle.</p><figure><img alt=\"-eEQQvR2dpfwYIIW45KUncl6orjYCfsIUSKv\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/-eEQQvR2dpfwYIIW45KUncl6orjYCfsIUSKv\" width=\"600\"/></figure><p>To understand lazy loading, here\u2019s the specific use case Tunde had in mind when he discussed with John.</p><p>\u201c<em>Hey John, do you remember the Benny app has an initial home screen?</em>\u201d, said Tunde.</p><p>By initial home scree, Tunde was referring to this:</p><figure><img alt=\"WLAaGYYoijsLOrcC6jDilA81UbYyiwoREfg3\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/WLAaGYYoijsLOrcC6jDilA81UbYyiwoREfg3\" width=\"600\"/></figure><p>This is the first screen the user encounters when they visit the Benny game. To begin playing the game, you must click the \u201cStart Game\u201d button to be redirected to the actual game scene.</p><p>\u201c<em>John, the problem here is that we\u2019ve bundled all our React components together and are all served to the user on this page</em>\u201d.</p><p>\u201c<em>Oh, I see where you\u2019re going</em>\u201d, said John.</p><p>\u201c<em>Instead of loading the <code>GameScene</code> component and its associated assets, we could defer the loading of those until the user actually clicks \u2019Start Game\u2019, huh?</em>\u201d, said John.</p><p>And Tunde agreed with a resounding \u201c<em>Yes, that\u2019s exactly what I mean</em>\u201d.</p><p>Lay loading refers to deferring the loading of a particular resource until much later, usually when a user makes an interaction that demands the resource to be actually loaded. In some cases it could also mean preloading a resource.</p><p>Essentially, the user doesn\u2019t get the lazy loaded bundle served to them initially, rather it is fetched much later at runtime.</p><p>This is great for performance optimisations, initial load speed etc.</p><p>React makes lazy loading possible by employing the dynamic import syntax.</p><p>Dynamic imports refer to a <code>tc39</code> syntax <a href=\"https://github.com/tc39/proposal-dynamic-import\" rel=\"noopener\">proposal for javascript</a>, however, with transpilers like Babel, we can use this syntax today.</p><p>The typical, static way of importing a module looks like this:</p><pre><code>import { myModule } from 'awesome-module'</code></pre><p>While this is desirable in many cases, the syntax doesn\u2019t allow for dynamically loading a module at runtime.</p><p>Being able to dynamically load a part of a Javascript application at runtime makes way for interesting use cases such as loading a resource based on a user\u2019s language (a factor that can only be determined at runtime), or only loading some code just when it is likely to be used by the user (performance gains).</p><p>For these reasons (and more) there\u2019s a <a href=\"https://github.com/tc39/proposal-dynamic-import\" rel=\"noopener\">proposal</a> for introducing the dynamic import syntax to Javascript.</p><p>Here\u2019s what the syntax looks like:</p><pre><code>import('path-to-awesome-module')</code></pre><p>It has a syntax similar to a function, but is really not a function. It doesn\u2019t inherit from <code>Funtion.proptotype</code> and you can\u2019t invoke methods such as <code>call</code> and <code>apply</code>.</p><p>The returned result from the dynamic import call is a promise which is resolved with the imported module.</p><pre><code>import('path-to-awesome-module')\t.then(module =&gt; {     // do something with the module here e.g. module.default() to invoke the default export of the module. })</code></pre><h4 id=\"using-react-lazy-and-suspense-\">Using React.lazy and Suspense.</h4><p><code>React.lazy</code> and <code>Suspense</code> make using dynamic imports in a React application so easy.</p><p>For example, consider the demo code for the Benny application below:</p><pre><code>import React from 'react'import Benny from './Benny'import Scene from './Scene'import GameInstructions from './GameInstructions'</code></pre><pre><code>class Game extends Component {  state = {    startGame: false  }  render () {    return !this.state.startGame ?         &lt;GameInstructions /&gt; : \t\t&lt;Scene /&gt;  }}export default Game;</code></pre><p>Based on the state property <code>startGame</code>, either the <code>GameInstructions</code> or <code>Scene</code> component is rendered when the user clicks the \u201cStart Game\u201d button.</p><p><code>GameInstructions</code> represents the home page of the game and <code>Scene</code> the entire scene of the game itself.</p><p>In this implementation, <code>GameInstructions</code> and <code>Scene</code> will be bundled together in the same Javascript resource.</p><p>Consequently, even when the user hasn\u2019t shown intent to start playing the game, we would have loaded and sent to the user, the complex <code>Scene</code> component which contains all the logic for the game scene.</p><p>So, what do we do?</p><p>Let\u2019s defer the loading of the <code>Scene</code> component.</p><p>Here\u2019s how easy <code>React.lazy</code> makes that.</p><pre><code>// before import Scene from './Scene'</code></pre><pre><code>// now const Scene = React.lazy(() =&gt; import('./Scene'))</code></pre><p><code>React.lazy</code> takes a function that must call a dynamic import. In this case, the dynamic import call is <code>import('./Scene')</code>.</p><p>Note that <code>React.lazy</code> expects the dynamically loaded module to have a <code>default</code> export containing a React component.</p><p>With the <code>Scene</code> component now dynamically loaded, when the application is bundled for production, a separate module (or javascript file) will be created for the <code>Scene</code> dynamic import.</p><p>When the app loads, this javascript file won\u2019t be sent to the user. However, if they click the \u201cStart Game\u201d button and show intent to load the <code>Scene</code> component, a network request would be made to fetch the resource from the remote server.</p><p>Now, fetching from the server introduces some latency. To handle this, wrap the <code>Scene</code> component in a <code>Suspense</code> component to show a fallback for when the resource is being fetched.</p><p>Here\u2019s what I mean:</p><pre><code>import { Suspense } from 'react'const Scene = React.lazy(() =&gt; import('./Scene'))</code></pre><pre><code>class Game extends Component {  state = {    startGame: false  }  render () {    return !this.state.startGame ?         &lt;GameInstructions /&gt; : \t\t// look here\t\t&lt;;Suspense fallback=\"&lt;div&gt;loading ...&lt;/div&gt;\"&gt;\t\t  &lt;Scene /&gt;\t\t&lt;/Suspense&gt;  }}export default Game;</code></pre><p>Now, when the network request is initiated to fetch the <code>Scene</code> resource, we\u2019ll show a \u201cloading\u2026\u201d fallback courtesy the <code>Suspense</code> component.</p><p><code>Suspense</code> takes a <code>fallback</code> prop which can be a markup as shown here, or a full blown React component e.g. a custom loader.</p><p>With <code>React.lazy</code> and <code>Suspense</code> you can suspend the fetching of a component until much later, and show a fallback for when the resource is being fetched.</p><p>How convenient.</p><p>Also, you can place the <code>Suspense</code> component anywhere above the lazy loaded component. In this case the <code>Scene</code> component.</p><p>If you also had multiple lazy loaded components, you could wrap them in a single <code>Suspense</code> component or multiple, depending on your specific use case.</p><h4 id=\"handling-errors-\">Handling Errors.</h4><p>In the real-world, things break often, right?</p><p>It\u2019s possible that in the process of fetching the lazy loaded resource, a network error occurs.</p><p>To handle such case, be sure to wrap your lazy loaded components in an <em>Error Boundary</em>.</p><p>Remember error boundaries from the Lifecycle method chapter?</p><p>Here\u2019s an example:</p><pre><code>import { Suspense } from 'react'import MyErrorBoundary from './MyErrorBoundary'const Scene = React.lazy(() =&gt; import('./Scene'))class Game extends Component {  state = {    startGame: false  }</code></pre><pre><code>  render () {    return &amp;lt;MyErrorBoundary&gt;         {!this.state.startGame ?            &lt;GameInstructions /&gt; : \t\t   &lt;Suspense fallback=\"loading ...\"&gt;\t\t     &lt;Scene /&gt;;\t\t   &lt;/Suspense&gt;}\t\t&lt;/MyErrorBoundary&gt;  }}export default Game;</code></pre><p>Now, if an error occurs while fetching the lazy loaded resource, it\u2019ll be graciously handled by the error boundary.</p><h4 id=\"no-named-exports-\">No named exports.</h4><p>If you remember from the section above, I did mention that <code>React.lazy</code> expects the dynamic import statement to include a module with a <strong>default export</strong> being a React component.</p><p>At the moment, <code>React.lazy</code> doesn\u2019t support named exports. That\u2019s not entirely a bad thing, as it keeps tree shaking working so you don\u2019t import actual unused modules.</p><p>Consider the following module:</p><pre><code>// MyAwesomeComponents.js export const AwesomeA = () =&gt; &lt;div&gt; I am awesome &lt;/div&gt; export const AwesomeB = () =&gt; &lt;div&gt; I am awesome &lt;/div&gt; export const AwesomeC = () =&gt; &lt;div&gt; I am awesome &lt;/div&gt;</code></pre><p>Now, if you attempt to use <code>React.lazy</code> with a dynamic import of the module above, you\u2019ll get an error.</p><pre><code>// SomeWhereElse.js const Awesome = React.lazy(() =&gt; import('./MyAwesomeComponents'))</code></pre><p>That won\u2019t work since there\u2019s no default export in the <code>MyAwesomeComponents.js</code> module.</p><p>A workaround would be to create some other module that exports one of the components as a default.</p><p>For example, if I was interested in lazy loading the <code>AwesomeA</code> component from the <code>MyAwesomeComponents.js</code> module, I could create a new module like this:</p><pre><code>// AwesomeA.js export { AwesomeA as default } from './MyAwesomeComponents'</code></pre><p>Then I can can go ahead to effectively use <code>React.lazy</code> as follows:</p><pre><code>// SomeWhereElse.jsconst AwesomeA = React.lazy(() =&gt; import('AwesomeA'))</code></pre><p>Problem solved!</p><h4 id=\"code-splitting-routes-\">Code splitting routes.</h4><p>Code splitting advocates that instead of sending this large chunk of code to the user at once, you may dynamically send chunks to the user when they need it.</p><p>We had looked at component based code splitting in the earlier examples, but another common approach is with route based code splitting.</p><p>In this method, the code is split into chunks based on the routes in the application.</p><figure><img alt=\"AdX6wJOpumuGlg07LGrWXU55cVtu-wcsxGP7\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/AdX6wJOpumuGlg07LGrWXU55cVtu-wcsxGP7\" width=\"600\"/></figure><p>We could also take our knowledge of lazy loading one step further by code splitting routes.</p><p>Consider a typical React app that uses <code>react-router</code> for route matching.</p><pre><code>const App = () =&gt; (  &lt;Router&gt;      &lt;Switch&gt;        &lt;Route exact path=\"/\" component={Home}/&gt;        &lt;Route path=\"/about\" component={About}/&gt;      &lt;/Switch&gt;  &lt;/Router&gt;);</code></pre><p>We could lazy load the <code>Home</code> and <code>About</code> components so they are only fetched when the user hits the associated routes.</p><p>Here\u2019s how with <code>React.Lazy</code> and <code>Suspense</code>.</p><pre><code>// lazy load the route componentsconst Home = React.lazy(() =&gt; import('./Home'))const About = React.lazy(() =&gt; import('./About'))</code></pre><pre><code>// Provide a fallback with Suspenseconst App = () =&gt; (  &lt;Router&amp;gt;    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;      &lt;Switch&gt;        &lt;Route exact path=\"/\" component={Home}/&gt;        &lt;Route path=\"/about\" component={About}/&gt;      &lt;/Switch&gt;    &lt;/Suspense&gt;  &lt;/Router&gt;);</code></pre><p>Easy, huh?</p><p>We\u2019ve discussed how <code>React.Lazy</code> and <code>Suspense</code> works, but under the hood, the actual code splitting i.e. generating separate bundles for different modules is done by a bundler, for example <a href=\"https://webpack.js.org/\" rel=\"noopener\">Webpack</a>.</p><p>If you use <code>create-react-app</code>, <code>Gatsby</code> or <code>Next.js</code> then you have this already set up for you.</p><p>Setting this up yourself is also easy, you just need to tweak your <code>Webpack</code> config a little bit.</p><p>The official <code>Webpack</code> documentation has an <a href=\"https://webpack.js.org/guides/code-splitting/\" rel=\"noopener\">entire guide</a> on this. The guide may be worth checking if you\u2019re handling the budding configurations in your application yourself.</p><h4 id=\"example-adding-lazy-loading-to-the-bank-app-\">Example: Adding Lazy Loading to the Bank App.</h4><p>We can add some lazy loading to the bank application we saw from Chapter 2.</p><p>Consider the <code>Root</code> component of the application:</p><pre><code>const Root = () =&gt; (  &lt;UserProvider&gt;    &lt;UserConsumer&gt;      {({ user, handleLogin }) =&gt;        user ? &lt;App /&gt; : &lt;Login handleLogin={handleLogin} /&gt;      }    &lt;/UserConsumer&gt;  &lt;/UserProvider&gt;)</code></pre><p>When a user isn\u2019t logged in we display the login page, and the <code>App</code> component only when the user is logged in.</p><p>We could lazy load the <code>App</code> component, right?</p><p>This is very easy. You use the dynamic import syntax with <code>React.lazy</code> and wrap the <code>App</code> component in a <code>Suspense</code> component.</p><p>Here\u2019s how:</p><pre><code>...const App = React.lazy(() =&gt; import('./containers/App'))const Root = () =&gt; (  ...  &lt;Suspense fallback='loading...'&gt;     &lt;App /&amp;gt;  &lt;/Suspense&gt;)</code></pre><p>Now, if you throttle your network connection to simulate Slow 3G, you\u2019ll see the intermediate <em>\u201cloading\u2026\u201d</em> text after logging in.</p><figure><img alt=\"IW7iLI-wxcnn9I1L3bHHGzgpipbg6hcsBzPE\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/IW7iLI-wxcnn9I1L3bHHGzgpipbg6hcsBzPE\" width=\"600\"/></figure><h4 id=\"conclusion--3\">Conclusion.</h4><p><code>React.lazy</code> and <code>Suspense</code> are great, and so intuitive to work with, however, they do not support server side rendering yet.</p><p>It\u2019s likely this will change in the future, but in the mean time, if you care about SSR, using <a href=\"https://github.com/jamiebuilds/react-loadable\" rel=\"noopener\">react-loadable</a> is your best bet for lazy loading <code>React</code> components.</p><h3 id=\"chapter-7-hooks-building-simpler-react-apps-\">Chapter 7: Hooks \u2014 Building Simpler React Apps.</h3><figure><img alt=\"nSjeot4viuP2OG3F7I3AwlxLakzO5xCuzGV8\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/nSjeot4viuP2OG3F7I3AwlxLakzO5xCuzGV8\" width=\"600\"/></figure><p>For the past 3 years John\u2019s been writing React apps, functional components have mostly been dumb.</p><figure><img alt=\"60PnHQsIH-SlznuOqQ84T08blhFnXM3ygp7i\" height=\"600\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/60PnHQsIH-SlznuOqQ84T08blhFnXM3ygp7i\" width=\"800\"/></figure><p>If you wanted local state or some other complex side effects, you had to reach out to class component. You either painfully refactor your functional components to class components or nothing else.</p><p>It\u2019s a bright Thursday afternoon, and while having lunch, Mia introduces John to Hooks.</p><figure><img alt=\"zG-t1Hr6vonZBF1NbaepxzXMHLemGS1zhR4x\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/zG-t1Hr6vonZBF1NbaepxzXMHLemGS1zhR4x\" width=\"600\"/></figure><p>She speaks so enthusiastically, it piques John\u2019s interest.</p><p>Of all the things Mia said, one thing struck John. \u201c<em>With hooks, functional components become just as powerful (if not more powerful) than your typical class components</em>\u201d.</p><figure><img alt=\"epxPtULUEPakK0-3-EVfdtK5--vLsIHjVtRi\" height=\"600\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/epxPtULUEPakK0-3-EVfdtK5--vLsIHjVtRi\" width=\"800\"/></figure><p>That\u2019s a bold statement from Mia.</p><p>So, let\u2019s consider what hooks are.</p><h4 id=\"introducing-hooks-\">Introducing Hooks.</h4><p>Early this year, 2019, the React team released a new addition, hooks, to React in version <code>16.8.0.</code></p><p>If React were a big bowl of candies, then hooks are the latest additions, very chewy candies with great taste!</p><p>So, what exactly do hooks mean? And why are they worth your time?</p><p>One of the main reasons hooks were added to React is to offer a more powerful and expressive way to write (and share) functionality between components.</p><blockquote>In the longer term, we expect Hooks to be the primary way people write React components \u2014 <a href=\"https://reactjs.org/docs/hooks-faq.html#should-i-use-hooks-classes-or-a-mix-of-both\" rel=\"noopener\">React Team</a></blockquote><p>If hooks are going to be that important, why not learn about them in a fun way!</p><h4 id=\"the-candy-bowl-\">The Candy Bowl.</h4><p>Consider React to be a beautiful bowl of candy.</p><figure><img alt=\"pjja8sdMgoi2fUu1o2PCBoFmo4ihiNtfE7BD\" height=\"711\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/pjja8sdMgoi2fUu1o2PCBoFmo4ihiNtfE7BD\" width=\"800\"/></figure><p>The bowl of candy has been incredibly helpful to people around the world.</p><figure><img alt=\"1BvN5dNjhTWnvWoQh2jWDyUlyLcSZLT-zlqa\" height=\"711\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1BvN5dNjhTWnvWoQh2jWDyUlyLcSZLT-zlqa\" width=\"800\"/></figure><p>The people who made this bowl of candy realized that some of the candies in the bowl weren\u2019t doing people much good.</p><p>A couple of the candies tasted great, yes! But they brought about some complexity when people ate them \u2014 think render props and higher order components?</p><figure><img alt=\"ZuxFKQ3ZKRWVVn982t9Ey8MvL8EQGzfwkoqt\" height=\"775\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/ZuxFKQ3ZKRWVVn982t9Ey8MvL8EQGzfwkoqt\" width=\"743\"/></figure><p>So, what did they do?</p><figure><img alt=\"CuOhbGjag0VyZ6Un3XfJgdoC5hiugK9V49b0\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/CuOhbGjag0VyZ6Un3XfJgdoC5hiugK9V49b0\" width=\"600\"/></figure><p>They did the right thing \u2014 not throwing away all the previous candies, but making new sets of candies.</p><p>These candies were called <strong>Hooks</strong>.</p><figure><img alt=\"X1P4ajaVzaSiAfXwewXeXNdI5hzMJFyNBNva\" height=\"605\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/X1P4ajaVzaSiAfXwewXeXNdI5hzMJFyNBNva\" width=\"800\"/></figure><p>These candies exist for one purpose: <strong>to make it easier for you to do the things you are already doing</strong>.</p><figure><img alt=\"m55098wKgv-QFB3zcmy0vL3smJZ9vRaeLDcc\" height=\"577\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/m55098wKgv-QFB3zcmy0vL3smJZ9vRaeLDcc\" width=\"800\"/></figure><p>These candies aren\u2019t super special. In fact, as you begin to eat them you\u2019ll realize they taste familiar \u2014 they are just <strong>Javascript functions</strong>!</p><figure><img alt=\"RWmYzL3pHLO8573ms4TNS519-Dy7CGbSfyOb\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/RWmYzL3pHLO8573ms4TNS519-Dy7CGbSfyOb\" width=\"600\"/></figure><p>As with all good candies, these 10 new candies all have their unique names. Though they are collectively called <strong>hooks</strong>.</p><p>Their names always begin with the three letter word, use \u2026 e.g. <code>useState</code>, <code>useEffect</code> etc.</p><p>Just like chocolate, these 10 candies all share some of the same ingredients. Knowing how one tastes, helps you relate to the other.</p><p>Sounds fun? Now let\u2019s have these candies.</p><h4 id=\"the-state-hook-\">The State Hook.</h4><p>As stated earlier, hooks are functions. Officially, there are 10 of them. 10 new functions that exist to make writing and sharing functionalities in your components a lot more expressive.</p><p>The first hook we\u2019ll take a look at is called, <code>useState</code>.</p><p>For a long time, you couldn\u2019t use the local state in a functional component. Well, not until hooks.</p><p>With <code>useState</code>, your functional component can have (and update) local state.</p><p>How interesting.</p><p>Consider the following counter application:</p><figure><img alt=\"21F0jCXkYSFWmal4Fa3BxhlwaWre7WiBkrpG\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/21F0jCXkYSFWmal4Fa3BxhlwaWre7WiBkrpG\" width=\"600\"/></figure><p>With the Counter component shown below:</p><p>Simple, huh?</p><p>Let me ask you one simple question. Why exactly do we have this component as a <code>Class</code> component?</p><p>Well, the answer is simply because we need to keep track of some local state within the component.</p><p>Now, here\u2019s the same component refactored to a functional component with access to state via the <code>useState</code> hooks.</p><p>What\u2019s different?</p><p>I\u2019ll walk you through it step by step.</p><p>A functional component doesn\u2019t have all the <code>Class extend ...</code> syntax.</p><pre><code>function CounterHooks() {}</code></pre><p>It also doesn\u2019t require a render method.</p><pre><code>function CounterHooks() {    return (      &lt;div&gt;        &lt;h3 className=\"center\"&gt;Welcome to the Counter of Life &lt;/h3&gt;        &lt;button           className=\"center-block\"           onClick={this.handleClick}&gt; {count} &lt;/button&gt;      &lt;/div&gt;    ); }</code></pre><p>There are two concerns with the code above.</p><ul><li>You\u2019re not supposed to use the <code>this</code> keyword in function components.</li><li>The <code>count</code> state variable hasn\u2019t been defined.</li></ul><p>Extract <code>handleClick</code> to a separate function within the functional component:</p><pre><code>function CounterHooks() {  const handleClick = () =&gt; {   }  return (      &lt;div&gt;        &lt;h3 className=\"center\"&gt;Welcome to the Counter of Life &lt;/h3&gt;        &lt;button           className=\"center-block\"           onClick={handleClick}&gt; {count} &lt;/button&gt;      &lt;/div&gt;    ); }</code></pre><p>Before the refactor, the count variable came from the class component\u2019s state object.</p><p>In functional components, and with hooks, that comes from invoking the <code>useState</code> function or hook.</p><p><code>useState</code> is called with one argument, the initial state value e.g. <code>useState(0)</code> where 0 represents the initial state value to be kept track of.</p><p>Invoking this function returns an array with two values.</p><pre><code>//? returns an array with 2 values. useState(0) </code></pre><p>The first value being the current <code>state</code> value being tracked, and second, a function to update the <code>state</code> value.</p><p>Think of this as some <code>state</code> and <code>setState</code> replica - however, they aren\u2019t quite the same.</p><p>With this new knowledge, here\u2019s <code>useState</code> in action.</p><pre><code>function CounterHooks() {  // ?   const [count, setCount] = useState(0);  const handleClick = () =&gt; {    setCount(count + 1)  }  return (      &lt;div&gt;        &lt;h3 className=\"center\"&gt;Welcome to the Counter of Life &lt;/h3&gt;        &lt;button           className=\"center-block\"           onClick={handleClick}&gt; {count} &lt;/button&gt;      &lt;/div&gt;    ); } </code></pre><p>There are a few things to note here, apart from the obvious simplicity of the code!</p><p>One, since invoking <code>useState</code> returns an array of values, the values could be easily destructed into separate values as shown below:</p><pre><code>const [count, setCount] = useState(0);</code></pre><p>Also, note how the <code>handleClick</code> function in the refactored code doesn\u2019t need any reference to <code>prevState</code> or anything like that.</p><p>It just calls <code>setCount</code> with the new value, <code>count + 1</code>.</p><p>Simple as it sounds, you\u2019ve built your very first component using hooks. I know it\u2019s a contrived example, but that\u2019s a good start!</p><p><strong>NB</strong>: it\u2019s also possible to pass a function to the state updater function. This is usually recommended as with <code>setState</code> when a state update depends on a previous value of state e.g. <code>setCount(prevCount =&gt; prevCount +</code> 1)</p><h4 id=\"multiple-usestate-calls-\">Multiple useState calls.</h4><p>With class components, we all got used to setting state values in an object whether they contained a single property or more.</p><pre><code>// single property state = {  count: 0}// multiple properties state = { count: 0, time: '07:00'}</code></pre><p>With <code>useState</code> you may have noticed a subtle difference.</p><p>In the example above, we only called <code>useState</code> with the actual initial value. Not an object to hold the value.</p><pre><code>useState(0)</code></pre><p>So, what if we wanted to keep track of another state value?</p><p>Can multiple <code>useState</code> calls be used?</p><p>Consider the component below. It\u2019s the same counter application with a twist. This time the counter keeps track of the time of click.</p><figure><img alt=\"y1ygRHiHbm6haOM0uTRin1vZ9VoYMLvG1hYS\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/y1ygRHiHbm6haOM0uTRin1vZ9VoYMLvG1hYS\" width=\"600\"/></figure><p>As you can see, the hooks usage is quite the same, except for having a new <code>useState</code> call.</p><pre><code>const [time, setTime] = useState(new Date())</code></pre><p>Now, the <code>time</code> state variable is used in the rendered markup to display the hour, minute and second of the click.</p><pre><code>&lt;p&gt;     at: {`${time.getHours()} : ${time.getMinutes()} :${time.getSeconds()}`}  &lt;/p&gt;</code></pre><h4 id=\"object-as-initial-values\">Object as Initial Values</h4><p>Is it possible to use an object with <code>useState</code> as opposed to multiple <code>useState</code> calls?</p><p>If you choose to do this, you should note that unlike <code>setState</code> calls, the values passed into <code>useState</code> replaces the state value.</p><p><code>setState</code> merges object properties but <code>useState</code> replaces the entire value.</p><h4 id=\"the-effect-hook-\">The Effect Hook.</h4><p>With class components you\u2019ve likely performed side effects such as logging, fetching data or managing subscriptions.</p><p>These side effects may be called \u201ceffects\u201d for short, and the effect hook, <code>useEffect</code> was created for this purpose.</p><p>How\u2019s it used?</p><p>Well, the <code>useEffect</code> hook is called by passing it a function within which you can perform your side effects.</p><p>Below\u2019s a quick example:</p><pre><code>useEffect(() =&gt; {  // ? you can perform side effects here  console.log(\"useEffect first timer here.\")}) </code></pre><p>To <code>useEffect</code> I\u2019ve passed an anonymous function with some side effect called within it.</p><p>The next logical question is, when is the <code>useEffect</code> function invoked?</p><p>Well, remember that in class components you had lifecycle methods such as <code>componentDidMount</code> and <code>componentDidUpdate</code>.</p><p>Since functional components don\u2019t have these lifecycle methods, <code>useEffect</code> <em>kinda</em> takes their place.</p><p>Thus, in the example above, the function within <code>useEffect</code> also known as the effect function, will be invoked when the functional component mounts (<code>componentDidMount</code>) and when the component updates <code>componentDidUpdate</code>).</p><p>Here\u2019s that in action.</p><p>By adding the <code>useEffect</code> call above to the counter app, we indeed get the log from the <code>useEffect</code> function.</p><figure><img alt=\"T9u1mPVp81HSg4s3MsRRiOYc6KRzB1z5tLLv\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/T9u1mPVp81HSg4s3MsRRiOYc6KRzB1z5tLLv\" width=\"600\"/></figure><p>By default, the <code>useEffect</code> function will be called after every render.</p><p><strong>NB</strong>: The <code>useEffect</code> hook isn\u2019t entirely the same as <code>componentDidMount</code> + <code>componentDidUpdate</code>. It can be viewed as such, but the implementation differs with some subtle differences.</p><h4 id=\"passing-array-dependencies-\">Passing Array Dependencies.</h4><p>It\u2019s interesting that the effect function is invoked every time there\u2019s an update. That\u2019s great, but it\u2019s not always the desired functionality.</p><p>What if you only want to run the effect function only when the component mounts?</p><p>That\u2019s a common use case and <code>useEffect</code> takes a second parameter, an array of dependencies to handle this.</p><p>If you pass in an empty array, the effect function is run only on mount \u2014 subsequent re-renders don\u2019t trigger the effect function.</p><pre><code>useEffect(() =&gt; {    console.log(\"useEffect first timer here.\")}, [])</code></pre><figure><img alt=\"KAv1j3znRKI9nnXTHC-VSLHkqHyb-4Cskas7\" height=\"346\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/KAv1j3znRKI9nnXTHC-VSLHkqHyb-4Cskas7\" width=\"546\"/></figure><p>If you pass any values into this array, then the effect function will be run on mount, and anytime the values passed are updated. That is, if any of the values are changed, the effected call will re-run.</p><pre><code>useEffect(() =&gt; {    console.log(\"useEffect first timer here.\")}, [count])</code></pre><p>The effect function will be run on mount, and whenever the count function changes.</p><figure><img alt=\"uDU1DVT8gyC4jce-XQZDT5ftKLMmFMUKCD8T\" height=\"383\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/uDU1DVT8gyC4jce-XQZDT5ftKLMmFMUKCD8T\" width=\"543\"/></figure><p>What about subscriptions?</p><p>It\u2019s common to subscribe and unsubscribe from certain effects in certain apps.</p><p>Consider the following:</p><pre><code>useEffect(() =&gt; {  const clicked = () =&gt; console.log('window clicked');  window.addEventListener('click', clicked);}, [])</code></pre><p>In the effect above, upon mounting, a click event listener is attached to the window.</p><p>How do we unsubscribe from this listener when the component is unmounted?</p><p>Well, <code>useEffect</code> allows for this.</p><p>If you return a function within your effect function, it will be invoked when the component unmounts. This is the perfect place to cancel subscriptions as shown below:</p><pre><code>useEffect(() =&gt; {    const clicked = () =&gt; console.log('window clicked');    window.addEventListener('click', clicked);</code></pre><pre><code>    return () =&gt;; {      window.removeEventListener('click', clicked)    } }, [])</code></pre><p>There\u2019s a lot more you can do with the useEffect hook such as making API calls.</p><h4 id=\"build-your-own-hooks\">Build Your own Hooks</h4><p>From the start of the hooks section we\u2019ve taken (and used) candies from the candy box React provides.</p><p>However, React also provides a way for you to make your own unique candies \u2014 called custom hooks.</p><p>So, how does that work?</p><p>A custom hook is just a regular function. However, its name must begin with the word, <strong>use</strong> and if needed, it may call any of the React hooks within itself.</p><p>Below\u2019s an example:</p><h4 id=\"the-rules-of-hooks\">The Rules of Hooks</h4><p>There are two rules to adhere to while using hooks.</p><ul><li>Only Call Hooks at the <a href=\"https://reactjs.org/docs/hooks-rules.html#only-call-hooks-at-the-top-level\" rel=\"noopener\">Top Level</a> i.e. not within conditionals, loops or nested functions.</li><li>Only Call Hooks from React Functions i.e. Functional Components and Custom Hooks.</li></ul><p>This ESLint <a href=\"https://www.npmjs.com/package/eslint-plugin-react-hooks\" rel=\"noopener\">plugin</a> is great to ensure you adhere to these rules within your projects.</p><h3 id=\"advanced-hooks\">Advanced Hooks</h3><p>We have only considered two out of 10 of the hooks React provides!</p><p>What\u2019s interesting is that the knowledge of how <code>useState</code> and <code>useEffect</code> works helps you quickly learn the other hooks.</p><p>Curious to learn about those, I have created a <a href=\"https://github.com/ohansemmanuel/react-hooks-cheatsheet\" rel=\"noopener\">hooks cheatsheet</a> with live editable examples.</p><figure><img alt=\"uocYYVAXRFmr3pkFzJFxggyNp4dUcMlfr7cc\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/uocYYVAXRFmr3pkFzJFxggyNp4dUcMlfr7cc\" width=\"600\"/></figure><p>Why this is important is that you can immediately begin to tinker with real examples that\u2019ll reinforce your knowledge of how hooks work. All of them!</p><p>Remember that learning is reinforced when you actual solve problems and build stuff.</p><p>What\u2019s more interesting as well is, after you get through the live examples for each of the hooks, there\u2019s an extra section for other generic examples that don\u2019t exactly fit one hook or require a separate case study.</p><p>In the example section you\u2019ll find <a href=\"https://react-hooks-cheatsheet.com/examples/fetching-data\" rel=\"noopener\">examples</a> such as fetching data from a remote server using hooks and more.</p><figure><img alt=\"GK8XDogOdy6kbKVQ6SI9QfO2qpoNjWWYa3oU\" height=\"392\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/GK8XDogOdy6kbKVQ6SI9QfO2qpoNjWWYa3oU\" width=\"800\"/><figcaption>Live example from the cheatsheet.</figcaption></figure><p>Go, <a href=\"https://github.com/ohansemmanuel/react-hooks-cheatsheet\" rel=\"noopener\">check it out</a>.</p><h3 id=\"chapter-8-advanced-react-patterns-with-hooks\">Chapter 8: Advanced React Patterns with Hooks</h3><figure><img alt=\"WXlCQiqH7AWqwhgBWCKZuIQ6UXT-v3h-IjRO\" height=\"409\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/WXlCQiqH7AWqwhgBWCKZuIQ6UXT-v3h-IjRO\" width=\"800\"/></figure><p>With the release of hooks, certain React patterns have gone out of favour. They can still used, but for most use cases you\u2019re likely better off using hooks. For example, choose hooks over render props or higher order components.</p><p>There may be specific use cases where these could still be used, but most of the times, choose hooks.</p><p>That being said, we will now consider some more advanced React patterns implemented with hooks.</p><h4 id=\"introduction\">Introduction</h4><p>This chapter may be the longest in the book, and for good reason. Hooks are likely the way we\u2019ll be writing React components in the next couple of years, and so they are quite important.</p><p>In this chapter, we\u2019ll consider the following advanced React patterns:</p><ul><li>Compound Components</li><li>Props Collection</li><li>Prop Getters</li><li>State Initializers</li><li>State Reducer</li><li>Control Props</li></ul><p>If you\u2019re completely new to these advanced patterns, don\u2019t worry, I\u2019ll explain them in detail. If you\u2019re familiar with how these patterns work from previous experiences with class components, I\u2019ll show you how to use these patterns with hooks.</p><p>Now, let\u2019s get started.</p><h4 id=\"why-advanced-patterns\">Why Advanced Patterns?</h4><p>John\u2019s had a fairly good career. Today, he\u2019s a senior frontend engineer at <em>ReactCorp</em>. A great startup changing the world for good.</p><p><em>ReactCorp</em> is beginning to scale their workforce. A lot of engineers are being hired and John\u2019s beginning to work on building reusable components for the entire team of engineers.</p><figure><img alt=\"UndCKKEAhJKf7KUa3Ulf9CmeY7szLAiejuzX\" height=\"505\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/UndCKKEAhJKf7KUa3Ulf9CmeY7szLAiejuzX\" width=\"800\"/></figure><p>Yes, John can build components with his current React skills, however, with building highly reusable components comes specific problems.</p><p>There\u2019s a million different ways the components can be consumed, and you want to give consumers of the component as much flexibility as possible.</p><p>They must be able to extend the functionality and styles of the component as they deem fit.</p><p>The advanced patterns we\u2019ll consider here are tested and tried methods for building very reusable components that don\u2019t cripple flexibility.</p><p>I didn\u2019t create these advanced patterns. Truth be told, most of the advanced React patterns were made popular by one guy, <a href=\"https://kentcdodds.com/\" rel=\"noopener\">Kent Dodds</a> \u2014 an amazing Javascript engineer.</p><p>The community has received these patterns extremely well, and I\u2019m here to help you understand how they work!</p><h4 id=\"compound-components-pattern\">Compound Components Pattern</h4><p>The first pattern we will consider is called the Compound Components pattern. I know it sounds fancy, so I\u2019ll explain what it really means.</p><p>The keyword in the pattern name is the word <em>Compound</em>.</p><p>Literarily, the word <em>compound</em> refers to something that is composed of two or more separate elements.</p><p>With respect to React components, this could mean a component that is composed of two or more separate components.</p><p>It doesn\u2019t end there.</p><p>Any React component can be composed of 2 or more separate components. So, that\u2019s really not a brilliant way to describe compound components.</p><p>With compound components, there\u2019s more. The separate components within which the main component is composed cannot really be used without the parent.</p><figure><img alt=\"oZ7CY7vfHkIbqMLOGtI5DpdPBRWgnP7tGy3J\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/oZ7CY7vfHkIbqMLOGtI5DpdPBRWgnP7tGy3J\" width=\"600\"/><figcaption>compound components</figcaption></figure><p>The main component is usually called the parent, and the separate composed components, children.</p><p>The classic example is to consider the <code>html</code> select element.</p><pre><code>&lt;select&gt;  &lt;option value=\"value0\"&gt;key0&lt;/option&gt;  &lt;option value=\"value1\"&gt;key1&lt;/option&gt;  &lt;option value=\"value2\"&gt;key2&lt;/option&gt;&lt;/select&gt;</code></pre><p>With <code>select</code> being the parent, and the many <code>option</code> elements, children.</p><p>This works like a compound component. For one, it really makes no sense to use the <code>&lt;option&gt;key0&lt;</code>;/option&gt; elemen<code>t with</code>out a select parent tag. The overall beh<code>aviour</code> of a select element also relies on having the<code>se com</code>posed option elements as well.</p><p>They are so connected to one another.</p><p>Also, the state of the entire component is managed by <code>select</code> with all child elements dependent on that state.</p><p>Do you get a sense for what compound components are now?</p><p>It is also worth mentioning that compound components are just one of many ways to express the API for your components.</p><p>For example, while it doesn\u2019t look as good, the <code>select</code> element could have been designed to work like this:</p><pre><code>&lt;select options=\"key:value;anotherKey:anotherValue\"&gt;&lt;;/select&gt;</code></pre><p>This is definitely not the best way to express this API. It make passing attributes to the child components almost impossible.</p><p>With that in mind, let\u2019s take a look at an example that\u2019ll help you understand and build your own compound components.</p><h4 id=\"example-building-an-expandable-component-\">Example: Building an Expandable Component.</h4><figure><img alt=\"LSHe4laueTj0qrz7WZcIkNqQfI1txaaszPxo\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/LSHe4laueTj0qrz7WZcIkNqQfI1txaaszPxo\" width=\"600\"/><figcaption>The final component being used</figcaption></figure><p>We\u2019ll be building an <code>Expandable</code> component. Did you ask what that means?</p><p>Well, consider an <code>Expandable</code> component to be a miniature accordion element. It has a clickable header, which toggles the display of an associated body of content.</p><p>In the unexpanded state the component would look like this:</p><figure><img alt=\"xkCEtYIIkTQO0s-imNADZ8tX5ceLMV-zKpdq\" height=\"147\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/xkCEtYIIkTQO0s-imNADZ8tX5ceLMV-zKpdq\" width=\"800\"/></figure><p>And this, when expanded:</p><figure><img alt=\"NdybUeg-Rye1gyZ7yuDYcmREl2hPDflkQxi7\" height=\"448\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/NdybUeg-Rye1gyZ7yuDYcmREl2hPDflkQxi7\" width=\"800\"/></figure><p>You get the idea, right?</p><h4 id=\"designing-the-api\">Designing the API</h4><p>It\u2019s usually a good idea to write out what the exposed API of your component would look like before building it out.</p><p>In this case, here\u2019s what we\u2019re going for:</p><pre><code>&lt;Expandable&gt;\t&lt;Expandable.Header&gt; Header &lt;/Expandable.Header&gt; \t&lt;Expandable.Icon/&gt;    &lt;Expandable.Body&gt; This is the content &amp;lt;/Expandable.Body&gt;&lt;/Expandable&gt;</code></pre><figure><img alt=\"gsi8CWO9uvmAh4m33n-MsQTeHS5owZfFezsM\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/gsi8CWO9uvmAh4m33n-MsQTeHS5owZfFezsM\" width=\"600\"/></figure><figure><img alt=\"EbOV-Qb3ZrK2t87zC9sLtAvq5oWQCLkycWDX\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/EbOV-Qb3ZrK2t87zC9sLtAvq5oWQCLkycWDX\" width=\"600\"/><figcaption>A break down of the child components</figcaption></figure><p>In the code block above you\u2019d have noticed I have expressions like this: <code>Expandable.Header</code></p><p>You could as well do this:</p><pre><code>&lt;Expandable&gt;\t&lt;Header&gt; Header &lt;/Expandable.Header&gt; \t&lt;Icon/&gt;    &lt;Body&gt; This is the content &lt;/Body&gt;&lt;/Expandable&gt;</code></pre><p>It doesn\u2019t matter. I have chosen <code>Expandable.Header</code> over <code>Header</code> as a matter of personal preference. I find that it communicates dependency on the parent component well, but that\u2019s just my preference. A lot of people don\u2019t share the same preference and that\u2019s perfectly fine.</p><p>It\u2019s your component, use whatever API looks good to you :)</p><h4 id=\"building-the-expandable-component\">Building the Expandable Component</h4><p>The <code>Expandable</code> component being the parent component will keep track of state, and It will do this via a boolean variable called <code>expanded</code>.</p><pre><code>// state {  expanded: true || false}</code></pre><p>The <code>Expandable</code> component needs to communicate the state to every child component regardless of their position in the nested component tree.</p><p>Remember that the children are dependent on the parent compound component for state.</p><p>How best may we go about this?</p><p>If you said <code>context</code>, you\u2019re correct!</p><p>We need to create a <code>context</code> object to hold the component state, and expose the <code>expanded</code> property via the <code>Provider</code> component. Alongside the <code>expanded</code> property, we will also expose a function callback to toggle the value of this <code>expanded</code> state property.</p><figure><img alt=\"Ga1KnN7jSDEPUsyceXFVi4mqGwYjr4fOG1Yz\" height=\"505\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/Ga1KnN7jSDEPUsyceXFVi4mqGwYjr4fOG1Yz\" width=\"800\"/><figcaption>the state relationship for the expandable component</figcaption></figure><p>If that sounds alright to you, here\u2019s the starting point for the <code>Expandable</code> component.</p><pre><code>// Expandable.js import React, { createContext } from 'react'</code></pre><pre><code>const ExpandableContext = createContext()const { Provider } = ExpandableContext</code></pre><pre><code>const Expandable = ({children}) =&gt; {  return &lt;Provider&gt;{children}&lt;/Provider&gt;}export default Expandable</code></pre><p>There\u2019s nothing spectacular going on in the code block above.</p><p>A context object is created and the <code>Provider</code> component deconstructed. Then we go on to create the <code>Expandable</code> component which renders the <code>Provider</code> and any <code>children</code>.</p><p>Got that?</p><p>With the basic setup out of the way, let\u2019s do a little more.</p><p>The context object was created with no initial value. However, we need the <code>Provider</code> to expose the state value <code>expanded</code> and a toggle function to update the state.</p><p>Let\u2019s create the <code>expanded</code> state value using <code>useState</code>.</p><pre><code>// Expandable.js </code></pre><pre><code>import React, { createContext, useState } from 'react'...const Expandable = ({children}) =&gt; {  // look here ?  const [expanded, setExpanded] = useState(false) </code></pre><pre><code>  return &lt;Provider&gt;{children}&lt;/Provider&gt;}</code></pre><p>With the <code>expanded</code> state variable created, let\u2019s create the <code>toggle</code> updater function to toggle the value of <code>expanded</code> \u2014 whether <code>true</code> or <code>false</code>.</p><pre><code>// Expandable.js ...const Expandable = ({children}) =&gt; {  const [expanded, setExpanded] = useState(false)  // look here ?  const toggle = setExpanded(prevExpanded =&gt; !prevExpanded) </code></pre><pre><code>  return &lt;Provider&gt;{children}&lt;/Provider&gt;}</code></pre><p>The <code>toggle</code> function invokes <code>setExpanded</code>, the actual updater function returned from the <code>useState</code> call.</p><p>Every updater function from the <code>useState</code> call can receive a function argument. This is similar to how you pass a function to <code>setState</code> e.g. <code>setState(prevState =&gt; !prevState.val</code>ue).</p><p>This is the same thing I\u2019ve done above. The function passed to <code>setExpanded</code> receives the previous value of <code>expanded</code> and returns the opposite of that, <code>!expanded</code></p><p><code>toggle</code> acts as a callback function and It\u2019ll eventually be invoked by <code>Expandable.Header</code>. Let\u2019s prevent any future performance issue by memoizing the callback.</p><pre><code>... import { useCallback } from 'react';</code></pre><pre><code>const Expandable = ({children}) =&gt; {  const [expanded, setExpanded] = useState(false)  // look here ?  const toggle = useCallback(    () =&gt; setExpanded(prevExpanded =&gt; !prevExpanded),    []  ))return &lt;Provider&gt;{children}&lt;/Provider&gt; </code></pre><p>Not sure how <code>useCallback</code> works? You probably skipped the previous advanced hooks section that pointed to the cheatsheet. <a href=\"https://react-hooks-cheatsheet.com/usecallback\" rel=\"noopener\">Have a look</a>.</p><p>Once we have both <code>expanded</code> and <code>toggle</code> created, we can expose these via the <code>Provider</code>\u2019s value prop.</p><pre><code>...const Expandable = ({children}) =&gt; {  const [expanded, setExpanded] = useState(false)  const toggle = useCallback(    () =&gt; setExpanded(prevExpanded =&gt; !prevExpanded),    []  )   // look here ?  const value = { expanded, toggle }   // and here ?  return &lt;;Provider value={value}&gt;{children}&lt;/Provider&gt;}  </code></pre><p>This works, but the <code>value</code> reference will be different on every re-render causing the <code>Provider</code> to re-render its children.</p><p>Let\u2019s memoize the <code>value</code>.</p><pre><code>...const Expandable = ({children}) =&gt; {  ... // look here ?  const value = useMemo(\t() =&gt; ({ expanded, toggle }), \t[expanded, toggle]  )  return &lt;Provider value={value}&gt;{children}&amp;lt;/Provider&gt;} </code></pre><p><code>useMemo</code> takes a callback that returns the object value <code>{ expanded, toggle }</code> and we pass an array dependency <code>[expanded, toggle]</code> so that the memoized value remains the same unless those change.</p><p>We\u2019ve done a great job so far!</p><p>Now, there\u2019s just one other thing to do on the <code>Expandable</code> parent component.</p><p>If you remember from a previous experience with class components, it\u2019s possible to do this:</p><pre><code>this.setState({  name: \"value\"}, () =&gt; {  this.props.onStateChange(this.state.name)})</code></pre><p>This is how you trigger a callback after a state change in class components.</p><p>Usually, the callback e.g. <code>this.props.onStateChange</code> is always invoked with the current value of the updated state as shown below:</p><pre><code>this.props.onStateChange(this.state.name)</code></pre><p>Why is this important?</p><p>This is good practice when creating reusable components, because this way the consumer of your component can attach any custom logic to be run after a state update.</p><p>For example:</p><pre><code>const doSomethingPersonal = ({expanded}) =&gt; {  // do something really important after being expanded}</code></pre><pre><code>&lt;Expandable onExpanded={doSomethingPersonal}&gt; ... &lt;/Expandable&gt;</code></pre><p>We will add this functionality to the <code>Expanded</code> component.</p><p>With class components this is pretty much straightforward. With functional components, we need to do a little more work \u2014 not so much :)</p><p>Whenever you want to perform a side effect within a functional component, for most cases, always reach out for <code>useEffect</code>.</p><p>So, the easiest solution might look like this:</p><pre><code>useEffect(() =&gt; {  props.onExpanded(expanded)}, [expanded])</code></pre><p>The problem however with this is that the <code>useEffect</code> effect function is called at least once \u2014 when the component is initially mounted.</p><p>So, even though there\u2019s a dependency array, <code>[expanded]</code>, the callback will also be invoked when the component mounts!</p><pre><code>useEffect(() =&gt; {  // this function will always be invoked on mount})</code></pre><p>The functionality we seek requires that the callback to be passed by the user isn\u2019t invoked on mount.</p><p>How can we enforce this?</p><p>First, consider the naive solution below:</p><pre><code>//faulty solution... let componentJustMounted = trueuseEffect(    () =&gt; {        if(!componentJustMounted) {        props.onExpand(expanded)        componentJustMounted = false      }    },    [expanded]  )...</code></pre><p>What\u2019s wrong with the code above?</p><p>Loosely speaking, the thinking behind the code is correct. You keep track of a certain variable <code>componentJustMounted</code> and set it to <code>true</code>, and only call the user callback <code>onExpand</code> when <code>componentJustMounted</code> is false.</p><p>The <code>componentJustMounted</code> value is only set to <code>false</code> after the user callback has been invoked at least once.</p><p>Looks good.</p><p>However, the problem with this is that whenever the function component re-renders owing to a state or prop change, the <code>componentJustMounted</code> value will always be reset to <code>true</code>. Thus, the user callback <code>onExpand</code> will never be invoked as it is only invoked when <code>componentJustMounted</code> is falsey.</p><pre><code>...if (!componentJustMounted) {    \tonExpand(expanded)}...</code></pre><p>Well, the solution to this is simple. We can use the <code>useRef</code> hook to ensure that a value stays the same all through lifetime of the component.</p><p>Here\u2019s how it works:</p><pre><code>//correct implementation  const componentJustMounted = useRef(true)  useEffect(    () =&gt; {      if (!componentJustMounted.current) {        onExpand(expanded)      }      componentJustMounted.current = false    },    [expanded]  )</code></pre><p><code>useRef</code> returns a <code>ref</code> object and the value stored in the object may be retrieved from <code>ref.current</code></p><p>The signature for <code>useRef</code> looks like this: <code>useRef(initialValue)</code>.</p><p>Hence, stored initially in <code>componentJustMounted.current</code> is a ref object with the <code>current</code> property set to <code>true</code>.</p><pre><code>const componentJustMounted = useRef(true)</code></pre><p>After invoking the user callback, we then update this value to <code>false</code>.</p><pre><code>componentJustMounted.current = false</code></pre><p>Now, whenever there\u2019s a state or prop change the value in the ref object isn\u2019t tampered with. It remains the same.</p><p>With the current implementation, whenever the <code>expanded</code> state value is toggled, the user callback function <code>onExpanded</code> will be invoked with the current value of <code>expanded</code>.</p><p>Here\u2019s what the final implementation of the <code>Expandable</code> component now looks like:</p><pre><code>// Expandable.js const Expandable = ({ children, onExpand }) =&gt; {  const [expanded, setExpanded] = useState(false)  const toggle = useCallback(    () =&gt; setExpanded(prevExpanded =&gt; !prevExpanded),    []  )  const componentJustMounted = useRef(true)  useEffect(    () =&gt; {      if (!componentJustMounted) {        onExpand(expanded)      }       componentJustMounted.current = false    },    [expanded]  )  const value = useMemo(   () =&gt; ({ expanded, toggle }),    [expanded, toggle]  )  return (    &lt;Provider value={value}&gt;        {children}    &lt;/Provider&gt;  )}</code></pre><p>If you\u2019ve followed along, that\u2019s great. We\u2019ve sorted out the most complex component in the bunch. Now, let\u2019s build the child components.</p><h4 id=\"building-the-compound-child-components\">Building the Compound Child Components</h4><p>There are three child components for the <code>Expandable</code> component.</p><figure><img alt=\"qCrrUqNmXLJI53uFn41uZ9VtAWvsU9Xfi14a\" height=\"448\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/qCrrUqNmXLJI53uFn41uZ9VtAWvsU9Xfi14a\" width=\"800\"/></figure><p>These child components need to consume values from the context object created in <code>Expandable.js</code>.</p><p>To make this possible, we\u2019ll do a little refactoring as shown below:</p><pre><code>export const ExpandableContext = createContext()</code></pre><p>We export the context object, <code>ExpandableContext</code> from <code>Expandable.js</code>.</p><p>Now, we may use the <code>useContext</code> hook to consume the values from the <code>Provider</code>.</p><p>Below\u2019s the <code>Header</code> child component fully implemented.</p><pre><code>//Header.jsimport React, { useContext } from 'react'import { ExpandableContext } from './Expandable'</code></pre><pre><code>const Header = ({children}) =&gt; {  const { toggle } = useContext(ExpandableContext)  return &lt;div onClick={toggle}&gt;{children}&lt;/div&gt;}export default Header</code></pre><p>Simple, huh?</p><p>It renders a <code>div</code> whose <code>onClick</code> callback is the <code>toggle</code> function for toggling the <code>expanded</code> state within the <code>Expandable</code> parent component.</p><p>Here\u2019s the implementation for the <code>Body</code> child component:</p><pre><code>// Body.jsimport { useContext } from 'react'import { ExpandableContext } from './Expandable'</code></pre><pre><code>const Body = ({ children }) =&gt; {  const { expanded } = useContext(ExpandableContext)  return expanded ? children : null}export default Body</code></pre><p>Pretty simple as well.</p><p>The <code>expanded</code> value is retrieved from the context object and used within the rendered markup. It reads like this: If expanded, render <code>children</code> else render nothing.</p><p>The <code>Icon</code> component is just as simple.</p><pre><code>// Icon.jsimport { useContext } from 'react'import { ExpandableContext } from './Expandable'</code></pre><pre><code>const Icon = () =&gt; {  const { expanded } = useContext(ExpandableContext)  return expanded ? '-' : '+'}export default Icon</code></pre><p>It renders either <code>+</code> or <code>-</code> depending on the value of <code>expanded</code> retrieved from the context object.</p><p>With all child components built, we can set the child components as <code>Expandable</code> properties. See below:</p><pre><code>import Header from './Header'import Icon from './Icon'import Body from './Body'</code></pre><pre><code>const Expandable = ({ children, onExpand }) =&gt; {\t...}</code></pre><pre><code>// Remember this is just a personal reference. It's not mandatoryExpandable.Header = HeaderExpandable.Body = BodyExpandable.Icon = Icon</code></pre><p>Now we can go ahead to use the <code>Expandable</code> component as designed:</p><pre><code>&lt;Expandable&gt;    &lt;Expandable.Header&gt;React hooks&lt;/Expandable.Header&gt;           &lt;Expandable.Icon /&gt;    &lt;Expandable.Body&gt;Hooks are awesome&amp;lt;/Expandable.Body&gt;&lt;/Expandable&gt;</code></pre><p>Does it work?</p><p>You bet!</p><p>Here\u2019s what\u2019s rendered when not expanded:</p><figure><img alt=\"D3EYhc5vHz6LzpqQkb38aAfzEF8NICFyX0J8\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/D3EYhc5vHz6LzpqQkb38aAfzEF8NICFyX0J8\" width=\"600\"/></figure><p>And when expanded:</p><figure><img alt=\"T8DJ2hZnTVMSyKFRN0t8-br-GCE5H9c-3cap\" height=\"71\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/T8DJ2hZnTVMSyKFRN0t8-br-GCE5H9c-3cap\" width=\"368\"/></figure><p>This works but it has to be the ugliest component I\u2019ve ever seen. We can do better.</p><h4 id=\"manageable-styling-for-reusable-components\">Manageable Styling for Reusable Components</h4><p>Hate it or not, styling (or CSS) is integral to how the web works.</p><p>While there\u2019s a number of ways to style a <code>React</code> component, and I\u2019m sure you have a favourite, when you build reusable components it\u2019s always a good idea to expose a frictionless API for overriding default styles.</p><p>Usually, I recommend letting it possible to have your components styleable via both <code>style</code> and <code>className</code> props.</p><p>For example:</p><pre><code>// this should work.&lt;MyComponent style={{name: \"value\"}} /&gt;// and this.&lt;MyComponent className=\"my-class-name-with-dope-styles\" /&gt;</code></pre><p>Now, our goal isn\u2019t just styling the component, but to make it as reusable as possible. This means letting whoever consumes the component style the component whichever they want i.e inline style via the <code>style</code> prop, or by passing some <code>className</code> prop.</p><p>Let\u2019s begin with the <code>Header</code> child component:</p><pre><code>// before const Header = ({children}) =&gt; {  const { toggle } = useContext(ExpandableContext)  return &lt;div onClick={toggle}&gt;{children}&lt;/div&gt;}</code></pre><p>First, let\u2019s change the rendered markup to a <code>button</code>. It\u2019s a more accessible and semantic alternative to the <code>div</code> used earlier.</p><pre><code>const Header = ({children}) =&gt; {  const { toggle } = useContext(ExpandableContext)  // look here ?  return &lt;button onClick={toggle}&gt;{children}&lt;;/button&gt;} </code></pre><p>We will now write some default styles for the <code>Header</code> component in a <code>Header.css</code> file.</p><pre><code>// Header.css.Expandable-trigger {    background: none;    color: hsl(0, 0%, 13%);    display: block;    font-size: 1rem;    font-weight: normal;    margin: 0;    padding: 1em 1.5em;    position: relative;    text-align: left;    width: 100%;    outline: none;    text-align: center;  }    .Expandable-trigger:focus,  .Expandable-trigger:hover {    background: hsl(216, 94%, 94%);  }</code></pre><p>I\u2019m sure you can figure out the simple CSS above. If not, don\u2019t stress it. What\u2019s important is to note the default <code>className</code> used here, <code>.Expandable-trigger</code></p><p>To apply these styles, we need to import the <code>CSS</code> file and apply the appropriate <code>className</code> prop to the rendered <code>button</code>.</p><pre><code>... import './Header.css'const Header = () =&gt; {  const { toggle } = useContext(ExpandableContext)  return &lt;button onClick={toggle} \t className=\"Expandable-trigger\"&gt;\t{children}&amp;lt;/button&gt;}</code></pre><p>This works great, however the <code>className</code> is set to the default string <code>Expandable-trigger</code>.</p><p>This will apply the styling we\u2019ve written in the <code>CSS</code> file, but it doesn\u2019t take into the account any <code>className</code> prop passed in by the user.</p><p>It\u2019s important to accommodate passing this <code>className</code> prop as a user might like to change the default style you\u2019ve set in your <code>CSS</code>.</p><p>Here\u2019s one way to do this:</p><pre><code>// Header.jsimport './Header.css'const Header = ({ children, className}) =&gt; {  // look here ?  const combinedClassName = `Expandable-trigger ${className}`  return (    &lt;button onClick={toggle} className={combinedClassName}&gt;      {children}    &lt;/button&gt;  )} </code></pre><p>Now, whatever <code>className</code> is passed to the <code>Header</code> component will be combined with the <code>default</code> <code>Expandable-trigger</code> before been passed on to the rendered <code>button</code> element.</p><p>Let\u2019s consider how good the current solution is.</p><p>First, if the <code>className</code> prop is <code>null</code> or <code>undefined</code>, the <code>combinedClassName</code> variable will hold the value <code>\"Expandable-trigger null\"</code> or <code>\"Expandable-trigger undefined\".</code></p><p>To prevent this, be sure to pass a <code>className</code> by using the ES6 default parameters syntax as shown below:</p><pre><code>// note how className defaults to an empty stringconst Header = ({ children, className = '' }) =&gt; {  ...}</code></pre><p>Having provided a default value, if the user still doesn\u2019t enter a <code>className</code>, the <code>combinedClassName</code> value will be equal to <code>\"Expandable-trigger \"</code>.</p><p>Note the empty string appended to the <code>Expandable-trigger</code>. This is owing to how template literals work.</p><p>My preferred solution is to do this:</p><pre><code>const combinedClassName = ['Expandable-trigger', className].join('')</code></pre><p>This solution handles the previously discussed edge cases. If you also want to explicit about removing <code>null</code>, <code>undefined</code> or any other falsey values, you can do the following:</p><pre><code>const combinedClassName = ['Expandable-trigger', className].filter(Boolean).join('')</code></pre><p>I\u2019ll stick with the simpler alternative, and providing a default for <code>className</code> via default parameters.</p><p>With that being said, here\u2019s the final implementation for <code>Header</code>:</p><pre><code>// after ...import './Header.css'const Header = ({ children, className = ''}) =&gt; {  const { toggle } = useContext(ExpandableContext)  const combinedClassName = ['Expandable-trigger', className].join('')</code></pre><pre><code>return (    &lt;button onClick={toggle} className={combinedClassName}&gt;      {children}    &lt;/button&gt;  )}</code></pre><p>So far, so good.</p><p>Incase you were wondering, <code>combinedClassName</code> returns a string. Since strings are compared by value, there\u2019s no need to memoize this value with <code>useMemo</code>.</p><p>So far, we\u2019ve graciously handled the <code>className</code> prop. How about the option to override default styles by passing a <code>style</code> prop?</p><p>Well, let\u2019s fix that.</p><p>Instead of explicitly destructuring the <code>style</code> prop, we can pass on any other prop passed by the user to the <code>button</code> component.</p><pre><code>// rest paramter ...otherProps ?const Header = ({ children, className = '', ...otherProps }) =&gt; {\treturn (    // spread syntax {...otherProps} ?    &lt;button {...otherProps}&gt;      {children}    &lt;/button&gt;  )}  </code></pre><p>Note the use of the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters\" rel=\"noopener\">rest parameter</a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\" rel=\"noopener\">spread syntax</a>.</p><p>With this done, the <code>Header</code> component receives our default styles, yet allows for change via the <code>className</code> or <code>style</code> props.</p><pre><code>// override style via className&lt;Expandable.Header className=\"my-class\"&gt;\tReact hooks&lt;/Expandable.Header&gt;</code></pre><pre><code>// override style via style prop&lt;Expandable.Header style={{color: \"red\"}}&gt;\tReact hooks&lt;/Expandable.Header&gt;</code></pre><p>Now, I\u2019ll go ahead and do the same for the other child components, <code>Body</code> and <code>Icon</code>.</p><pre><code>// before const Body = ({ children }) =&gt; {  const { expanded } = useContext(ExpandableContext)  return expanded ? children : null}</code></pre><pre><code>// after import './Body.css'const Body = ({ children, className = '', ...otherProps }) =&gt; {  const { expanded } = useContext(ExpandableContext)  const combinedClassNames = ['Expandable-panel', className].join('')</code></pre><pre><code>  return expanded ? (    &lt;div className={combinedClassNames} {...otherProps}&gt;      {children}    &lt;/div&gt;  ) : null}</code></pre><pre><code>// Body.css.Expandable-panel {    margin: 0;    padding: 1em 1.5em;    border: 1px solid hsl(216, 94%, 94%);;    min-height: 150px;  }</code></pre><p>Do the same for <code>Icon</code> component:</p><pre><code>// before const Icon = () =&gt; {  const { expanded } = useContext(ExpandableContext)  return expanded ? '-' : '+'}</code></pre><pre><code>// after ...import './Icon.css'const Icon = ({ className = '', ...otherProps }) =&gt; {  ...  const combinedClassNames = ['Expandable-icon', className].join('')</code></pre><pre><code>  return (    &lt;span className={combinedClassNames} {...otherProps}&gt;      {expanded ? '-' : '+'}    &lt;/span&gt;  )}</code></pre><pre><code>// Icon.css.Expandable-icon {    position: absolute;    top: 16px;    right: 10px;}</code></pre><p>And finally, some styles for the parent component, <code>Expandable</code>.</p><pre><code>import './Expandable.css'const Expandable = ({ children, onExpand, className = '', ...otherProps }) =&gt; {   ...   const combinedClassNames = ['Expandable', className].join('')  return (    &lt;Provider value={value}&gt;      &lt;div className={combinedClassNames} {...otherProps}&gt;        {children}      &lt;/div&gt;    &lt;/Provider&gt;  )}</code></pre><pre><code>// Expandable.css.Expandable {     position: relative;     width: 350px;}</code></pre><p>Now we\u2019ve got a beautiful reusable component!</p><figure><img alt=\"hrQd5NnJyljpaXrRKyja27D9zUWhMmNjD2j4\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/hrQd5NnJyljpaXrRKyja27D9zUWhMmNjD2j4\" width=\"600\"/></figure><figure><img alt=\"rKVwrothDrwalJqh04muFzOpFIzL98Yqjvk2\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/rKVwrothDrwalJqh04muFzOpFIzL98Yqjvk2\" width=\"600\"/></figure><p>We\u2019ve not just made it beautiful, but it\u2019s customisable as well.</p><p>How customisable is the component we\u2019ve built?</p><p>See what I\u2019ve done below with the same component!</p><figure><img alt=\"vrUIQnYihcnlrQftUj6lXhen7LBVO3HJijr1\" height=\"107\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/vrUIQnYihcnlrQftUj6lXhen7LBVO3HJijr1\" width=\"443\"/></figure><figure><img alt=\"n04wsdnMMD-qykRyopr-JcQq1stOiNUhqdQj\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/n04wsdnMMD-qykRyopr-JcQq1stOiNUhqdQj\" width=\"600\"/></figure><p>And this didn\u2019t take a lot of code.</p><pre><code>&lt;Expandable&gt;    &lt;Expandable.Header&gt;Reintroducing React&lt;/Expandable.Header&gt;    &lt;Expandable.Icon /&gt;    &lt;Expandable.Body&gt;     \t&lt;img            src='https://i.imgur.com/qpj4Y7N.png'            style={{ width: '250px' }}            alt='reintroducing react book cover'        /&gt;        &lt;p style={{ opacity: 0.7 }}&gt;          This book is so f*cking amazing! &lt;br /&gt;        &lt;a          href='https://leanpub.com/reintroducing-react'          target='_blank'          rel='noopener noreferrer'          &gt;            Go get it now.        &lt;/a&gt;       &lt;/p&gt;     &lt;/Expandable.Body&gt;&lt;/Expandable&gt;</code></pre><p>You can go one step further to test if overriding styles via the <code>style</code> prop works as well.</p><pre><code>&lt;Expandable&gt;   &lt;Expandable.Header       // look here ?\t  style={{ color: 'red', border: '1px solid teal' }}&gt;        Reintroducing React    &lt;/Expandable.Header&gt;        ...&lt;/Expandable&gt; </code></pre><p>And below\u2019s the result of that:</p><figure><img alt=\"dg50ZCANWn3YXiFdxq1kX0-KFwYDLuyhEgF-\" height=\"586\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/dg50ZCANWn3YXiFdxq1kX0-KFwYDLuyhEgF-\" width=\"687\"/><figcaption>Default Header styles override with the style prop.</figcaption></figure><p>Yay! it works as expected.</p><p><strong>Note</strong>: I have covered 5 other advanced component patterns with Hooks <a href=\"https://leanpub.com/reintroducing-react\" rel=\"noopener\">in the ebook </a>(PDF, Epub and Mobi). <strong>You can get it completely free </strong>(or pay whatever you want if you like my work).</p><figure><img alt=\"P8npt6FWcQTqVRfBE4oJ0mseFztCZ-Fod0lt\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/P8npt6FWcQTqVRfBE4oJ0mseFztCZ-Fod0lt\" width=\"600\"/><figcaption><a href=\"https://leanpub.com/reintroducing-react\" rel=\"noopener\" target=\"_blank\" title=\"\">https://leanpub.com/reintroducing-react</a></figcaption></figure><h3 id=\"conclusion-2\">Conclusion</h3><p>This has been a lengthy discourse on the modern changes in React. If you don\u2019t get all of it yet, spend a little more time practising the examples in your day to day work, and I\u2019m pretty sure you\u2019ll get a hang of it real quick.</p><p>When you do, go be the React engineer with a decent understanding of Modern React and go build highly reusable components with advanced hook patterns.</p><p>Thank you for following me on this journey. Got questions? Use the comment section!</p>\n</section><p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p></div></article>", "textContent": "\n                            \nIn this article (and accompanying book), unlike any you may have come across before, I will deliver funny, unfeigned and dead serious comic strips about every React update since v16+. It\u2019ll be hilarious, either intentionally or unintentionally, easy on beginners as well as professionals, and will be very informative as a whole.Why Comic Strips ?I have been writing software for over 5 years. But I have done other things, too. I\u2019ve been a graphics designer, a published author, teacher, and a long, long time ago, an amateur Illustrator.I love the tech community, but sometimes as a group, we tend to be a little narrow-minded.When people attempt to teach new technical concepts, they forget who they were before they became developers and just churn out a lot of technical jargon \u2014 like other developers they\u2019ve seen.When you get to know people, it turns out so many of us have different diverse backgrounds! \u201cIf you were a comedian, why not explain technical concepts with some comedy?Wouldn\u2019t that be so cool?I want to show how we can become better as engineers, as teams, and as a community, by openly being our full, weird selves, and teaching others with all that personality. But instead of just talking, I want to make it noteworthy and lead by example. So, you\u2019re welcome to my rendition of a comic strip inspired book about every React update since v16.With recently released v16.8 features, there\u2019s going to be a lot of informative comic strips to be delivered!Inspired by Jani Ev\u00e4kallio.This is a very interesting but long read. Please download the ebook (PDF, Epub & Mobi) absolutely free \u2014 without having to share your email with me. You can also pay whatever you want for the book if you wanna support my work.How to Read this ArticleFirst, get the ebook. Apart from being able to read offline, the ebooks have syntax highlighted codes that make them easier to read as well. Go get it.https://leanpub.com/reintroducing-reactSecondly, please find the associated code repository for the book on Github. This will help you follow along with the examples allowing for more hands-on practice.Why Reintroduce React?I wrote my first React application 3 to 4 years ago. Between then and now, the fundamental principles of React have remained the same. React is just as declarative and component-based today as it was then.That\u2019s great news, however, the way we write React applications today has changed!There\u2019s been a lot of new additions (and well, removals).If you learned React a while back it\u2019s not impossible that you haven\u2019t been up to date with every new feature/release. It\u2019s also possible to get lost on all the new features. Where exactly do you start? How important are they for your day to day use?Even as an experienced engineer, I sometimes find unlearning old concepts and relearning new ones just as intimidating as learning a new concept from the scratch.If that\u2019s the case with you, I hope I can provide the right help for you via this guide.The same applies if you\u2019re just learning React.There\u2019s a lot of state information out there. If you learn React with some old resource, yes, you\u2019ll learn the fundamentals of React, but modern React has new interesting features that are worth your attention. It\u2019s best to know those now, and not have to unlearn and relearn newer concepts.Whether you\u2019ve been writing React for a while, or new to developing React applications, I will be discussing every update to React since version 16.This will keep you in sync with the recent changes to React, and help you write better software.Remember, a reintroduction to React is important for not just beginners, but professionals alike. It all depends on how well you\u2019ve kept your ear to the ground, and really studied the many changes that have been released over the last 12 months.On the bright side, I\u2019m bringing you a one-stop reference to all the changes.In this book, I\u2019ll take you on a journey \u2014 alongside some humour and unique content to follow.Ready?What\u2019s Changed since version 16?If you think not much has changed, think again.Here\u2019s a list of the relevant changes we\u2019ll be discussing in this guide:New Lifecycle Methods.Simpler State Management with the Context API.ContextType \u2014 Using Context without a Consumer.The Profiler: Using Charts and Interactions.Lazy Loading with React.Lazy and Suspense.Functional PureComponent with React.memoSimplifying React apps with Hooks!Advanced React Component Patterns with Hooks.It goes without saying that a lot has been introduced since version 16. For ease, each of these topics have been broken down into separate sections.In the next section I\u2019ll begin to discuss these changes by having a look at the new lifecycle methods available from version 16.Chapter 1: New Lifecycle Methods.He\u2019s been writing software for a while, but new to the React ecosystem.Meet John.For a long time he didn\u2019t fully understand what lifecycle truly meant in the context of React apps.When you think of lifecycle what comes to mind?What\u2019s Lifecycle Anyway?Well, consider humans.The typical lifecycle for a human is something like, \u201cchild\u201d to \u201cadult\u201d to \u201celderly\u201d.In the biological sense, lifecycle refers to the series of \u201cchanges in form\u201d an organism undergoes.The same applies to React components. They undergo a series of \u201cchanges in form\u201d.Here\u2019s what a simple graphical representation for React components would be.The four essential phases or lifecycle attributed to a React component include:Mounting \u2014 like the birth of a child, at this phase the component is created (your code, and react\u2019s internals) then inserted into the DOMUpdating \u2014 like humans \u201cgrow\u201d, in this phase a React component undergoes growth by being updated via changes in props or state.Unmounting \u2014 Like the death of a human, this is the phase the component is removed from the DOM.Error Handling \u2014 Think of this as being comparable to when humans fall sick and visit the doctor. Sometimes your code doesn\u2019t run or there\u2019s a bug somewhere. When this happens, the component is in the error handling phase. I intentionally skipped this phase in the illustration earlier.Lifecycle Methods.Now that you understand what lifecycle means, what are \u201clifecycle methods\u201d?Knowing the phases /lifecycle a React component goes through is one part of the equation. The other part is understanding the methods React makes available (or invokes) at each phase.The methods invoked during different phase/lifecycle of a component is what\u2019s popularly known as the component lifecycle methods e.g. In the mounting and updating phases, the render lifecycle method is always invoked.There are lifecycle methods available on all 4 phases of a component \u2014 mounting, updating, unmounting and error handling.Knowing when a lifecycle method is invoked (i.e the associated lifecycle/phase) means you can go ahead to write related logic within the method and know it\u2019ll be invoked at the right time.With the basics out of the way, let\u2019s have a look at the actual new lifecycle methods available from version 16.static getDerivedStateFromProps.Before explaining how this lifecycle method works, let me show you how the method is used.The basic structure looks like this:const MyComponent extends React.Component {  ...   static getDerivedStateFromProps() {     //do stuff here  }  }The method takes in props and state:...   static getDerivedStateFromProps(props, state) {\t//do stuff here  }  ...And you can either return an object to update the state of the component:...   static getDerivedStateFromProps(props, state) {      return {     \tpoints: 200 // update state with this     }  }    ...Or return null to make no updates:...   static getDerivedStateFromProps(props, state) {    return null  }  ...I know what you\u2019re thinking. Why exactly is this lifecycle method important?Well, it is one of the rarely used lifecycle methods, but it comes in handy in certain scenarios.Firstly, this method is called (or invoked) before the component is rendered to the DOM on initial mount.Below\u2019s a quick example.Consider a simple component that renders the number of points scored by a football team.As you may have expected, the number of points is stored in the component state object:class App extends Component {  state = {    points: 10  }  render() {    return (      <div className=\"App\">        <header className=\"App-header\">          <img src={logo} className=\"App-logo\" alt=\"logo\" />          <p>            You've scored {this.state.points} points.          </p>        </header>      </div>    );  }}Note that the text reads, you have scored 10 points \u2014 where 10 is the number of points in the state object.Just an as an example, if you put in the static getDerivedStateFromProps method as shown below, what number of points will be rendered?class App extends Component {  state = {    points: 10  }\t  // *******  //  NB: Not the recommended way to use this method. Just an example. Unconditionally overriding state here is generally considered a bad idea  // ********  static getDerivedStateFromProps(props, state) {    return {      points: 1000    }  }  render() {    return (      <div className=\"App\">        <header className=\"App-header\">          <img src={logo} className=\"App-logo\" alt=\"logo\" />          <p>            You've scored {this.state.points} points.          </p>        </header>      </div>    );  }}Right now, we have the static getDerivedStateFromProps component lifecycle method in there. If you remember from the previous explanation, this method is called before the component is mounted to the DOM. By returning an object, we update the state of the component before it is even rendered.And here\u2019s what we get:With the 1000 coming from updating state within the static getDerivedStateFromProps method.Well, this example is contrived, and not really the way you\u2019d use the static getDerivedStateFromProps method. I just wanted to make sure you understood the basics first.With this lifecycle method, just because you can update state doesn\u2019t mean you should go ahead and do this. There are specific use cases for the static getDerivedStateFromProps method, or you\u2019ll be solving a problem with the wrong tool.So when should you use the static getDerivedStateFromProps lifecycle method?The method name getDerivedStateFromProps comprises five different words, \u201cGet Derived State From Props\u201d.Also, component state in this manner is referred to as Derived State.As a rule of thumb, derived state should be used sparingly as you can introduce subtle bugs into your application if you aren\u2019t sure of what you\u2019re doing.getSnapshotBeforeUpdate.In the updating component phase, right after the render method is called, the getSnapshotBeforeUpdate lifecycle method is called next.This one is a little tricky, but I\u2019ll take my time to explain how it works.Chances are you may not always reach out for this lifecycle method, but it may come in handy in certain special cases. Specifically when you need to grab some information from the DOM (and potentially change it) just after an update is made.Here\u2019s the important thing. The value queried from the DOM in getSnapshotBeforeUpdate will refer to the value just before the DOM is updated. Even though the render method was previously called.An analogy that may help has to do with how you use version control systems such as git.A basic example is that you write code, and stage your changes before pushing to the repo.In this case, assume the render function was called to stage your changes before actually pushing to the DOM. So, before the actual DOM update, information retrieved from getSnapshotBeforeUpdate refers to those before the actual visual DOM update.Actual updates to the DOM may be asynchronous, but the getSnapshotBeforeUpdate lifecycle method will always be called immediately before the DOM is updated.Don\u2019t worry if you don\u2019t get it yet. I have an example for you.The implementation of the chat pane is as simple as you may have imagined. Within the App component is an unordered list with a Chats component:<ul className=\"chat-thread\">    <Chats chatList={this.state.chatList} /> </ul>The Chats component renders the list of chats, and for this, it needs a chatList prop. This is basically an Array. In this case, an array of 3 string values, \"Hey\", \"Hello\", \"Hi\".The Chats component has a simple implementation as follows:class Chats extends Component {  render() {    return (      <React.Fragment>        {this.props.chatList.map((chat, i) => (          <li key={i} className=\"chat-bubble\">            {chat}          </li>        ))}      </React.Fragment>    );  }}It just maps through the chatList prop and renders a list item which is in turn styled to look like a chat bubble :).There\u2019s one more thing though. Within the chat pane header is an \u201cAdd Chat\u201d button.Clicking this button will add a new chat text, \u201cHello\u201d, to the list of rendered messages.Here\u2019s that in action:Adding new chat messagesThe problem here, as with most chat applications, is that whenever the number of chat messages exceeds the available height of the chat window, the expected behaviour is to auto scroll down the chat pane so that the latest chat message is visible. That\u2019s not the case now.I have to scroll manually to find the most recent messageLet\u2019s see how we may solve this using the getSnapshotBeforeUpdate lifecycle method.The way the getSnapshotBeforeUpdate lifecycle method works is that when it is invoked, it gets passed the previous props and state as arguments.So we can use the prevProps and prevState parameters as shown below:getSnapshotBeforeUpdate(prevProps, prevState) {   }Within this method, you\u2019re expected to either return a value or null:getSnapshotBeforeUpdate(prevProps, prevState) {   return value || null // where 'value' is a  valid JavaScript value    }Whatever value is returned here is then passed on to another lifecycle method. You\u2019ll get to see what I mean soon.The getSnapshotBeforeUpdate lifecycle method doesn't work on its own. It is meant to be used in conjunction with the componentDidUpdate lifecycle method.Whatever value is returned from the getSnapshotBeforeUpdate lifecycle method is passed as the third argument to the componentDidUpdate method.Let\u2019s call the returned value from getSnapshotBeforeUpdate, snapshot, and here's what we get thereafter:componentDidUpdate(prevProps, prevState, snapshot) { }The componentDidUpdate lifecycle method is invoked after the getSnapshotBeforeUpdate is invoked. As with the getSnapshotBeforeUpdate method it receives the previous props and state as arguments. It also receives the returned value from getSnapshotBeforeUpdate as final argument.Here\u2019s all the code required to maintain the scroll position within the chat pane:getSnapshotBeforeUpdate(prevProps, prevState) {    if (this.state.chatList > prevState.chatList) {      const chatThreadRef = this.chatThreadRef.current;      return chatThreadRef.scrollHeight - chatThreadRef.scrollTop;    }    return null;  }  componentDidUpdate(prevProps, prevState, snapshot) {    if (snapshot !== null) {      const chatThreadRef = this.chatThreadRef.current;      chatThreadRef.scrollTop = chatThreadRef.scrollHeight - snapshot;    }  }Let me explain what\u2019s going on there.Below\u2019s the chat window:The full chat windowHowever, the graphic below highlights the actual region that holds the chat messages (the unordered list, ul which houses the messages).The actual region holding the chat messagesIt is this ul we hold a reference to using a React Ref:<ul className=\"chat-thread\" ref={this.chatThreadRef}>   ...</ul>First off, because getSnapshotBeforeUpdate may be triggered for updates via any number of props or even a state update, we wrap to code in a conditional that checks if there\u2019s indeed a new chat message:getSnapshotBeforeUpdate(prevProps, prevState) {    if (this.state.chatList > prevState.chatList) {      // write logic here    }  }The getSnapshotBeforeUpdate method above has to return a value yet. If no chat message was added, we will just return null:getSnapshotBeforeUpdate(prevProps, prevState) {    if (this.state.chatList > prevState.chatList) {      // write logic here    }      return null }Now consider the full code for the getSnapshotBeforeUpdate method:getSnapshotBeforeUpdate(prevProps, prevState) {    if (this.state.chatList > prevState.chatList) {      const chatThreadRef = this.chatThreadRef.current;      return chatThreadRef.scrollHeight - chatThreadRef.scrollTop;    }    return null;  }Does it make sense to you?Not yet, I suppose.First, consider a situation where the entire height of all chat messages doesn\u2019t exceed the height of the chat pane.Here, the expression chatThreadRef.scrollHeight - chatThreadRef.scrollTop will be equivalent to chatThreadRef.scrollHeight - 0.When this is evaluated, it\u2019ll be equal to the scrollHeight of the chat pane \u2014 just before the new message is inserted to the DOM.If you remember from the previous explanation, the value returned from the getSnapshotBeforeUpdate method is passed as the third argument to the componentDidUpdate method. We call this snapshot:componentDidUpdate(prevProps, prevState, snapshot) {}The value passed in here \u2014 at this time, is the previous scrollHeight before the update to the DOM.In the componentDidUpdate we have the following code, but what does it do?componentDidUpdate(prevProps, prevState, snapshot) {    if (snapshot !== null) {      const chatThreadRef = this.chatThreadRef.current;      chatThreadRef.scrollTop = chatThreadRef.scrollHeight - snapshot;    }  }In actuality, we are programmatically scrolling the pane vertically from the top down, by a distance equal to chatThreadRef.scrollHeight - snapshot;Since snapshot refers to the scrollHeight before the update, the above expression returns the height of the new chat message plus any other related height owing to the update.Please see the graphic below:When the entire chat pane height is occupied with messages (and already scrolled up a bit), the snapshot value returned by the getSnapshotBeforeUpdate method will be equal to the actual height of the chat pane.The computation from componentDidUpdate will set to scrollTop value to the sum of the heights of extra messages - exactly what we want.Yeah, that\u2019s it.If you got stuck, I\u2019m sure going through the explanation (one more time) or checking the source code will help clarify your questions.The Error Handling Lifecycle Methods.Sometimes things go bad, errors are thrown. The error lifecycle methods are invoked when an error is thrown by a descendant component i.e a component below them.Let\u2019s implement a simple component to catch errors in the demo app. For this, we\u2019ll create a new component called ErrorBoundary.Here\u2019s the most basic implementation:import React, { Component } from 'react';class ErrorBoundary extends Component {  state = {};  render() {    return null;  }}export default ErrorBoundary;Now, let\u2019s incorporate the error lifecycle methods.static getDerivedStateFromError.Whenever an error is thrown in a descendant component, this method is called first, and the error thrown passed as an argument.Whatever value is returned from this method is used to update the state of the component.Let\u2019s update the ErrorBoundary component to use this lifecycle method.import React, { Component } from \"react\";class ErrorBoundary extends Component {  state = {};  static getDerivedStateFromError(error) {    console.log(`Error log from getDerivedStateFromError: ${error}`);    return { hasError: true };  }  render() {    return null;  }}export default ErrorBoundary;Right now, whenever an error is thrown in a descendant component, the error will be logged to the console, console.error(error), and an object is returned from the getDerivedStateFromError method. This will be used to update the state of the ErrorBoundary component i.e with hasError: true.componentDidCatch.The componentDidCatch method is also called after an error in a descendant component is thrown. Apart from the error thrown, it is passed one more argument which represents more information about the error:componentDidCatch(error, info) {}In this method, you can send the error or info received to an external logging service. Unlike getDerivedStateFromError, the componentDidCatch allows for side-effects:componentDidCatch(error, info) {\tlogToExternalService(error, info) // this is allowed.         //Where logToExternalService may make an API call.}Let\u2019s update the ErrorBoundary component to use this lifecycle method:import React, { Component } from \"react\";class ErrorBoundary extends Component {  state = { hasError: false };  static getDerivedStateFromError(error) {    console.log(`Error log from getDerivedStateFromError: ${error}`);    return { hasError: true };  }  componentDidCatch(error, info) {    console.log(`Error log from componentDidCatch: ${error}`);    console.log(info);  }  render() {    return null  }}export default ErrorBoundary;Also, since the ErrorBoundary can only catch errors from descendant components, we\u2019ll have the component render whatever is passed as Children or render a default error UI if something went wrong:... render() {    if (this.state.hasError) {      return <h1>Something went wrong.</h1>;    }    return this.props.children; }I have simulated a javascript error whenever you add a 5th chat message.Have a look at the error boundary at work:Conclusion.It is worth mentioning that while new additions were made to the component lifecycle methods, some other methods such as componentWillMount , componentWillUpdate, componentWillReceiveProps were deprecated.Deprecated lifecycle methodsNow you\u2019re up to date on the changes made to the component lifecycle methods since React version 16!Chapter 2: Simpler State Management with the Context API.John\u2019s an amazing developer, and he loves what he does. However, he\u2019s frequently been facing the same problem when writing React applications.Props drillingProps drilling, the term used to describe passing down props needlessly through a deeply nested component tree, has plagued John for a while now!Luckily, John has a friend who always has all the answers. Hopefully, she can suggest a way out.John reaches out to Mia, and she steps in to offer some advice.Mia says, \u2018try Redux or MobX\u2019.Mia is a fabulous engineer as well, and she suggests using some state management library such as Redux or MobX.These are great choices, however, for most of John\u2019s use cases, he finds them a little too bloated for his need.\u201cCan\u2019t I have something simpler and native to React itself\u201d, says John.Mia goes on a desperate search to help a friend in need, and she finds the Context API.Mia recommends using React\u2019s Context API to solve the problem. John is now happy, excited to see what the Context API could offer, and he goes about his work productively.This marks the beginning of John\u2019s experience with the Context API.Introduction to Context.The Context API exists to make it easy to share data considered \u201cglobal\u201d within a component tree.Let\u2019s have a look at an illustrated example before we delve into writing any code.Well, John has began working with the Context API and has mostly been impressed with it so far. Today he has a new project to work on, and he intends to use the context API.Let\u2019s see what this new project is about.The new project: Benny Home RunJohn is expected to build a game for a new client of his. This game is called Benny Home Run, and it seems like a great place to use the Context API.The sole aim of the game is to move Benny from his start position to his new home.The aim of the gameTo build this game, John must keep track of the position of Benny.Since Benny\u2019s position is such an integral part of the entire application, it may as well be tracked via some global application state.Tracking position values x and y in stateDid I just say \u201cglobal application state\u201d?Yeah!That sounds like a good fit for the Context API.So, how may John build this?First, there\u2019s the need to import the createContext method from Reactimport {createContext} from 'react';The createContext method allows you to create what\u2019s referred to as a context object. Consider this to be the data structure that powers retrieving and saving state values.To create a context object, you invoke the createContext method with (or without) an initial state value to be saved in the context object.createContext(initialStateValue)Here\u2019s what that looks like in the Benny app:const BennyPositionContext = createContext({ \tx: 50, \ty: 50 })The createContext method is invoked with an initial state value corresponding to the initial position values (x and y) for Benny.Looks good!But, after creating a context object, how exactly do you gain access to the state values within your application?Well, every context object comes with a Provider and Consumer component.The Provider component \u201cprovides\u201d the value saved in the context object to its children, while the Consumer component \u201cconsumes\u201d the values from within any child component.I know that was a mouth full, so let\u2019s break it apart slowly.In the Benny example, we can go ahead and destructure the BennyPositionContext to retrieve the Provider and Consumer components.const BennyPositionContext = createContext({ \tx: 50, \ty: 50 })// get provider and consumerconst { Provider, Consumer } = BennyPositionContextSince Provider provides value saved in the context object to its children, we could wrap a tree of components with the Provider component as shown below:&lt;Provider>   <Root /> // the root component for the Benny app. </Provider>Now, any child component within the Root component will have access to the default values stored in the context object.Consider the following tree of components for the Benny app.<Provider>   <Scene>     <Benny />   &lt;/Scene></Provider>Where Scene and Benny are children of the Root component and represent the game scene and benny character respectively.In this example, the Scene or the even more nested Benny component will have access to the value provided by the Provider component.It is worth mentioning that a Provider also takes in a value props.This value prop is useful if you want to provide a value other than the initial value passed in at the context object creation time via createContext(initialStateValue)Here\u2019s an example where a new set of values are passed in to the Provider component.<Provider value={x: 100, y: 150}>   <Scene>     <Benny />   &lt;/Scene></Provider>Now that we have values provided by the Provider component, how can a nested component such as Benny consume this value?The simple answer is by using the Consumer component.Consider the Benny component being a simple component that renders some SVG.const Benny = () => {  return <svg />}Now, within Benny we can go ahead and use the Consumer component like this:const Benny = () => {  return <Consumer>  {(position) => <svg /&gt;}</Consumer>}Okay, what\u2019s going on there?The Consumer component exposes a render prop API i.e children is a function. This function is then passed arguments corresponding to the values saved in the context object. In this case, the position object with the x and y coordinate values.It is worth noting that whenever the value from a Provider component changes, the associated Consumer component and the children will be re-rendered to keep the value(s) consumed in sync.Also, a Consumer will receive values from the closest Provider above it in the tree.Consider the situation below:// create context object const BennyPositionContext = createContext({ \tx: 50, \ty: 50 })// get provider and consumerconst { Provider, Consumer } = BennyPositionContext// wrap Root component in a Provider&lt;Provider>  <Root />;</Provider>// in Benny, within Root. const Benny = () => (  <Provider value={x: 100, y: 100}>    // do whatever  </Provider>)Now, with a new provider component introduced in Benny, any Consumer within Benny will receive the value {x: 100, y: 100} NOT the initial value of {x: 50, y: 50}.This is a contrived illustrated example, but it helps solidify the foundations of using the Context API.Having understood the necessary building blocks for using the Context API, let\u2019s build an application utilizing all you\u2019ve learned so far, with extra use cases discussed.Example: The Mini-Bank Application.John\u2019s an all round focused guy. When he\u2019s not working on projects from his work place, he dabbles into side projects.One of his many side projects is a bank application he thinks could shape the future of banking. How so.I managed to get the source code for this application. You\u2019ll find it in the code repository for the book as well.To get started, please Install the dependencies and run the application by following the commands below:cd 02-Context-API/bank-appyarn installyarn startOnce that\u2019s done, the application starts off with a login screen as seen below:You can enter whatever username and password combination of your choosing.Upon login in you\u2019ll be presented with the application\u2019s main screen shown below:In the main screen you can perform actions such as viewing your bank account balance and making withdrawals as well.cliking yes from the previous screen displays the account balanceOur goal here is to manage the state in this application a lot better by introducing React\u2019s Context.Identifying Props being Drilled.The root component of the application is called Root, and has the implementation below:... import { USER } from './api'class Root extends Component {  state = {    loggedInUser: null  }  handleLogin = evt => {    evt.preventDefault()    this.setState({      loggedInUser: USER    })  }  render () {    const { loggedInUser } = this.state    return loggedInUser ? (      &lt;App loggedInUser={loggedInUser} />    ) : (      <Login handleLogin={this.handleLogin} /&gt;    )  }}If the user is logged in, the main component App is rendered, else we show the Login component.... loggedInUser ? (      &lt;App loggedInUser={loggedInUser} />    ) : (   <Login handleLogin={this.handleLogin} />)...Upon a successful login (which doesn\u2019t require any particular username and password combinations), the state of the Root application is updated with a loggedInUser....handleLogin = evt => {    ...    this.setState({      loggedInUser: USER    })  }...In the real world, this could come from an api call.For this application, I\u2019ve created a fake user in the api directory that exports the following user object.export const USER = {  name: 'June',  totalAmount: 2500701}Basically, the name and totalAmount of the user\u2019s bank account are retrieved and set to state when you log in.How\u2019s the user object used in the application?Well, consider the main component, App. This is the component responsible for rendering everything in the app other than the Login screen.Here\u2019s the implementation of that:class App extends Component {  state = {    showBalance: false  }  displayBalance = () => {    this.setState({ showBalance: true })  }  render () {    const { loggedInUser } = this.props    const { showBalance } = this.state    return (      <div className='App'>            <User loggedInUser={loggedInUser} profilePic={photographer} />\t<ViewAccountBalance          showBalance={showBalance}          loggedInUser={loggedInUser}          displayBalance={this.displayBalance}        />        <section>;          <WithdrawButton amount={10000} />          <WithdrawButton amount={5000} /&gt;        </section>        <Charity />      </div>    )  }}It\u2019s a lot simpler that it seems. Have a second look!The loggedInUser is passed as props to App from Root, and is also passed down to both User and ViewAccountBalance components.The User component receives the loggedInUser prop and passes it down to another child component, Greeting which renders the text, \u201cWelcome, June\u201d.//User.js const User = ({ loggedInUser, profilePic }) => {  return (    <div>      <img  src={profilePic} alt='user' />      <Greeting loggedInUser={loggedInUser} />    </div>  )}Also, ViewAccountBalance takes in a boolean prop showBalance which decides whether to show the account balance or not. This is toggled to true when you click the \u201cyes\u201d button.//ViewAccountBalance.jsconst ViewAccountBalance = ({ showBalance, loggedInUser, displayBalance }) => {  return (    <Fragment>      {!showBalance ? (        <div>          <p>            Would you love to view your account balance?          </p>          <button onClick={displayBalance}>            Yes          </button>        </div>      ) : (        <TotalAmount totalAmount={loggedInUser.totalAmount} />      )}    </Fragment>  )}From the code block above, do you also see that ViewAccountBalance receives the loggedInUser prop only to pass it to TotalAmount?TotalAmount receives this prop, retrieves the totalAmount from the user object and renders the total amount.I\u2019m pretty sure you can figure out whatever else is going on in the code snippets above.Having explained the code so far, do you see the obvious props drilling here?loggedInUser is passed down way too many times to components that don\u2019t even need to know about it.Let\u2019s fix that with the Context API.Avoid Props Drilling with Context.One easy solution is to look at the Root component where we began passing props down and finding a way to introduce a context object in there.Going by that solution, we could create a context object with no initial default values above the Root class declaration:const { Provider, Consumer } = createContext()class Root extends Component {  state = {    loggedInUser: null  }  ... }Then we could wrap the main App component around the Provider with a value prop.class Root extends Component {  state = {    loggedInUser: null  }  ...   render () {    ...    return loggedInUser ? (      <Provider value={this.state.loggedInUser}>        <App loggedInUser={loggedInUser} />      </Provider>    ) ...Initially, the Provider value prop will be null, but as soon as a user logs in and the state is updated in Root, the Provider will also receive the current loggedInUser.With this done we can import the Consumer wherever we want and do away with passing props needlessly down the component tree.For example here\u2019s the Consumer used in the Greeting component:import { Consumer } from '../Root'const Greeting = () => {  return (    <Consumer>      {user => <p>Welcome, {user.name}! </p>;}    </Consumer>  )}We could go ahead and do the same everywhere else we\u2019ve passed the loggedInUser prop needlessly.And the app works just as before, only we got rid of passing down loggedInUser over and over again .Isolating Implementation Details.The solution highlighted above works but not without some caveat.A better solution will be to centralise the logic for the user state and Provider in one place.This is pretty common practice. Let me show you what I mean.Instead of having the Root component manage the state for loggedInUser, we will create a new file called UserContext.js.This file will have the related logic for updating loggedInUser as well as expose a context Provider and Consumer to make sure loggedInUser and any updater functions are accessible from anywhere in the component tree.This sort of modularity becomes important when you have many different context objects. For example, you could have a ThemeContext and LanguageContext object in the same app.Extracting these into separate files and components proves more manageable and effective over time.Consider the following:// UserContext.jsimport React, { createContext, Component } from 'react'import { USER } from '../api'const { Provider, Consumer } = createContext()class UserProvider extends Component {  state = {    loggedInUser: null  }  handleLogin = evt => {    evt.preventDefault()    this.setState({      loggedInUser: USER    })  }  render () {    const { loggedInUser } = this.state    return (      <Provider        value={{          user: loggedInUser,          handleLogin: this.handleLogin        }}      >        {this.props.children}      </Provider>    )  }}export { UserProvider as default, Consumer as UserConsumer }This represents the content of the new context/UserContext.js file. The logic previously handled by the Root component has been moved here.Note how it handles every logic regarding the loggedInUser state value, and passes the needed values to children via a Provider....<Provider     value={{       user: loggedInUser,       handleLogin: this.handleLogin      }}     >      {this.props.children}</Provider>...In this case, the value prop is an object with the user value, and function to update it, handleLogin.Also note that the Provider and Consumer are both exported. This makes it easy to consume the values from any components in the application.export { UserProvider as default, Consumer as UserConsumer }With this decoupled setup, you can use the loggedInUser state value anywhere in your component tree, and have it updated from anywhere in your component tree as well.Here\u2019s an example of using this in the Greeting component:import React from 'react'import { UserConsumer } from '../context/UserContext'const Greeting = () => {  return (    <UserConsumer>      {({ user }) => <p>Welcome, {user.name}! </p>}    </UserConsumer>  )}export default GreetingHow easy.Now, I\u2019ve taken the effort to delete every reference to loggedInUser where the prop had to be passed down needlessly. Thanks, Context!For example:// before const User = ({ loggedInUser, profilePic }) => {  return (    <div>      <img src={profilePic} alt='user' />      <Greeting loggedInUser={loggedInUser} />    </div>  )}// after: Greeting consumes UserContext const User = ({profilePic }) => {  return (    <div>      <img src={profilePic} alt='user' />      <Greeting />     </div>  )}export default UserBe sure to look in the accompanying code folder for the final implementation i.e. after stripping off the loggedInUser from being passed down needlessly.Updating Context Values.What\u2019s a bank app if you can\u2019t make withdrawals, huh?Well, this app has some buttons. You click them and voil\u00e0, a withdrawal is made.The withdrawal buttonsSince the totalAmount value resides in the loggedInUser object, we may as well have the logic to make withdrawals in the UserContext.js file.Remember we\u2019re trying to centralise all logic related to the user object in one place.To do this, we\u2019ll extend the UserProvider in UserContext.js to include a handleWithdrawal method.// UserContext.js... handleWithdrawal = evt => {    const { name, totalAmount } = this.state.loggedInUser    const withdrawalAmount = evt.target.dataset.amountWhen you click any of the buttons, we will invoke this handleWithdrawal method.From the evt click object passed as an argument to the handleWithdrawal method, we then pull out the amount to be withdrawn from the dataset object.const withdrawalAmount = evt.target.dataset.amountThis is possible because both buttons have a data-amount attribute set on them. For example:<button data-amount=1000 />Now that we have the handleWithdrawal method written out, we can expose it via the values prop passed to Provider as shown below:<Provider    value={{       user: loggedInUser,       handleLogin: this.handleLogin       handleWithdrawal: this.handleWithdrawal     }}   >  {this.props.children}</Provider>Now, we\u2019re all set to consume the handleWithdrawal method from anywhere in the component tree.In this case, our focus is on the WithdrawButton component. Go ahead and wrap that in a UserConsumer, deconstruct the handleWithdrawal method and make it the click handler for the buttons as shown below:const WithdrawButton = ({ amount }) => {  return (    <UserConsumer>      {({ handleWithdrawal }) => (        <button          data-amount={amount}          onClick={handleWithdrawal}        >          WITHDRAW {amount}        </button>      )}    </UserConsumer>  )}On logging in, the withdrawal now works as expected.And that works!ConclusionThis illustrates that you can pass not only state values, but also their corresponding updater functions in a context Provider. These will be available to be consumed anywhere in your component tree.Having made the bank app work well with the Context API, I\u2019m pretty sure John will be proud of the progress we\u2019ve made!Chapter 3: ContextType \u2014 Using Context without a Consumer.So far, John has had a great experience with the Context. Thanks to Mia who recommended such great tool.However, there\u2019s a little problem.As John uses the context API more often, he begins to realise a problem.When you have multiple Consumers within a component, it results in having a lot of nested, not-so-pleasant code.Here\u2019s an example.While working on the Benny Home Run application, John had to create a new context object to hold the game level state of the current user.// initial context objectconst BennyPositionContext = createContext({ \tx: 50, \ty: 50 })// another context object for game level i.e Level 0 - 5 const GameLevelContext = createContext(0)Remember, it\u2019s common practice to split related data into different context objects for reusability and performance (owing to the fact the every consumer is re-rendered when values within a Provider change)With these context objects, John goes ahead to use both Consumer components within the Benny component as follows.//grab consumer for PositionContextconst { Consumer: PositionConsumer } = BennyPositionContext// grab consumer for GameLevelContextconst { Consumer: GameLevelConsumer } = GameLevelContext// use both Consumers here.const Benny = () => {  return <PositionConsumer>    {position => <GameLevelConsumer>        {gameLevel => <svg /&gt;}    </GameLevelConsumer>}  </PositionConsumer>}Do you notice that consuming values from both context objects results in very nested code?Well, this is one of the more common problem with consuming data with the Consumer component. With multiple consumer components, you begin to have a lot of nesting.So, what can we do about this?Firstly, when we learn about Hooks in a later chapter, you\u2019ll come to see an almost perfect solution to this. In the mean time, let\u2019s consider the solution available to Class components via something calledcontextType.Using a Class Component with contextType.To take advantage of contextType you\u2019re required to work with a class component.Consider the Benny component rewritten as a class component.// create context objectconst { Provider, Consumer } = createContext({ x: 50, y: 50 })// Class componentclass Benny extends Component {  render () {    return <Consumer>    {position => <svg />}  &lt;/Consumer>  }}In this example, Benny consumes the initial context values { x: 50, y: 50 } from the context object.However, using a Consumer forces you to use a render prop API that may lead to nested code.Let\u2019s get rid of the Consumer component by using the contextType class property.Getting this to work is fairly easy.First, you set the contextType property on the class component to a context object.const BennyPositionContext = createContext({ x: 50, y: 50 })// Class Benny extends Component ... // look here ?Benny.contextType = BennyPositionContext After setting the contextType property, you can go ahead to consume values from the context object by using this.context.For example, to retrieve the position values { x: 50, y: 50 }:class Benny extends Component {  render () {    // look here. No nesting!    const position = this.context    return <svg />  }}The Perfect Solution?Using the contextType class property is great, but not particularly the best solution in the world. You can only use one contextType within a class component. This means if you need to introduce multiple Consumers you\u2019ll still have some nested code.ConclusionThe contextType property is does solve the nesting problem a little bit.However, when we discuss Hooks in a later chapter, you\u2019ll see how much better the solution hooks offer is.Chapter 4: React.memo === Functional PureComponent.A few weeks ago John refactored the Benny component to a PureComponent.Here\u2019s what his change looked like:Well, that looks good.However, the only reason he refactored the Benny component to a class component was because be needed to extend React.PureComponent.The solution works, but what if we could achieve the same effect without having to refactor from functional to class components?Refactoring large components just because you need a specific React feature isn\u2019t the most pleasant of experiences.How React.memo works.React.memo is the perfect replacement for the class\u2019 PureComponent. All you do is wrap your functional component in the React.memo function call and you get the exact behaviour PureComponent gives.Here\u2019s a quick example:// before import React from 'react'function MyComponent ({name}) {     return ( <div>        Hello {name}.            </div>    )}export default MyComponent// after import React, { memo } from 'react'export default  memo(function MyComponent ({name}) {    return ( <div>        Hello {name}.            </div&gt;    )})So simple, it couldn\u2019t get any easier.Technically, React.memo is a higher order function that takes in a functional component and returns a new memoized component.So, if props do not change, react will skip rendering the component and just use the previously memoized value.With this new found information, John refactors the functional component, Benny to use React.memo.Handling Deeply Nested Props.React.memo does a props shallow comparison. By implication, if you have nested props objects, the comparison will fail.To handle such cases, React.memo takes in a second argument, an equality check function.Here\u2019s a basic example:import React, { memo } from 'react'export default  memo (function MyComponent (props) {      return ( <div>        Hello World from {props.name.surname.short}            </div&gt;    )}, equalityCheck)function equalityCheck(prevProps, nextProps) {  // return perform equality check & return true || false}If the equalityCheck function returns true, no re-render will happen. This would mean that the current props and previous props are the same. If you return false, then a re-render will occur.If you\u2019re concerned about incurring extra performance hits from doing a deep comparison, you may use the lodash isEqual utility method.import { isEqual } from 'lodash'function equalityCheck(prevProps, nextProps) {\treturn isEqual(prevProps, nextProps) }Conclusion.React.memo brings the class PureComponent behaviour to functional components. We\u2019ve also had a look at using the equalityCheck function as well. If you use the equalityCheck function, be sure to include checks for function props where applicable. Not doing so is a common source of bugs in many React applications.Chapter 5: The Profiler \u2014 Identifying Performance Bottlenecks.It\u2019s Friday and Mia is headed back home. On her way home she can\u2019t help but think to herself.\u201cWhat have I achieved today?\u201d Mia says her to herself.After a long careful thought, she comes to the conclusion that she accomplished just one thing the entire day.Well, how is it possible that Mia only achieved one thing the entire day?That \u2018one thing\u2019 had better be a worthy feat!So, what was Mia\u2019s accomplishment for the day?It turns out that all Mia accomplished today was sitting helplessly as her browser attempted to load a page for 7 hours!What???Measuring Performance in React Apps.Web performance is a big deal. Nobody has all the time in the world to sit through minutes waiting for your webpage to load.In order to measure performance and identify performance bottlenecks in your apps, it\u2019s crucial to have some way to inspect how long it took your app\u2019s components to render, and why they were rendered.This is exactly why the Profiler exists.If you\u2019ve been writing react for sometime, you might remember the react-addons-perf module.Well, that has been deprecated in favour of the Profiler.With the Profiler, you can:Collect timing information about each componentEasily identify performance bottlenecksBe sure to have a tool compatible with concurrent renderingGetting Started.To keep this as pragmatic as possible, I have set up a tiny application we\u2019re going to profile together. i.e measure performance. We\u2019ll do this with the aid of the Profiler.I call the application fake-medium, and it looks like this:The Fake-medium appYou\u2019ll find the source code for the application in the code repository for this book.To Install the dependencies and run the app, run the following from the04-The-Profiler directory:cd fake-mediumyarn install yarn startIf you ran those commands, you should have the application running in your default browser, on port 3000 or similar.Application running on some local port.Finally, open your chrome devtools by pressing Command+Option+J (Mac) or Control+Shift+J (Windows, Linux, and Chrome OS).Then find the React chrome devtools extension tab and click it.You\u2019ll be presented with two tabs, elements and profiler.You guessed right, our focus is on the profiler tab, so please click it.Doing so will lead you to the following page:How does the Profiler Work?The Profiler works by recording a session of actual usage of your application. In this recording session it gathers information about the components in your application and displays some interesting information you can exploit to find performance bottlenecks.To get started, click the record button.After clicking \u2018record\u2019, you then go ahead to use your application as you\u2019d expect a user to.In this case, I\u2019ve gone ahead to click the medium clap button 3 times!Once you\u2019re done interacting with your application, hit stop to view the information the Profiler provides.Making Sense of the Profiler Results.On the far right of the profiler screen, you\u2019ll find a visual representation of the number of commits made during your interaction with your application.Conceptually, react does work in 2 phases. The render phase where components are rendered and the virtual DOM diffed, and the commit phase where actual changes in the virtual DOM are committed to the DOM.The graphical representation you see on the far right of the profiler represents the number of commits that were made to the DOM during your interaction with the app.The taller the bar is, the longer it took React to render the components in this commit.In the example above, the Profiler recorded three commits. That make sense since I clicked the button only 3 times. So, there should be only 3 commits made to the DOM.Also the first commit took much longer than the subsequent two commits.The three bars represent the different commits made to the DOM, and you can click on any to investigate performance metrics for the particular commit.The Flame Chart.After a successful recording session, you\u2019ll be presented with a couple different bits of information about your components.First, you have 3 tabs representing different groups of information \u2014 each relating to the selected commit on the right.The first tab represents a flame chart.The flame chart displays information on how long it took your component tree to render.You\u2019ll notice that each component in your application tree is represented by bars of varying lengths and colors.The length of a bar defines how long it took the component (and its children) to render.Judging by the bar length, it appears the Provider component took the longest time to render. That make sense since the Provider is the main root component of the app, so the time represented here is the time taken for Provider and all its children to render.That\u2019s half the story.Note that the colors of the bars are different.For example, Provider and a couple other components have a grey color.What does that mean?Well, first we are investing the first commit made to the DOM during the interaction with the application.The components with a grey color means they weren\u2019t rendered in this commit. If the component is greyed out, it wasn\u2019t rendered in this commit. So, the length of the bar only represents how long it took the component to render previously before this commit i.e. before the interaction with the application.If you think about it, that\u2019s reasonable.On careful examination, you\u2019ll see that the only component with a different flame chart color here is the Clap component.This component represents the Medium clap button that was clicked.A yellow bar means the component took the most time to render in this commit.Well, no other component is coloured which means the Clap button was the only component re-rendered in this commit.That\u2019s perfect!You don\u2019t want to click the Clap button and have a different component being re-rendered. That\u2019ll be a performance hit right there.In more complex applications, you\u2019ll find flame charts with not just yellow and grey bars. You\u2019ll find some with blue bars.What\u2019s worth noting is that, yellow longer bars took more time to render, followed by the blue ones, and finally grey bars weren\u2019t re-rendered in the particular commit being viewed.It\u2019s also possible to click on a particular bar to view more information on why it rendered or not i.e. the props and state passed to the component.While zoomed in, you can also click the commit bars on top to see the difference in props or state across each commit render.The Ranked Chart.Once you understand how the flame chart works, the ranked chart becomes a walk in the park.The second tab option refers to the ranked chart.The ranked chart displays every component that was rendered in the commit being viewed. It displays this components ranked from top to bottom \u2014 with component which took more time to render at the top.In this example, we have just the Clap component displayed in the ranked chart view. That\u2019s okay as we only expect the Clap component to be re-rendered upon clicking.A more complex ranked chart may look like this:Ranked chart from an application we\u2019ll profile nextYou can see how the longer yellow bars are right there at the top, and shorter blue bars at the bottom. If you look carefully, you\u2019ll notice that the colors fade as you go from top to bottom. From more yellow bars to pale yellow bars, to light blue bars and finally blue bars.Component Chart.Whenever you zoom into a component within the Profiler i.e. by clicking its associated bar, a new option on the right pops up.Clicking this button will bring you to what\u2019s called the component chart.The component chart displays how many times a particular component was re-rendered during the recorded interaction.In this example, I can click the button to view chart for the Clap component.This shows three bars representing the three times the Clap component was re-rendered. If I saw a fourth bar here, I\u2019d begin to get worried as I only clicked three times and expected only three re-renders.If the selected component didn\u2019t re-render at all, you\u2019ll be presented with the empty screen below:NB: you can either view the component chart by clicking the button on the far right, or by double clicking a component bar from the flame or ranked chart.Interactions.There\u2019s one final tab in the profiler, and by default it displays an empty screen:Interactions let you tag actions performed during a recording session with a string identifier so they can be monitored and tracked within the profiling results.The API for this is unstable, but here\u2019s how to enable interactions in your profiling results.First install the scheduler module. From your terminal, run yarn add scheduler within the application directory .Once the installation is done, you need to use unstable_trace function exported by the module as shown below:import { unstable_trace as trace } from 'scheduler/tracing'The function is exported as unstable_trace but you can rename it in the import statement as I have done above.The trace function has a signature similar to this:trace(\"string identifier\", timestamp, () = {})It takes a string identifier, timestamp and a callback function. Ideally, you track whatever interaction you want by passing it into the callback.For example, I have gone ahead to do this in the fake-medium application:// before _handleClick () {   // do something}// after _handleClick () {   trace(\"Clap was clicked!\", window.performace.now(), () => {  \t  // do something   })}The medium clap when clicked calls the _handleClick method. Now, I\u2019ve wrapped the functionality within the trace method.Here\u2019s what happens when the profiling result is now viewed:Clicking three times now records 3 interactions and you can click on any of the interactions to view more details about them.The interactions will also show up in the flame and ranked charts.Example: Identifying Performance BottleNecks in the Bank Application.\u201cHey John, what have you done?!!!\u201d, said Mia as she stumped into John\u2019s office.\u201cI was just profiling the bank application, and it\u2019s so not performant\u201d, she added.John wasn\u2019t surprised. He had not spent a lot of time thinking about performance, but with Mia up in his face, he began to have a rethink.\u201cOkay, I\u2019ll have a look and fix whatever bottlenecks I find. Can we do that together?\u201d, John said while thinking to himself how much help Mia would be since she spotted the problem anyway.\u201cOh, sure\u201d, she retorted.After spending a couple hours, they found and fixed a coupe of performance bottlenecks in the application.What did they do? What measures were taken?In this example, we\u2019ll spin up the bank application and pick up from where we stopped in the earlier chapter. This time we\u2019ll fix the performance bottlenecks within the application.Here\u2019s what the bank app looks like again:Noting the Expected Behaviour.When I need to profile an application, specifically during a certain interaction with an app, I like to set the baseline for what I expect in terms of performance. This sort of expectation helps you retain your focus as you delve into interpreting the results from the Profiler.Let\u2019s consider the bank application we want to profile. The interaction in the bank app is simple. You click a set of buttons, and the withdrawal amount is updated.The basic interaction of the appNow, what would you consider the expected behaviour of this app with respect to re-renders and updates?Well, for me, it\u2019s quite simple.The only part of the app visually changing is the withdrawal amount. Before going into the profiling session, my expectation for a performant application will be that no unnecessary components are re-rendered, just the component responsible for updating the total amount.Where I expect re-renders to happen. Nowhere else.Give or take, I\u2019ll expect just the TotalAmount component to be re-rendered, or any other component directly connected with that update.With this expectation set, let\u2019s go on and profile the application.The steps are the same as discussed earlier. You open your devtools, record an interaction session, and begin to interpret the results.Now, I have gone ahead to record a session. In this session, all I did was click the \u201cwithdraw $10,000\u201d button 3 times.Here\u2019s the flame chart from the profiling session:Flame chart resultsOh my! From the chart above, so many components were re-rendered. You see the many bar colours represented in the flame chart ?This is far from ideal, so let\u2019s begin to fix the problem.Interpreting the Flame chart.First let\u2019s consider what\u2019s likely the root of the problem here. By default, whenever a Provider has its value changed, every child component is forced to re-render. That\u2019s how the Consumer gets the latest values from the context object and stays in sync.The problem here is that every component apart from Root is a child of Provider \u2014 and they all get re-rendered needlessly!All children components re-rendered with a change in the Provider\u2019s value.So, what can we do about this?Some of the child components don\u2019t need to be re-rendered as they are not directly connected with the change.First, let\u2019s consider the first child component, App.The App component doesn\u2019t receive any prop and it only manages the state value showBalance.class App extends Component {  state = {    showBalance: false  }  displayBalance = () => {    this.setState({ showBalance: true })  }  render () {    const { showBalance } = this.state    ...  }}It isn\u2019t directly connected with the change, and it\u2019s pointless to re-render this component.Let\u2019s fix this by making it a PureComponent.// before class App extends Component {  state = {    showBalance: false  } ... }// after class App extends PureComponent {  state = {    showBalance: false  } ... }Having made App a PureComponent, did we make any decent progress?Well, have a look at the new flame chart generated after that simple (one-liner) change.Can you see that?A lot of App\u2019s children aren\u2019t re-rendered needlessly, and we have a more sane flame graph now.Great!Profile Different Interactions.It\u2019s easy to assume that because we had fewer re-renders in the \u201cwithdraw amount\u201d interaction we now have a performant app.That\u2019s not correct.App\u2019s now a PureComponent, but what happens when App gets rendered owing to a state change?Well, let\u2019s profile a different interaction. This time, load up the application and profile the interaction for viewing an account balance.If you go ahead and profile the interaction, we get a completely different result.Screencast showing the interaction being profiled.Now, what\u2019s changed?From the flame graph above, every child component of App as been re-rendered. They all had nothing to do with this visual update, so those are wasted rendered.NB: If you need to check the hierarchy of components more clearly, remember you can always click the elements tab:Well, since these child components are functional components, let\u2019s use React.memo to memoize the render results so they don\u2019t change except there\u2019s a change in props.// User.jsimport { memo } from 'react'const User = memo(({ profilePic }) => {  ...})// ViewAccountBalance.jsimport { memo } from 'react'const ViewAccountBalance = memo(({ showBalance, displayBalance }) => {      ...})// WithdrawButton.jsimport { memo } from 'react'const WithdrawButton = memo(({ amount }) => {    ...  )})Now, when you do that and re-profile the interaction, we get a much nicer flame chart:Now, only ViewAccountBalance and other child components are re-rendered. That\u2019s okay.When you view your flame chart i.e if you\u2019re following along, you may see something slightly different.The names of the component may not be shown. You get the generic name Memo and it becomes difficult to track which component is what.To change this, set the displayName property for the memoized components.Below\u2019s an example.// ViewAccountBalance.jsconst ViewAccountBalance = memo(({ showBalance, displayBalance }) => {  ...})// set the displayName hereViewAccountBalance.displayName = 'ViewAccountBalance'You go ahead and do this for all the memoized functional components.The Provider Value.We\u2019re pretty much done with resolving the performance leaks in the application, however, there\u2019s one more thing to do.The effect isn\u2019t very obvious in this application, but will come handy as you face more cases in the real world such as in situations where a Provider is nested within other components.The implementation of the Provider in the bank application had the following:...<Provider    value={{       user: loggedInUser,       handleLogin: this.handleLogin       handleWithdrawal: this.handleWithdrawal     }}   >  {this.props.children}</Provider>...The problem here is that we\u2019re passing a new object to the value prop every single time. A better solution will be to keep a reference to these values via state. e.g.<Provider value={this.state}>\t{this.props.children}</Provider>Doing this requires a bit of refactoring as shown below:// context/UserContext.jsclass UserProvider extends Component {  constructor () {    super()    this.state = {      user: null,      handleLogin: this.handleLogin,      handleWithdrawal: this.handleWithdrawal    }  }  ...  render () {    return <Provider value={this.state}>  \t\t{this.props.children}\t</Provider>  }}Be sure to look in the associated code folder if you need more clarity on this.Conclusion.Profiling applications and identifying performance leaks is fun and rewarding. I hope you\u2019ve gained relevant knowledge in this section.Chapter 6: Lazy Loading with React.Lazy and Suspense.\u201cHey John, we need to look into lazy loading some modules in the Benny application\u201d, says Tunde, John\u2019s manager.John\u2019s had great feedback from his manager for the past few months. Every now and then Tunde storms into the office with a new project idea. Today, it\u2019s lazy loading with React.Lazy and Suspense.John\u2019s never lazy loaded a module with React.Lazy and Suspense before now. This is all new to him, so he ventures into a quick study to deliver on what his manager has requested.What is Lazy Loading?When you bundle your application, you likely have the entire application bundled in one large chunk.As your app grows, so does the bundle.To understand lazy loading, here\u2019s the specific use case Tunde had in mind when he discussed with John.\u201cHey John, do you remember the Benny app has an initial home screen?\u201d, said Tunde.By initial home scree, Tunde was referring to this:This is the first screen the user encounters when they visit the Benny game. To begin playing the game, you must click the \u201cStart Game\u201d button to be redirected to the actual game scene.\u201cJohn, the problem here is that we\u2019ve bundled all our React components together and are all served to the user on this page\u201d.\u201cOh, I see where you\u2019re going\u201d, said John.\u201cInstead of loading the GameScene component and its associated assets, we could defer the loading of those until the user actually clicks \u2019Start Game\u2019, huh?\u201d, said John.And Tunde agreed with a resounding \u201cYes, that\u2019s exactly what I mean\u201d.Lay loading refers to deferring the loading of a particular resource until much later, usually when a user makes an interaction that demands the resource to be actually loaded. In some cases it could also mean preloading a resource.Essentially, the user doesn\u2019t get the lazy loaded bundle served to them initially, rather it is fetched much later at runtime.This is great for performance optimisations, initial load speed etc.React makes lazy loading possible by employing the dynamic import syntax.Dynamic imports refer to a tc39 syntax proposal for javascript, however, with transpilers like Babel, we can use this syntax today.The typical, static way of importing a module looks like this:import { myModule } from 'awesome-module'While this is desirable in many cases, the syntax doesn\u2019t allow for dynamically loading a module at runtime.Being able to dynamically load a part of a Javascript application at runtime makes way for interesting use cases such as loading a resource based on a user\u2019s language (a factor that can only be determined at runtime), or only loading some code just when it is likely to be used by the user (performance gains).For these reasons (and more) there\u2019s a proposal for introducing the dynamic import syntax to Javascript.Here\u2019s what the syntax looks like:import('path-to-awesome-module')It has a syntax similar to a function, but is really not a function. It doesn\u2019t inherit from Funtion.proptotype and you can\u2019t invoke methods such as call and apply.The returned result from the dynamic import call is a promise which is resolved with the imported module.import('path-to-awesome-module')\t.then(module => {     // do something with the module here e.g. module.default() to invoke the default export of the module. })Using React.lazy and Suspense.React.lazy and Suspense make using dynamic imports in a React application so easy.For example, consider the demo code for the Benny application below:import React from 'react'import Benny from './Benny'import Scene from './Scene'import GameInstructions from './GameInstructions'class Game extends Component {  state = {    startGame: false  }  render () {    return !this.state.startGame ?         <GameInstructions /> : \t\t<Scene />  }}export default Game;Based on the state property startGame, either the GameInstructions or Scene component is rendered when the user clicks the \u201cStart Game\u201d button.GameInstructions represents the home page of the game and Scene the entire scene of the game itself.In this implementation, GameInstructions and Scene will be bundled together in the same Javascript resource.Consequently, even when the user hasn\u2019t shown intent to start playing the game, we would have loaded and sent to the user, the complex Scene component which contains all the logic for the game scene.So, what do we do?Let\u2019s defer the loading of the Scene component.Here\u2019s how easy React.lazy makes that.// before import Scene from './Scene'// now const Scene = React.lazy(() => import('./Scene'))React.lazy takes a function that must call a dynamic import. In this case, the dynamic import call is import('./Scene').Note that React.lazy expects the dynamically loaded module to have a default export containing a React component.With the Scene component now dynamically loaded, when the application is bundled for production, a separate module (or javascript file) will be created for the Scene dynamic import.When the app loads, this javascript file won\u2019t be sent to the user. However, if they click the \u201cStart Game\u201d button and show intent to load the Scene component, a network request would be made to fetch the resource from the remote server.Now, fetching from the server introduces some latency. To handle this, wrap the Scene component in a Suspense component to show a fallback for when the resource is being fetched.Here\u2019s what I mean:import { Suspense } from 'react'const Scene = React.lazy(() => import('./Scene'))class Game extends Component {  state = {    startGame: false  }  render () {    return !this.state.startGame ?         <GameInstructions /> : \t\t// look here\t\t<;Suspense fallback=\"<div>loading ...</div>\">\t\t  <Scene />\t\t</Suspense>  }}export default Game;Now, when the network request is initiated to fetch the Scene resource, we\u2019ll show a \u201cloading\u2026\u201d fallback courtesy the Suspense component.Suspense takes a fallback prop which can be a markup as shown here, or a full blown React component e.g. a custom loader.With React.lazy and Suspense you can suspend the fetching of a component until much later, and show a fallback for when the resource is being fetched.How convenient.Also, you can place the Suspense component anywhere above the lazy loaded component. In this case the Scene component.If you also had multiple lazy loaded components, you could wrap them in a single Suspense component or multiple, depending on your specific use case.Handling Errors.In the real-world, things break often, right?It\u2019s possible that in the process of fetching the lazy loaded resource, a network error occurs.To handle such case, be sure to wrap your lazy loaded components in an Error Boundary.Remember error boundaries from the Lifecycle method chapter?Here\u2019s an example:import { Suspense } from 'react'import MyErrorBoundary from './MyErrorBoundary'const Scene = React.lazy(() => import('./Scene'))class Game extends Component {  state = {    startGame: false  }  render () {    return &lt;MyErrorBoundary>         {!this.state.startGame ?            <GameInstructions /> : \t\t   <Suspense fallback=\"loading ...\">\t\t     <Scene />;\t\t   </Suspense>}\t\t</MyErrorBoundary>  }}export default Game;Now, if an error occurs while fetching the lazy loaded resource, it\u2019ll be graciously handled by the error boundary.No named exports.If you remember from the section above, I did mention that React.lazy expects the dynamic import statement to include a module with a default export being a React component.At the moment, React.lazy doesn\u2019t support named exports. That\u2019s not entirely a bad thing, as it keeps tree shaking working so you don\u2019t import actual unused modules.Consider the following module:// MyAwesomeComponents.js export const AwesomeA = () => <div> I am awesome </div> export const AwesomeB = () => <div> I am awesome </div> export const AwesomeC = () => <div> I am awesome </div>Now, if you attempt to use React.lazy with a dynamic import of the module above, you\u2019ll get an error.// SomeWhereElse.js const Awesome = React.lazy(() => import('./MyAwesomeComponents'))That won\u2019t work since there\u2019s no default export in the MyAwesomeComponents.js module.A workaround would be to create some other module that exports one of the components as a default.For example, if I was interested in lazy loading the AwesomeA component from the MyAwesomeComponents.js module, I could create a new module like this:// AwesomeA.js export { AwesomeA as default } from './MyAwesomeComponents'Then I can can go ahead to effectively use React.lazy as follows:// SomeWhereElse.jsconst AwesomeA = React.lazy(() => import('AwesomeA'))Problem solved!Code splitting routes.Code splitting advocates that instead of sending this large chunk of code to the user at once, you may dynamically send chunks to the user when they need it.We had looked at component based code splitting in the earlier examples, but another common approach is with route based code splitting.In this method, the code is split into chunks based on the routes in the application.We could also take our knowledge of lazy loading one step further by code splitting routes.Consider a typical React app that uses react-router for route matching.const App = () => (  <Router>      <Switch>        <Route exact path=\"/\" component={Home}/>        <Route path=\"/about\" component={About}/>      </Switch>  </Router>);We could lazy load the Home and About components so they are only fetched when the user hits the associated routes.Here\u2019s how with React.Lazy and Suspense.// lazy load the route componentsconst Home = React.lazy(() => import('./Home'))const About = React.lazy(() => import('./About'))// Provide a fallback with Suspenseconst App = () => (  <Router&gt;    <Suspense fallback={<div>Loading...</div>}>      <Switch>        <Route exact path=\"/\" component={Home}/>        <Route path=\"/about\" component={About}/>      </Switch>    </Suspense>  </Router>);Easy, huh?We\u2019ve discussed how React.Lazy and Suspense works, but under the hood, the actual code splitting i.e. generating separate bundles for different modules is done by a bundler, for example Webpack.If you use create-react-app, Gatsby or Next.js then you have this already set up for you.Setting this up yourself is also easy, you just need to tweak your Webpack config a little bit.The official Webpack documentation has an entire guide on this. The guide may be worth checking if you\u2019re handling the budding configurations in your application yourself.Example: Adding Lazy Loading to the Bank App.We can add some lazy loading to the bank application we saw from Chapter 2.Consider the Root component of the application:const Root = () => (  <UserProvider>    <UserConsumer>      {({ user, handleLogin }) =>        user ? <App /> : <Login handleLogin={handleLogin} />      }    </UserConsumer>  </UserProvider>)When a user isn\u2019t logged in we display the login page, and the App component only when the user is logged in.We could lazy load the App component, right?This is very easy. You use the dynamic import syntax with React.lazy and wrap the App component in a Suspense component.Here\u2019s how:...const App = React.lazy(() => import('./containers/App'))const Root = () => (  ...  <Suspense fallback='loading...'>     <App /&gt;  </Suspense>)Now, if you throttle your network connection to simulate Slow 3G, you\u2019ll see the intermediate \u201cloading\u2026\u201d text after logging in.Conclusion.React.lazy and Suspense are great, and so intuitive to work with, however, they do not support server side rendering yet.It\u2019s likely this will change in the future, but in the mean time, if you care about SSR, using react-loadable is your best bet for lazy loading React components.Chapter 7: Hooks \u2014 Building Simpler React Apps.For the past 3 years John\u2019s been writing React apps, functional components have mostly been dumb.If you wanted local state or some other complex side effects, you had to reach out to class component. You either painfully refactor your functional components to class components or nothing else.It\u2019s a bright Thursday afternoon, and while having lunch, Mia introduces John to Hooks.She speaks so enthusiastically, it piques John\u2019s interest.Of all the things Mia said, one thing struck John. \u201cWith hooks, functional components become just as powerful (if not more powerful) than your typical class components\u201d.That\u2019s a bold statement from Mia.So, let\u2019s consider what hooks are.Introducing Hooks.Early this year, 2019, the React team released a new addition, hooks, to React in version 16.8.0.If React were a big bowl of candies, then hooks are the latest additions, very chewy candies with great taste!So, what exactly do hooks mean? And why are they worth your time?One of the main reasons hooks were added to React is to offer a more powerful and expressive way to write (and share) functionality between components.In the longer term, we expect Hooks to be the primary way people write React components \u2014 React TeamIf hooks are going to be that important, why not learn about them in a fun way!The Candy Bowl.Consider React to be a beautiful bowl of candy.The bowl of candy has been incredibly helpful to people around the world.The people who made this bowl of candy realized that some of the candies in the bowl weren\u2019t doing people much good.A couple of the candies tasted great, yes! But they brought about some complexity when people ate them \u2014 think render props and higher order components?So, what did they do?They did the right thing \u2014 not throwing away all the previous candies, but making new sets of candies.These candies were called Hooks.These candies exist for one purpose: to make it easier for you to do the things you are already doing.These candies aren\u2019t super special. In fact, as you begin to eat them you\u2019ll realize they taste familiar \u2014 they are just Javascript functions!As with all good candies, these 10 new candies all have their unique names. Though they are collectively called hooks.Their names always begin with the three letter word, use \u2026 e.g. useState, useEffect etc.Just like chocolate, these 10 candies all share some of the same ingredients. Knowing how one tastes, helps you relate to the other.Sounds fun? Now let\u2019s have these candies.The State Hook.As stated earlier, hooks are functions. Officially, there are 10 of them. 10 new functions that exist to make writing and sharing functionalities in your components a lot more expressive.The first hook we\u2019ll take a look at is called, useState.For a long time, you couldn\u2019t use the local state in a functional component. Well, not until hooks.With useState, your functional component can have (and update) local state.How interesting.Consider the following counter application:With the Counter component shown below:Simple, huh?Let me ask you one simple question. Why exactly do we have this component as a Class component?Well, the answer is simply because we need to keep track of some local state within the component.Now, here\u2019s the same component refactored to a functional component with access to state via the useState hooks.What\u2019s different?I\u2019ll walk you through it step by step.A functional component doesn\u2019t have all the Class extend ... syntax.function CounterHooks() {}It also doesn\u2019t require a render method.function CounterHooks() {    return (      <div>        <h3 className=\"center\">Welcome to the Counter of Life </h3>        <button           className=\"center-block\"           onClick={this.handleClick}> {count} </button>      </div>    ); }There are two concerns with the code above.You\u2019re not supposed to use the this keyword in function components.The count state variable hasn\u2019t been defined.Extract handleClick to a separate function within the functional component:function CounterHooks() {  const handleClick = () => {   }  return (      <div>        <h3 className=\"center\">Welcome to the Counter of Life </h3>        <button           className=\"center-block\"           onClick={handleClick}> {count} </button>      </div>    ); }Before the refactor, the count variable came from the class component\u2019s state object.In functional components, and with hooks, that comes from invoking the useState function or hook.useState is called with one argument, the initial state value e.g. useState(0) where 0 represents the initial state value to be kept track of.Invoking this function returns an array with two values.//? returns an array with 2 values. useState(0) The first value being the current state value being tracked, and second, a function to update the state value.Think of this as some state and setState replica - however, they aren\u2019t quite the same.With this new knowledge, here\u2019s useState in action.function CounterHooks() {  // ?   const [count, setCount] = useState(0);  const handleClick = () => {    setCount(count + 1)  }  return (      <div>        <h3 className=\"center\">Welcome to the Counter of Life </h3>        <button           className=\"center-block\"           onClick={handleClick}> {count} </button>      </div>    ); } There are a few things to note here, apart from the obvious simplicity of the code!One, since invoking useState returns an array of values, the values could be easily destructed into separate values as shown below:const [count, setCount] = useState(0);Also, note how the handleClick function in the refactored code doesn\u2019t need any reference to prevState or anything like that.It just calls setCount with the new value, count + 1.Simple as it sounds, you\u2019ve built your very first component using hooks. I know it\u2019s a contrived example, but that\u2019s a good start!NB: it\u2019s also possible to pass a function to the state updater function. This is usually recommended as with setState when a state update depends on a previous value of state e.g. setCount(prevCount => prevCount + 1)Multiple useState calls.With class components, we all got used to setting state values in an object whether they contained a single property or more.// single property state = {  count: 0}// multiple properties state = { count: 0, time: '07:00'}With useState you may have noticed a subtle difference.In the example above, we only called useState with the actual initial value. Not an object to hold the value.useState(0)So, what if we wanted to keep track of another state value?Can multiple useState calls be used?Consider the component below. It\u2019s the same counter application with a twist. This time the counter keeps track of the time of click.As you can see, the hooks usage is quite the same, except for having a new useState call.const [time, setTime] = useState(new Date())Now, the time state variable is used in the rendered markup to display the hour, minute and second of the click.<p>     at: {`${time.getHours()} : ${time.getMinutes()} :${time.getSeconds()}`}  </p>Great!Object as Initial ValuesIs it possible to use an object with useState as opposed to multiple useState calls?Absolutely!If you choose to do this, you should note that unlike setState calls, the values passed into useState replaces the state value.setState merges object properties but useState replaces the entire value.The Effect Hook.With class components you\u2019ve likely performed side effects such as logging, fetching data or managing subscriptions.These side effects may be called \u201ceffects\u201d for short, and the effect hook, useEffect was created for this purpose.How\u2019s it used?Well, the useEffect hook is called by passing it a function within which you can perform your side effects.Below\u2019s a quick example:useEffect(() => {  // ? you can perform side effects here  console.log(\"useEffect first timer here.\")}) To useEffect I\u2019ve passed an anonymous function with some side effect called within it.The next logical question is, when is the useEffect function invoked?Well, remember that in class components you had lifecycle methods such as componentDidMount and componentDidUpdate.Since functional components don\u2019t have these lifecycle methods, useEffect kinda takes their place.Thus, in the example above, the function within useEffect also known as the effect function, will be invoked when the functional component mounts (componentDidMount) and when the component updates componentDidUpdate).Here\u2019s that in action.By adding the useEffect call above to the counter app, we indeed get the log from the useEffect function.By default, the useEffect function will be called after every render.NB: The useEffect hook isn\u2019t entirely the same as componentDidMount + componentDidUpdate. It can be viewed as such, but the implementation differs with some subtle differences.Passing Array Dependencies.It\u2019s interesting that the effect function is invoked every time there\u2019s an update. That\u2019s great, but it\u2019s not always the desired functionality.What if you only want to run the effect function only when the component mounts?That\u2019s a common use case and useEffect takes a second parameter, an array of dependencies to handle this.If you pass in an empty array, the effect function is run only on mount \u2014 subsequent re-renders don\u2019t trigger the effect function.useEffect(() => {    console.log(\"useEffect first timer here.\")}, [])If you pass any values into this array, then the effect function will be run on mount, and anytime the values passed are updated. That is, if any of the values are changed, the effected call will re-run.useEffect(() => {    console.log(\"useEffect first timer here.\")}, [count])The effect function will be run on mount, and whenever the count function changes.What about subscriptions?It\u2019s common to subscribe and unsubscribe from certain effects in certain apps.Consider the following:useEffect(() => {  const clicked = () => console.log('window clicked');  window.addEventListener('click', clicked);}, [])In the effect above, upon mounting, a click event listener is attached to the window.How do we unsubscribe from this listener when the component is unmounted?Well, useEffect allows for this.If you return a function within your effect function, it will be invoked when the component unmounts. This is the perfect place to cancel subscriptions as shown below:useEffect(() => {    const clicked = () => console.log('window clicked');    window.addEventListener('click', clicked);    return () =>; {      window.removeEventListener('click', clicked)    } }, [])There\u2019s a lot more you can do with the useEffect hook such as making API calls.Build Your own HooksFrom the start of the hooks section we\u2019ve taken (and used) candies from the candy box React provides.However, React also provides a way for you to make your own unique candies \u2014 called custom hooks.So, how does that work?A custom hook is just a regular function. However, its name must begin with the word, use and if needed, it may call any of the React hooks within itself.Below\u2019s an example:The Rules of HooksThere are two rules to adhere to while using hooks.Only Call Hooks at the Top Level i.e. not within conditionals, loops or nested functions.Only Call Hooks from React Functions i.e. Functional Components and Custom Hooks.This ESLint plugin is great to ensure you adhere to these rules within your projects.Advanced HooksWe have only considered two out of 10 of the hooks React provides!What\u2019s interesting is that the knowledge of how useState and useEffect works helps you quickly learn the other hooks.Curious to learn about those, I have created a hooks cheatsheet with live editable examples.Why this is important is that you can immediately begin to tinker with real examples that\u2019ll reinforce your knowledge of how hooks work. All of them!Remember that learning is reinforced when you actual solve problems and build stuff.What\u2019s more interesting as well is, after you get through the live examples for each of the hooks, there\u2019s an extra section for other generic examples that don\u2019t exactly fit one hook or require a separate case study.In the example section you\u2019ll find examples such as fetching data from a remote server using hooks and more.Live example from the cheatsheet.Go, check it out.Chapter 8: Advanced React Patterns with HooksWith the release of hooks, certain React patterns have gone out of favour. They can still used, but for most use cases you\u2019re likely better off using hooks. For example, choose hooks over render props or higher order components.There may be specific use cases where these could still be used, but most of the times, choose hooks.That being said, we will now consider some more advanced React patterns implemented with hooks.Ready?IntroductionThis chapter may be the longest in the book, and for good reason. Hooks are likely the way we\u2019ll be writing React components in the next couple of years, and so they are quite important.In this chapter, we\u2019ll consider the following advanced React patterns:Compound ComponentsProps CollectionProp GettersState InitializersState ReducerControl PropsIf you\u2019re completely new to these advanced patterns, don\u2019t worry, I\u2019ll explain them in detail. If you\u2019re familiar with how these patterns work from previous experiences with class components, I\u2019ll show you how to use these patterns with hooks.Now, let\u2019s get started.Why Advanced Patterns?John\u2019s had a fairly good career. Today, he\u2019s a senior frontend engineer at ReactCorp. A great startup changing the world for good.ReactCorp is beginning to scale their workforce. A lot of engineers are being hired and John\u2019s beginning to work on building reusable components for the entire team of engineers.Yes, John can build components with his current React skills, however, with building highly reusable components comes specific problems.There\u2019s a million different ways the components can be consumed, and you want to give consumers of the component as much flexibility as possible.They must be able to extend the functionality and styles of the component as they deem fit.The advanced patterns we\u2019ll consider here are tested and tried methods for building very reusable components that don\u2019t cripple flexibility.I didn\u2019t create these advanced patterns. Truth be told, most of the advanced React patterns were made popular by one guy, Kent Dodds \u2014 an amazing Javascript engineer.The community has received these patterns extremely well, and I\u2019m here to help you understand how they work!Compound Components PatternThe first pattern we will consider is called the Compound Components pattern. I know it sounds fancy, so I\u2019ll explain what it really means.The keyword in the pattern name is the word Compound.Literarily, the word compound refers to something that is composed of two or more separate elements.With respect to React components, this could mean a component that is composed of two or more separate components.It doesn\u2019t end there.Any React component can be composed of 2 or more separate components. So, that\u2019s really not a brilliant way to describe compound components.With compound components, there\u2019s more. The separate components within which the main component is composed cannot really be used without the parent.compound componentsThe main component is usually called the parent, and the separate composed components, children.The classic example is to consider the html select element.<select>  <option value=\"value0\">key0</option>  <option value=\"value1\">key1</option>  <option value=\"value2\">key2</option></select>With select being the parent, and the many option elements, children.This works like a compound component. For one, it really makes no sense to use the <option>key0<;/option> element without a select parent tag. The overall behaviour of a select element also relies on having these composed option elements as well.They are so connected to one another.Also, the state of the entire component is managed by select with all child elements dependent on that state.Do you get a sense for what compound components are now?It is also worth mentioning that compound components are just one of many ways to express the API for your components.For example, while it doesn\u2019t look as good, the select element could have been designed to work like this:<select options=\"key:value;anotherKey:anotherValue\"><;/select>This is definitely not the best way to express this API. It make passing attributes to the child components almost impossible.With that in mind, let\u2019s take a look at an example that\u2019ll help you understand and build your own compound components.Example: Building an Expandable Component.The final component being usedWe\u2019ll be building an Expandable component. Did you ask what that means?Well, consider an Expandable component to be a miniature accordion element. It has a clickable header, which toggles the display of an associated body of content.In the unexpanded state the component would look like this:And this, when expanded:You get the idea, right?Designing the APIIt\u2019s usually a good idea to write out what the exposed API of your component would look like before building it out.In this case, here\u2019s what we\u2019re going for:<Expandable>\t<Expandable.Header> Header </Expandable.Header> \t<Expandable.Icon/>    <Expandable.Body> This is the content &lt;/Expandable.Body></Expandable>A break down of the child componentsIn the code block above you\u2019d have noticed I have expressions like this: Expandable.HeaderYou could as well do this:<Expandable>\t<Header> Header </Expandable.Header> \t<Icon/>    <Body> This is the content </Body></Expandable>It doesn\u2019t matter. I have chosen Expandable.Header over Header as a matter of personal preference. I find that it communicates dependency on the parent component well, but that\u2019s just my preference. A lot of people don\u2019t share the same preference and that\u2019s perfectly fine.It\u2019s your component, use whatever API looks good to you :)Building the Expandable ComponentThe Expandable component being the parent component will keep track of state, and It will do this via a boolean variable called expanded.// state {  expanded: true || false}The Expandable component needs to communicate the state to every child component regardless of their position in the nested component tree.Remember that the children are dependent on the parent compound component for state.How best may we go about this?If you said context, you\u2019re correct!We need to create a context object to hold the component state, and expose the expanded property via the Provider component. Alongside the expanded property, we will also expose a function callback to toggle the value of this expanded state property.the state relationship for the expandable componentIf that sounds alright to you, here\u2019s the starting point for the Expandable component.// Expandable.js import React, { createContext } from 'react'const ExpandableContext = createContext()const { Provider } = ExpandableContextconst Expandable = ({children}) => {  return <Provider>{children}</Provider>}export default ExpandableThere\u2019s nothing spectacular going on in the code block above.A context object is created and the Provider component deconstructed. Then we go on to create the Expandable component which renders the Provider and any children.Got that?With the basic setup out of the way, let\u2019s do a little more.The context object was created with no initial value. However, we need the Provider to expose the state value expanded and a toggle function to update the state.Let\u2019s create the expanded state value using useState.// Expandable.js import React, { createContext, useState } from 'react'...const Expandable = ({children}) => {  // look here ?  const [expanded, setExpanded] = useState(false)   return <Provider>{children}</Provider>}With the expanded state variable created, let\u2019s create the toggle updater function to toggle the value of expanded \u2014 whether true or false.// Expandable.js ...const Expandable = ({children}) => {  const [expanded, setExpanded] = useState(false)  // look here ?  const toggle = setExpanded(prevExpanded => !prevExpanded)   return <Provider>{children}</Provider>}The toggle function invokes setExpanded, the actual updater function returned from the useState call.Every updater function from the useState call can receive a function argument. This is similar to how you pass a function to setState e.g. setState(prevState => !prevState.value).This is the same thing I\u2019ve done above. The function passed to setExpanded receives the previous value of expanded and returns the opposite of that, !expandedtoggle acts as a callback function and It\u2019ll eventually be invoked by Expandable.Header. Let\u2019s prevent any future performance issue by memoizing the callback.... import { useCallback } from 'react';const Expandable = ({children}) => {  const [expanded, setExpanded] = useState(false)  // look here ?  const toggle = useCallback(    () => setExpanded(prevExpanded => !prevExpanded),    []  ))return <Provider>{children}</Provider> Not sure how useCallback works? You probably skipped the previous advanced hooks section that pointed to the cheatsheet. Have a look.Once we have both expanded and toggle created, we can expose these via the Provider\u2019s value prop....const Expandable = ({children}) => {  const [expanded, setExpanded] = useState(false)  const toggle = useCallback(    () => setExpanded(prevExpanded => !prevExpanded),    []  )   // look here ?  const value = { expanded, toggle }   // and here ?  return <;Provider value={value}>{children}</Provider>}  This works, but the value reference will be different on every re-render causing the Provider to re-render its children.Let\u2019s memoize the value....const Expandable = ({children}) => {  ... // look here ?  const value = useMemo(\t() => ({ expanded, toggle }), \t[expanded, toggle]  )  return <Provider value={value}>{children}&lt;/Provider>} useMemo takes a callback that returns the object value { expanded, toggle } and we pass an array dependency [expanded, toggle] so that the memoized value remains the same unless those change.We\u2019ve done a great job so far!Now, there\u2019s just one other thing to do on the Expandable parent component.If you remember from a previous experience with class components, it\u2019s possible to do this:this.setState({  name: \"value\"}, () => {  this.props.onStateChange(this.state.name)})This is how you trigger a callback after a state change in class components.Usually, the callback e.g. this.props.onStateChange is always invoked with the current value of the updated state as shown below:this.props.onStateChange(this.state.name)Why is this important?This is good practice when creating reusable components, because this way the consumer of your component can attach any custom logic to be run after a state update.For example:const doSomethingPersonal = ({expanded}) => {  // do something really important after being expanded}<Expandable onExpanded={doSomethingPersonal}> ... </Expandable>We will add this functionality to the Expanded component.With class components this is pretty much straightforward. With functional components, we need to do a little more work \u2014 not so much :)Whenever you want to perform a side effect within a functional component, for most cases, always reach out for useEffect.So, the easiest solution might look like this:useEffect(() => {  props.onExpanded(expanded)}, [expanded])The problem however with this is that the useEffect effect function is called at least once \u2014 when the component is initially mounted.So, even though there\u2019s a dependency array, [expanded], the callback will also be invoked when the component mounts!useEffect(() => {  // this function will always be invoked on mount})The functionality we seek requires that the callback to be passed by the user isn\u2019t invoked on mount.How can we enforce this?First, consider the naive solution below://faulty solution... let componentJustMounted = trueuseEffect(    () => {        if(!componentJustMounted) {        props.onExpand(expanded)        componentJustMounted = false      }    },    [expanded]  )...What\u2019s wrong with the code above?Loosely speaking, the thinking behind the code is correct. You keep track of a certain variable componentJustMounted and set it to true, and only call the user callback onExpand when componentJustMounted is false.The componentJustMounted value is only set to false after the user callback has been invoked at least once.Looks good.However, the problem with this is that whenever the function component re-renders owing to a state or prop change, the componentJustMounted value will always be reset to true. Thus, the user callback onExpand will never be invoked as it is only invoked when componentJustMounted is falsey....if (!componentJustMounted) {    \tonExpand(expanded)}...Well, the solution to this is simple. We can use the useRef hook to ensure that a value stays the same all through lifetime of the component.Here\u2019s how it works://correct implementation  const componentJustMounted = useRef(true)  useEffect(    () => {      if (!componentJustMounted.current) {        onExpand(expanded)      }      componentJustMounted.current = false    },    [expanded]  )useRef returns a ref object and the value stored in the object may be retrieved from ref.currentThe signature for useRef looks like this: useRef(initialValue).Hence, stored initially in componentJustMounted.current is a ref object with the current property set to true.const componentJustMounted = useRef(true)After invoking the user callback, we then update this value to false.componentJustMounted.current = falseNow, whenever there\u2019s a state or prop change the value in the ref object isn\u2019t tampered with. It remains the same.With the current implementation, whenever the expanded state value is toggled, the user callback function onExpanded will be invoked with the current value of expanded.Here\u2019s what the final implementation of the Expandable component now looks like:// Expandable.js const Expandable = ({ children, onExpand }) => {  const [expanded, setExpanded] = useState(false)  const toggle = useCallback(    () => setExpanded(prevExpanded => !prevExpanded),    []  )  const componentJustMounted = useRef(true)  useEffect(    () => {      if (!componentJustMounted) {        onExpand(expanded)      }       componentJustMounted.current = false    },    [expanded]  )  const value = useMemo(   () => ({ expanded, toggle }),    [expanded, toggle]  )  return (    <Provider value={value}>        {children}    </Provider>  )}If you\u2019ve followed along, that\u2019s great. We\u2019ve sorted out the most complex component in the bunch. Now, let\u2019s build the child components.Building the Compound Child ComponentsThere are three child components for the Expandable component.These child components need to consume values from the context object created in Expandable.js.To make this possible, we\u2019ll do a little refactoring as shown below:export const ExpandableContext = createContext()We export the context object, ExpandableContext from Expandable.js.Now, we may use the useContext hook to consume the values from the Provider.Below\u2019s the Header child component fully implemented.//Header.jsimport React, { useContext } from 'react'import { ExpandableContext } from './Expandable'const Header = ({children}) => {  const { toggle } = useContext(ExpandableContext)  return <div onClick={toggle}>{children}</div>}export default HeaderSimple, huh?It renders a div whose onClick callback is the toggle function for toggling the expanded state within the Expandable parent component.Here\u2019s the implementation for the Body child component:// Body.jsimport { useContext } from 'react'import { ExpandableContext } from './Expandable'const Body = ({ children }) => {  const { expanded } = useContext(ExpandableContext)  return expanded ? children : null}export default BodyPretty simple as well.The expanded value is retrieved from the context object and used within the rendered markup. It reads like this: If expanded, render children else render nothing.The Icon component is just as simple.// Icon.jsimport { useContext } from 'react'import { ExpandableContext } from './Expandable'const Icon = () => {  const { expanded } = useContext(ExpandableContext)  return expanded ? '-' : '+'}export default IconIt renders either + or - depending on the value of expanded retrieved from the context object.With all child components built, we can set the child components as Expandable properties. See below:import Header from './Header'import Icon from './Icon'import Body from './Body'const Expandable = ({ children, onExpand }) => {\t...}// Remember this is just a personal reference. It's not mandatoryExpandable.Header = HeaderExpandable.Body = BodyExpandable.Icon = IconNow we can go ahead to use the Expandable component as designed:<Expandable>    <Expandable.Header>React hooks</Expandable.Header>           <Expandable.Icon />    <Expandable.Body>Hooks are awesome&lt;/Expandable.Body></Expandable>Does it work?You bet!Here\u2019s what\u2019s rendered when not expanded:And when expanded:This works but it has to be the ugliest component I\u2019ve ever seen. We can do better.Manageable Styling for Reusable ComponentsHate it or not, styling (or CSS) is integral to how the web works.While there\u2019s a number of ways to style a React component, and I\u2019m sure you have a favourite, when you build reusable components it\u2019s always a good idea to expose a frictionless API for overriding default styles.Usually, I recommend letting it possible to have your components styleable via both style and className props.For example:// this should work.<MyComponent style={{name: \"value\"}} />// and this.<MyComponent className=\"my-class-name-with-dope-styles\" />Now, our goal isn\u2019t just styling the component, but to make it as reusable as possible. This means letting whoever consumes the component style the component whichever they want i.e inline style via the style prop, or by passing some className prop.Let\u2019s begin with the Header child component:// before const Header = ({children}) => {  const { toggle } = useContext(ExpandableContext)  return <div onClick={toggle}>{children}</div>}First, let\u2019s change the rendered markup to a button. It\u2019s a more accessible and semantic alternative to the div used earlier.const Header = ({children}) => {  const { toggle } = useContext(ExpandableContext)  // look here ?  return <button onClick={toggle}>{children}<;/button>} We will now write some default styles for the Header component in a Header.css file.// Header.css.Expandable-trigger {    background: none;    color: hsl(0, 0%, 13%);    display: block;    font-size: 1rem;    font-weight: normal;    margin: 0;    padding: 1em 1.5em;    position: relative;    text-align: left;    width: 100%;    outline: none;    text-align: center;  }    .Expandable-trigger:focus,  .Expandable-trigger:hover {    background: hsl(216, 94%, 94%);  }I\u2019m sure you can figure out the simple CSS above. If not, don\u2019t stress it. What\u2019s important is to note the default className used here, .Expandable-triggerTo apply these styles, we need to import the CSS file and apply the appropriate className prop to the rendered button.... import './Header.css'const Header = () => {  const { toggle } = useContext(ExpandableContext)  return <button onClick={toggle} \t className=\"Expandable-trigger\">\t{children}&lt;/button>}This works great, however the className is set to the default string Expandable-trigger.This will apply the styling we\u2019ve written in the CSS file, but it doesn\u2019t take into the account any className prop passed in by the user.It\u2019s important to accommodate passing this className prop as a user might like to change the default style you\u2019ve set in your CSS.Here\u2019s one way to do this:// Header.jsimport './Header.css'const Header = ({ children, className}) => {  // look here ?  const combinedClassName = `Expandable-trigger ${className}`  return (    <button onClick={toggle} className={combinedClassName}>      {children}    </button>  )} Now, whatever className is passed to the Header component will be combined with the default Expandable-trigger before been passed on to the rendered button element.Let\u2019s consider how good the current solution is.First, if the className prop is null or undefined, the combinedClassName variable will hold the value \"Expandable-trigger null\" or \"Expandable-trigger undefined\".To prevent this, be sure to pass a className by using the ES6 default parameters syntax as shown below:// note how className defaults to an empty stringconst Header = ({ children, className = '' }) => {  ...}Having provided a default value, if the user still doesn\u2019t enter a className, the combinedClassName value will be equal to \"Expandable-trigger \".Note the empty string appended to the Expandable-trigger. This is owing to how template literals work.My preferred solution is to do this:const combinedClassName = ['Expandable-trigger', className].join('')This solution handles the previously discussed edge cases. If you also want to explicit about removing null, undefined or any other falsey values, you can do the following:const combinedClassName = ['Expandable-trigger', className].filter(Boolean).join('')I\u2019ll stick with the simpler alternative, and providing a default for className via default parameters.With that being said, here\u2019s the final implementation for Header:// after ...import './Header.css'const Header = ({ children, className = ''}) => {  const { toggle } = useContext(ExpandableContext)  const combinedClassName = ['Expandable-trigger', className].join('')return (    <button onClick={toggle} className={combinedClassName}>      {children}    </button>  )}So far, so good.Incase you were wondering, combinedClassName returns a string. Since strings are compared by value, there\u2019s no need to memoize this value with useMemo.So far, we\u2019ve graciously handled the className prop. How about the option to override default styles by passing a style prop?Well, let\u2019s fix that.Instead of explicitly destructuring the style prop, we can pass on any other prop passed by the user to the button component.// rest paramter ...otherProps ?const Header = ({ children, className = '', ...otherProps }) => {\treturn (    // spread syntax {...otherProps} ?    <button {...otherProps}>      {children}    </button>  )}  Note the use of the rest parameter and spread syntax.With this done, the Header component receives our default styles, yet allows for change via the className or style props.// override style via className<Expandable.Header className=\"my-class\">\tReact hooks</Expandable.Header>// override style via style prop<Expandable.Header style={{color: \"red\"}}>\tReact hooks</Expandable.Header>Now, I\u2019ll go ahead and do the same for the other child components, Body and Icon.// before const Body = ({ children }) => {  const { expanded } = useContext(ExpandableContext)  return expanded ? children : null}// after import './Body.css'const Body = ({ children, className = '', ...otherProps }) => {  const { expanded } = useContext(ExpandableContext)  const combinedClassNames = ['Expandable-panel', className].join('')  return expanded ? (    <div className={combinedClassNames} {...otherProps}>      {children}    </div>  ) : null}// Body.css.Expandable-panel {    margin: 0;    padding: 1em 1.5em;    border: 1px solid hsl(216, 94%, 94%);;    min-height: 150px;  }Do the same for Icon component:// before const Icon = () => {  const { expanded } = useContext(ExpandableContext)  return expanded ? '-' : '+'}// after ...import './Icon.css'const Icon = ({ className = '', ...otherProps }) => {  ...  const combinedClassNames = ['Expandable-icon', className].join('')  return (    <span className={combinedClassNames} {...otherProps}>      {expanded ? '-' : '+'}    </span>  )}// Icon.css.Expandable-icon {    position: absolute;    top: 16px;    right: 10px;}And finally, some styles for the parent component, Expandable.import './Expandable.css'const Expandable = ({ children, onExpand, className = '', ...otherProps }) => {   ...   const combinedClassNames = ['Expandable', className].join('')  return (    <Provider value={value}>      <div className={combinedClassNames} {...otherProps}>        {children}      </div>    </Provider>  )}// Expandable.css.Expandable {     position: relative;     width: 350px;}Now we\u2019ve got a beautiful reusable component!We\u2019ve not just made it beautiful, but it\u2019s customisable as well.How customisable is the component we\u2019ve built?See what I\u2019ve done below with the same component!And this didn\u2019t take a lot of code.<Expandable>    <Expandable.Header>Reintroducing React</Expandable.Header>    <Expandable.Icon />    <Expandable.Body>     \t<img            src='https://i.imgur.com/qpj4Y7N.png'            style={{ width: '250px' }}            alt='reintroducing react book cover'        />        <p style={{ opacity: 0.7 }}>          This book is so f*cking amazing! <br />        <a          href='https://leanpub.com/reintroducing-react'          target='_blank'          rel='noopener noreferrer'          >            Go get it now.        </a>       </p>     </Expandable.Body></Expandable>You can go one step further to test if overriding styles via the style prop works as well.<Expandable>   <Expandable.Header       // look here ?\t  style={{ color: 'red', border: '1px solid teal' }}>        Reintroducing React    </Expandable.Header>        ...</Expandable> And below\u2019s the result of that:Default Header styles override with the style prop.Yay! it works as expected.Note: I have covered 5 other advanced component patterns with Hooks in the ebook (PDF, Epub and Mobi). You can get it completely free (or pay whatever you want if you like my work).https://leanpub.com/reintroducing-reactConclusionThis has been a lengthy discourse on the modern changes in React. If you don\u2019t get all of it yet, spend a little more time practising the examples in your day to day work, and I\u2019m pretty sure you\u2019ll get a hang of it real quick.When you do, go be the React engineer with a decent understanding of Modern React and go build highly reusable components with advanced hook patterns.Thank you for following me on this journey. Got questions? Use the comment section!\n\n                        \n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    ", "length": 114045, "excerpt": "In this article (and accompanying book), unlike any you may have come across\nbefore, I will deliver funny, unfeigned and dead serious comic strips about\nevery React update since v16+. It\u2019ll be hilarious, either intentionally or\nunintentionally, easy on beginners as well as professionals, and will be very\ninformative as a whole.\n\nWhy Comic Strips ?\nI have been writing software for over 5 years. But I have done other things,\ntoo. I\u2019ve been a graphics designer, a published author, teacher, and a lo", "siteName": "freeCodeCamp.org", "publishedTime": "2019-05-02T20:05:07.000Z", "id": "07b0c25f39ce841c82336385fe8319cec01329bc", "url": "https://www.freecodecamp.org/news/reintroducing-react-every-react-update-since-v16-demystified-60686ee292cc/", "domain": "freecodecamp.org", "date": "2023-12-27T18:10:45.280042", "resultUri": "http://localhost:3000/result/07b0c25f39ce841c82336385fe8319cec01329bc", "query": {"url": ["https://www.freecodecamp.org/news/reintroducing-react-every-react-update-since-v16-demystified-60686ee292cc/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "Reintroducing React \u2013 Every React Update Since v16 [Full Handbook]", "description": "In this article (and accompanying book), unlike any you may have come across before, I will deliver funny, unfeigned and dead serious comic strips about every React update since v16+. It\u2019ll be hilarious, either intentionally or unintentionally, easy on beginners as well as professionals, and will be very informative as", "url": "https://www.freecodecamp.org/news/reintroducing-react-every-react-update-since-v16-demystified-60686ee292cc/", "image": "https://cdn-media-1.freecodecamp.org/images/1*EFYIS4Y6E3M4fv0BIG3G2w.png", "image:width": "800", "image:height": "533"}, "twitter": {"card": "summary_large_image", "title": "Reintroducing React \u2013 Every React Update Since v16 [Full Handbook]", "description": "In this article (and accompanying book), unlike any you may have come across before, I will deliver funny, unfeigned and dead serious comic strips about every React update since v16+. It\u2019ll be hilarious, either intentionally or unintentionally, easy on beginners as well as professionals, and will be very informative as", "url": "https://www.freecodecamp.org/news/reintroducing-react-every-react-update-since-v16-demystified-60686ee292cc/", "image": "https://cdn-media-1.freecodecamp.org/images/1*EFYIS4Y6E3M4fv0BIG3G2w.png", "label1": "Written by", "data1": "Emmanuel Ohans", "label2": "Filed under", "data2": "React, Technology, Tech, Programming, Coding", "site": "@freecodecamp"}}}