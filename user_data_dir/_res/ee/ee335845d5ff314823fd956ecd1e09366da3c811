{"title": "How to Implement Heap-Sort in the Go Standard Library", "byline": "Ehud Tamir", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>How to Implement Heap-Sort in the Go Standard Library</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>Heap-sort is a beautiful sorting algorithm. It uses a max-heap to sort a sequence of numbers or other elements with a defined order relation. In this article we\u2019ll deep-dive into the <strong><strong>Go standard library</strong></strong> heap-sort implementation.</p><h2 id=\"max-heap\">Max-heap</h2><p>First a short recap on <a href=\"https://en.wikipedia.org/wiki/Heap_(data_structure)\"><strong><strong>binary max-heaps</strong></strong></a>. A max-heap is a container that provides its maximum element in O(1) time, adds an element in O(log n), and removes the <strong><strong>maximum element</strong></strong> in O(log n).</p><p>Max-heaps are <strong><strong>almost-full</strong></strong> binary trees, where <strong><strong>every node is greater or equal to its children</strong></strong>. I\u2019ll refer to the latter as <strong><strong>the heap property</strong> </strong>throughout the article.</p><p>Together, these two properties define a max-heap:</p><figure><img alt=\"image-117\" height=\"870\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2019/08/image-117.png\" width=\"1170\"/><figcaption>A Max heap. By Ermishin \u2014 Own work, CC BY-SA 3.0, <a href=\"https://commons.wikimedia.org/w/index.php?curid=12251273\">https://commons.wikimedia.org/w/index.php?curid=12251273</a></figcaption></figure><p>In heap algorithms, a max-heap is represented as an array. In the array representation, the children of the node in index <code>i</code> are located in indices <code>2*i+1</code> and <code>2*i+2</code>. This chart from Wikipedia shows the array representation:</p><figure><img alt=\"image-118\" height=\"242\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2019/08/image-118.png\" width=\"643\"/><figcaption>Max-heap represented as an array. By Maxiantor \u2014 Own work, CC BY-SA 4.0, <a href=\"https://commons.wikimedia.org/w/index.php?curid=55590553\">https://commons.wikimedia.org/w/index.php?curid=55590553</a></figcaption></figure><h2 id=\"building-a-heap\">Building a heap</h2><p>An array can be converted into a max-heap in O(n) time. Amazing, isn\u2019t it? This is the algorithm:</p><ol><li>Treat the input array as a heap. It doesn\u2019t satisfy the heap property yet.</li><li>Iterate the nodes of the heap starting from the second-to-last level of the heap \u2014 that\u2019s one level above the leaves \u2014 going back to the root.</li><li>For each node encountered, propagate it down in the heap, until it is greater than both its children. When propagating down, always swap with the greater child.</li></ol><p>That\u2019s it! You\u2019re done!</p><p>Why does it work? I\u2019ll try to convince you with this hand-wavy proof (Feel free to skip though):</p><ul><li>Take a tree node <code>x</code>. Because we iterate the heap from back to front, when we reach it, the subtrees rooted in both its children already satisfy the heap property.</li><li>If <code>x</code> is greater than both its children, we\u2019re done.</li><li>Otherwise, we swap <code>x</code> with its biggest child. That makes the new root of the subtree greater than both its children.</li><li>If <code>x</code> doesn\u2019t satisfy the heap-property in its new subtree, the process will be repeated until it does or becomes a leaf, in which case it won\u2019t have any children.</li></ul><p>This is true for all nodes in the heap, including the root.</p><h2 id=\"heap-sort-algorithm\">Heap-sort algorithm</h2><p>Now for the main course \u2014 heap-sort.</p><p>Heap-sort works in 2 steps:</p><ol><li>Builds a max-heap from the input array using the algorithm I showed above. This takes O(n) time</li><li>Pops elements from the heap into the output array, filling it from the back to the front. Every removal of the maximum element from the heap takes O(log n) time, which adds up to O(n * log n) for the entire container.</li></ol><p>A cool property of the Go implementation, is that it uses the input array to store the output, thus saving the need to allocate O(n) memory for the output.</p><h2 id=\"heap-sort-implementation\">Heap-sort implementation</h2><p>The Go sort library supports any collection that is <strong><strong>indexed by integers</strong></strong>, has a <strong><strong>defined order relation</strong></strong> on its elements, and <strong><strong>supports swapping</strong> </strong>elements between two indices:</p><figure><pre tabindex=\"0\"><code>type Interface interface {\n\t// Len is the number of elements in the collection.\n\tLen() int\n\t// Less reports whether the element with\n\t// index i should sort before the element with index j.\n\tLess(i, j int) bool\n\t// Swap swaps the elements with indexes i and j.\n\tSwap(i, j int)\n}</code></pre><figcaption>From <a href=\"https://github.com/golang/go/blob/master/src/sort/sort.go\">https://github.com/golang/go/blob/master/src/sort/sort.go</a></figcaption></figure><p>Naturally, any contiguous container of numbers can satisfy this interface.</p><p>Now let\u2019s take a look at the body of <code>heapSort()</code>:</p><figure><pre tabindex=\"0\"><code>func heapSort(data Interface, a, b int) {\n\tfirst := a\n\tlo := 0\n\thi := b - a\n\n\t// Build heap with greatest element at top.\n\tfor i := (hi - 1) / 2; i &gt;= 0; i-- {\n\t\tsiftDown(data, i, hi, first)\n\t}\n\n\t// Pop elements, largest first, into end of data.\n\tfor i := hi - 1; i &gt;= 0; i-- {\n\t\tdata.Swap(first, first+i)\n\t\tsiftDown(data, lo, i, first)\n\t}\n}</code></pre><figcaption>From <a href=\"https://github.com/golang/go/blob/master/src/sort/sort.go\">https://github.com/golang/go/blob/master/src/sort/sort.go</a></figcaption></figure><p>The function\u2019s signature is a bit cryptic, but looking at the first 3 lines clear things up:</p><ul><li><code>a</code> and <code>b</code> are indices into <code>data</code>. <code>heapSort(data, a, b)</code> sorts <code>data</code> in the half-open range <code>[a, b)</code>.</li><li><code>first</code> is a copy of <code>a</code>.</li><li><code>lo</code> and <code>high</code> are indices normalized by <code>a</code> \u2014 <code>lo</code> always starts at zero, and <code>hi</code> at the size of the input.</li></ul><p>Next, the code builds the max-heap:</p><pre tabindex=\"0\"><code>// Build heap with greatest element at top.\nfor i := (hi - 1) / 2; i &gt;= 0; i-- {\n  siftDown(data, i, hi, first)\n}</code></pre><p>As we saw earlier, the code scans the heap from one level above the leaves and uses <code>siftDown()</code> to propagate the current element down until it satisfies the heap property. I\u2019ll go into <code>siftDown()</code> in more detail below.</p><p>At this stage, <code>data</code> is a max-heap.</p><p>Next, we pop all the elements to create the sorted array:</p><pre tabindex=\"0\"><code>// Pop elements, largest first, into end of data.\nfor i := hi - 1; i &gt;= 0; i-- {\n  data.Swap(first, first+i)\n  siftDown(data, lo, i, first)\n}</code></pre><p>In this loop, <code>i</code> is the last index in the heap. On each iteration:</p><ul><li>The heap\u2019s maximum <code>first</code> is swapped with the last element of the heap.</li><li>The heap property is restored by propagating the new <code>first</code> down until it satisfies the heap property.</li><li>The heap size <code>i</code> is reduced by one.</li></ul><p>In other words, we are filling the array from the back to the front, starting from the largest element, to the 2nd element in size all the way to the smallest element. The result is the sorted input.</p><h2 id=\"maintaining-the-heap-property\">Maintaining the heap property</h2><p>Along the post I mentioned using <code>siftDown()</code> to maintain the heap property. Let\u2019s see how it works:</p><figure><pre tabindex=\"0\"><code>// siftDown implements the heap property on data[lo, hi).\n// first is an offset into the array where the root of the heap lies.\nfunc siftDown(data Interface, lo, hi, first int) {\n\troot := lo\n\tfor {\n\t\tchild := 2*root + 1\n\t\tif child &gt;= hi {\n\t\t\tbreak\n\t\t}\n\t\tif child+1 &lt; hi &amp;&amp; data.Less(first+child, first+child+1) {\n\t\t\tchild++\n\t\t}\n\t\tif !data.Less(first+root, first+child) {\n\t\t\treturn\n\t\t}\n\t\tdata.Swap(first+root, first+child)\n\t\troot = child\n\t}\n}</code></pre><figcaption>From <a href=\"https://github.com/golang/go/blob/master/src/sort/sort.go\">https://github.com/golang/go/blob/master/src/sort/sort.go</a></figcaption></figure><p>This code propagates the element in <code>root</code> all the way down the tree until it is larger than both of its children. When going down a level, the element will be swapped with its greater child. That is to make sure that the new parent node is greater than both its children:</p><figure><img alt=\"image-119\" height=\"734\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2019/08/image-119.png\" width=\"1400\"/><figcaption>The parent \u20183\u2019 is swapped with the greatest child \u201810\u2019</figcaption></figure><p>The first few lines calculate the index of the first child and check that it exists:</p><pre tabindex=\"0\"><code>child := 2*root + 1\nif child &gt;= hi {\n  break\n}\n</code></pre><p><code>child &gt;= hi</code> means that the current <code>root</code> is a leaf, so the algorithm stops.</p><p>Next, we pick the greater of the two children:</p><pre tabindex=\"0\"><code>if child+1 &lt; hi &amp;&amp; data.Less(first+child, first+child+1) {\n  child++\n}</code></pre><p>Since any node\u2019s children are next to each other in the array, <code>child++</code> selects the second child.</p><p>Next, we check if the parent is indeed smaller than the child:</p><pre tabindex=\"0\"><code>if !data.Less(first+root, first+child) {\n  return\n}</code></pre><p>If the parent is greater than it biggest child, we are done so we return.</p><p>Lastly, if the parent is smaller than the child we swap the two elements and increment <code>root</code> to prepare for the next iteration:</p><pre tabindex=\"0\"><code>data.Swap(first+root, first+child)\nroot = child</code></pre><h2 id=\"conclusion\">Conclusion</h2><p>This is the third article where I read an unfamiliar piece of code and try explain it. I like this kind of experience because it teaches me how to read code and how to communicate about it. Please leave your comments and feedback below!</p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nHeap-sort is a beautiful sorting algorithm. It uses a max-heap to sort a sequence of numbers or other elements with a defined order relation. In this article we\u2019ll deep-dive into the Go standard library heap-sort implementation.Max-heapFirst a short recap on binary max-heaps. A max-heap is a container that provides its maximum element in O(1) time, adds an element in O(log n), and removes the maximum element in O(log n).Max-heaps are almost-full binary trees, where every node is greater or equal to its children. I\u2019ll refer to the latter as the heap property throughout the article.Together, these two properties define a max-heap:A Max heap. By Ermishin \u2014 Own work, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=12251273In heap algorithms, a max-heap is represented as an array. In the array representation, the children of the node in index i are located in indices 2*i+1 and 2*i+2. This chart from Wikipedia shows the array representation:Max-heap represented as an array. By Maxiantor \u2014 Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=55590553Building a heapAn array can be converted into a max-heap in O(n) time. Amazing, isn\u2019t it? This is the algorithm:Treat the input array as a heap. It doesn\u2019t satisfy the heap property yet.Iterate the nodes of the heap starting from the second-to-last level of the heap \u2014 that\u2019s one level above the leaves \u2014 going back to the root.For each node encountered, propagate it down in the heap, until it is greater than both its children. When propagating down, always swap with the greater child.That\u2019s it! You\u2019re done!Why does it work? I\u2019ll try to convince you with this hand-wavy proof (Feel free to skip though):Take a tree node x. Because we iterate the heap from back to front, when we reach it, the subtrees rooted in both its children already satisfy the heap property.If x is greater than both its children, we\u2019re done.Otherwise, we swap x with its biggest child. That makes the new root of the subtree greater than both its children.If x doesn\u2019t satisfy the heap-property in its new subtree, the process will be repeated until it does or becomes a leaf, in which case it won\u2019t have any children.This is true for all nodes in the heap, including the root.Heap-sort algorithmNow for the main course \u2014 heap-sort.Heap-sort works in 2 steps:Builds a max-heap from the input array using the algorithm I showed above. This takes O(n) timePops elements from the heap into the output array, filling it from the back to the front. Every removal of the maximum element from the heap takes O(log n) time, which adds up to O(n * log n) for the entire container.A cool property of the Go implementation, is that it uses the input array to store the output, thus saving the need to allocate O(n) memory for the output.Heap-sort implementationThe Go sort library supports any collection that is indexed by integers, has a defined order relation on its elements, and supports swapping elements between two indices:type Interface interface {\n\t// Len is the number of elements in the collection.\n\tLen() int\n\t// Less reports whether the element with\n\t// index i should sort before the element with index j.\n\tLess(i, j int) bool\n\t// Swap swaps the elements with indexes i and j.\n\tSwap(i, j int)\n}From https://github.com/golang/go/blob/master/src/sort/sort.goNaturally, any contiguous container of numbers can satisfy this interface.Now let\u2019s take a look at the body of heapSort():func heapSort(data Interface, a, b int) {\n\tfirst := a\n\tlo := 0\n\thi := b - a\n\n\t// Build heap with greatest element at top.\n\tfor i := (hi - 1) / 2; i >= 0; i-- {\n\t\tsiftDown(data, i, hi, first)\n\t}\n\n\t// Pop elements, largest first, into end of data.\n\tfor i := hi - 1; i >= 0; i-- {\n\t\tdata.Swap(first, first+i)\n\t\tsiftDown(data, lo, i, first)\n\t}\n}From https://github.com/golang/go/blob/master/src/sort/sort.goThe function\u2019s signature is a bit cryptic, but looking at the first 3 lines clear things up:a and b are indices into data. heapSort(data, a, b) sorts data in the half-open range [a, b).first is a copy of a.lo and high are indices normalized by a \u2014 lo always starts at zero, and hi at the size of the input.Next, the code builds the max-heap:// Build heap with greatest element at top.\nfor i := (hi - 1) / 2; i >= 0; i-- {\n  siftDown(data, i, hi, first)\n}As we saw earlier, the code scans the heap from one level above the leaves and uses siftDown() to propagate the current element down until it satisfies the heap property. I\u2019ll go into siftDown() in more detail below.At this stage, data is a max-heap.Next, we pop all the elements to create the sorted array:// Pop elements, largest first, into end of data.\nfor i := hi - 1; i >= 0; i-- {\n  data.Swap(first, first+i)\n  siftDown(data, lo, i, first)\n}In this loop, i is the last index in the heap. On each iteration:The heap\u2019s maximum first is swapped with the last element of the heap.The heap property is restored by propagating the new first down until it satisfies the heap property.The heap size i is reduced by one.In other words, we are filling the array from the back to the front, starting from the largest element, to the 2nd element in size all the way to the smallest element. The result is the sorted input.Maintaining the heap propertyAlong the post I mentioned using siftDown() to maintain the heap property. Let\u2019s see how it works:// siftDown implements the heap property on data[lo, hi).\n// first is an offset into the array where the root of the heap lies.\nfunc siftDown(data Interface, lo, hi, first int) {\n\troot := lo\n\tfor {\n\t\tchild := 2*root + 1\n\t\tif child >= hi {\n\t\t\tbreak\n\t\t}\n\t\tif child+1 < hi && data.Less(first+child, first+child+1) {\n\t\t\tchild++\n\t\t}\n\t\tif !data.Less(first+root, first+child) {\n\t\t\treturn\n\t\t}\n\t\tdata.Swap(first+root, first+child)\n\t\troot = child\n\t}\n}From https://github.com/golang/go/blob/master/src/sort/sort.goThis code propagates the element in root all the way down the tree until it is larger than both of its children. When going down a level, the element will be swapped with its greater child. That is to make sure that the new parent node is greater than both its children:The parent \u20183\u2019 is swapped with the greatest child \u201810\u2019The first few lines calculate the index of the first child and check that it exists:child := 2*root + 1\nif child >= hi {\n  break\n}\nchild >= hi means that the current root is a leaf, so the algorithm stops.Next, we pick the greater of the two children:if child+1 < hi && data.Less(first+child, first+child+1) {\n  child++\n}Since any node\u2019s children are next to each other in the array, child++ selects the second child.Next, we check if the parent is indeed smaller than the child:if !data.Less(first+root, first+child) {\n  return\n}If the parent is greater than it biggest child, we are done so we return.Lastly, if the parent is smaller than the child we swap the two elements and increment root to prepare for the next iteration:data.Swap(first+root, first+child)\nroot = childConclusionThis is the third article where I read an unfamiliar piece of code and try explain it. I like this kind of experience because it teaches me how to read code and how to communicate about it. Please leave your comments and feedback below!\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 7890, "excerpt": "Heap-sort is a beautiful sorting algorithm. It uses a max-heap to sort a\nsequence of numbers or other elements with a defined order relation. In this\narticle we\u2019ll deep-dive into the Go standard library heap-sort implementation.\n\nMax-heap\nFirst a short recap on binary max-heaps\n[https://en.wikipedia.org/wiki/Heap_(data_structure)]. A max-heap is a container\nthat provides its maximum element in O(1) time, adds an element in O(log n), and\nremoves the maximum element in O(log n).\n\nMax-heaps are alm", "siteName": "freeCodeCamp.org", "publishedTime": "2019-08-12T04:00:00.000Z", "id": "ee335845d5ff314823fd956ecd1e09366da3c811", "url": "https://www.freecodecamp.org/news/reading-challenge-heap-sort-in-go/", "domain": "freecodecamp.org", "date": "2023-12-27T18:08:44.980003", "resultUri": "http://localhost:3000/result/ee335845d5ff314823fd956ecd1e09366da3c811", "query": {"url": ["https://www.freecodecamp.org/news/reading-challenge-heap-sort-in-go/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "How to Implement Heap-Sort in the Go Standard Library", "description": "Heap-sort is a beautiful sorting algorithm. It uses a max-heap to sort a sequence of numbers or other elements with a defined order relation. In this article we\u2019ll deep-dive into the Go standard library heap-sort implementation. Max-heap First a short recap on binary max-heaps [https://en.wikipedia.org/wiki/Heap_(data_structure)]. A max-heap is a container", "url": "https://www.freecodecamp.org/news/reading-challenge-heap-sort-in-go/", "image": "https://www.freecodecamp.org/news/content/images/2019/08/heap_cars.jpeg", "image:width": "2000", "image:height": "1125"}, "twitter": {"card": "summary_large_image", "title": "How to Implement Heap-Sort in the Go Standard Library", "description": "Heap-sort is a beautiful sorting algorithm. It uses a max-heap to sort a sequence of numbers or other elements with a defined order relation. In this article we\u2019ll deep-dive into the Go standard library heap-sort implementation. Max-heap First a short recap on binary max-heaps [https://en.wikipedia.org/wiki/Heap_(data_structure)]. A max-heap is a container", "url": "https://www.freecodecamp.org/news/reading-challenge-heap-sort-in-go/", "image": "https://www.freecodecamp.org/news/content/images/2019/08/heap_cars.jpeg", "label1": "Written by", "data1": "Ehud Tamir", "label2": "Filed under", "data2": "Programming, Go", "site": "@freecodecamp", "creator": "@ehudta"}}}