{"title": "Minimax Algorithm Guide: How to Create an Unbeatable AI", "byline": "Oluwatobi Sofela", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>Minimax Algorithm Guide: How to Create an Unbeatable AI</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>Recently I wondered \u2013 how can I program the computer to be unbeatable in a tic-tac-toe game? </p><p>Well, I thought I could easily get an answer to this question. But as I went back and forth from articles to videos to a series of coding meditations, I only succeeded in becoming more confused. </p><p>However, my \u201cAha!\u201d moment came when I took the time to understand how the <strong>minimax algorithm</strong> works.</p><p>If you are also on a similar path, let me take you through the steps to build an unbeatable AI (Artificial Intelligence).</p><h2 id=\"step-1-understand-the-basics-of-the-minimax-algorithm\">Step 1: Understand the basics of the minimax algorithm</h2><p>A <strong>minimax algorithm</strong> is a <a href=\"https://www.codesweetly.com/recursion/\">recursive</a> program written to find the best gameplay that minimizes any tendency to lose a game while maximizing any opportunity to win the game.</p><p>Graphically, we can represent minimax as an exploration of a <a href=\"https://en.wikipedia.org/wiki/Game_tree\">game tree's</a> <a href=\"https://en.wikipedia.org/wiki/Node_(computer_science)\">nodes</a> to discover the best game move to make. In such a case, the tree's root is the game's current state \u2014 where the minimax algorithm got invoked.</p><figure><img alt=\"Tic-tac-toe game tree\" height=\"1016\" loading=\"lazy\" sizes=\"(min-width: 1200px) 1200px\" src=\"https://www.freecodecamp.org/news/content/images/2020/12/game-tree-for-tic-tac-toe-minimax-codesweetly.png\" srcset=\"https://www.freecodecamp.org/news/content/images/size/w600/2020/12/game-tree-for-tic-tac-toe-minimax-codesweetly.png 600w, https://www.freecodecamp.org/news/content/images/size/w1000/2020/12/game-tree-for-tic-tac-toe-minimax-codesweetly.png 1000w, https://www.freecodecamp.org/news/content/images/2020/12/game-tree-for-tic-tac-toe-minimax-codesweetly.png 1600w\" width=\"1600\"/><figcaption>Figure 1: The game tree of a concluding tic-tac-toe game</figcaption></figure><p>Our focus in this guide is to use minimax to create an unbeatable AI for a tic-tac-toe game. However, <a href=\"https://en.wikipedia.org/wiki/Minimax\">you can also use it for complex games</a>, like chess, and general decision-making to resolve any uncertainties.</p><p>In most cases, the player that initially invokes minimax is called the <em>maximizing player</em>. In other words, the original invocator of minimax is the player that wants to maximize any opportunity to win the game.</p><p>In contrast, the maximizing player\u2019s opponent is called the <em>minimizing player</em>. As such, the minimizing player is the player whose chances of winning must be minimized.</p><p>In short, a minimax algorithm is a recursive function created to help a player (the maximizer) decide on the gameplay that <em>minimizes</em> the <em>maximum</em> possibility to lose a game.</p><h2 id=\"step-2-get-familiar-with-this-tutorial-s-root-node\">Step 2: Get familiar with this tutorial\u2019s root node</h2><p>To make this tutorial precise, the root node (the current state of the tic-tac-toe game) we will use will be a near-the-end state game board \u2014 as shown in figure 2 below. </p><p>Also, the <strong>X</strong> mark will represent the AI\u2019s mark, while the <strong>O</strong> mark will be the human player\u2019s mark.</p><figure><img alt=\"The initial state of this tutorial's tic-tac-toe board\" height=\"489\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2020/12/root-node-for-tic-tac-toe-minimax-tutorial-codesweetly.png\" width=\"500\"/><figcaption>Figure 2: This tutorial\u2019s root node</figcaption></figure><p>In the current stage of the tic-tac-toe game (as shown in figure 2 above), it\u2019s <strong>X</strong>\u2019s turn to play (that is, the AI\u2019s turn). And since there are three empty cells on the board, it implies that <strong>X</strong> has three possible play choices \u2014 top-middle, center, or bottom-right. </p><p>But which is the best choice? Which move will best help <strong>X</strong> minimize the maximum possibility of losing the game?</p><figure><img alt=\"AI player's possible moves\" height=\"609\" loading=\"lazy\" sizes=\"(min-width: 720px) 720px\" src=\"https://www.freecodecamp.org/news/content/images/2020/12/ai-player-first-possible-moves-minimax-tic-tac-toe-codesweetly.png\" srcset=\"https://www.freecodecamp.org/news/content/images/size/w600/2020/12/ai-player-first-possible-moves-minimax-tic-tac-toe-codesweetly.png 600w, https://www.freecodecamp.org/news/content/images/2020/12/ai-player-first-possible-moves-minimax-tic-tac-toe-codesweetly.png 1000w\" width=\"1000\"/><figcaption>Figure 3: AI player\u2019s possible play choices</figcaption></figure><p>To make the best decision, the AI needs to do the following:</p><ol><li>Store the current state (values) of the tic-tac-toe board in an array. (For any empty cell, the cell\u2019s index will get stored as its present content).</li><li>Get an array list of <em>only the empty cells\u2019</em> indexes.</li><li>Check and confirm if a specific player has won the game.</li><li><a href=\"https://www.codesweetly.com/recursion/\">Recursively</a> invoke <em>minimax</em> on each of the board\u2019s empty cells.</li><li>Return a score for every possible move for both player <strong>X</strong> and player <strong>O</strong>.</li><li>Out of all the returned scores, choose the best one (the highest) that is guaranteed to minimize the human player\u2019s possibilities of winning the game.</li></ol><p>Therefore, in the following steps below, we will configure the AI to accomplish the list above. So, let\u2019s get started by storing the board\u2019s current state in an array.</p><h2 id=\"step-3-store-the-board-s-current-state-in-an-array\">Step 3: Store the board\u2019s current state in an array</h2><p>Our next step is to store the current content of each of the board's cells in an array like so:</p><pre tabindex=\"0\"><code>const currentBoardState = [\"X\", 1, \"O\", \"X\", 4, \"X\", \"O\", \"O\", 8];</code></pre><ul><li>The current state of our tic-tac-toe board is still as illustrated in figure 2.</li><li>The values <code>1</code>, <code>4</code>, and <code>8</code> in the <code>currentBoardState</code> array are the board's empty cells' index numbers. In other words, instead of using empty strings, we chose to store the empty cells' current content as their respective indexes.</li></ul><p>Importantly, before moving to the next step, let us explicitly define whose mark is <code>\u201cX\u201d</code> and who owns <code>\u201cO\u201d</code>.</p><pre tabindex=\"0\"><code>const aiMark = \"X\";\nconst humanMark = \"O\";</code></pre><p>The two statements above denote that the AI\u2019s mark is <strong>X</strong> while the human player\u2019s mark is <strong>O</strong>.</p><h2 id=\"step-4-create-a-function-to-get-the-indexes-of-all-the-empty-cells\">Step 4: Create a function to get the indexes of all the empty cells</h2><p>The function below will filter the <code>currentBoardState</code> array \u2014 which will be passed-in as the function\u2019s parameter\u2019s argument. It will then return a new array containing all the <code>currentBoardState</code> array\u2019s items that are neither <code>\u201cX\u201d</code> nor <code>\u201cO\u201d</code>.</p><pre tabindex=\"0\"><code>function getAllEmptyCellsIndexes(currBdSt) {\n    return currBdSt.filter(i =&gt; i != \"X\" &amp;&amp; i != \"O\");\n}</code></pre><p><strong>Note:</strong> Remember that the <code>currentBoardState</code> array we created in step 3 contains only the values <code>\u201cX\u201d</code>, <code>\u201cO\u201d</code>, and <em>the board's empty cells' indexes</em>. Therefore, the <code>getAllEmptyCellsIndexes()</code> function above filters out any occurrence of an index in the <code>currentBoardState</code> array.</p><h2 id=\"step-5-create-a-winner-determiner-function\">Step 5: Create a winner determiner function</h2><p>The primary purpose of the <em>winner determiner function</em> below is to receive a <code>currentBoardState</code> array and a specific player\u2019s mark (either mark <code>\u201cX\u201d</code> or <code>\u201cO\u201d</code>) as its parameters\u2019 arguments. </p><p>Then, it checks if the received mark forms a winning combination on the tic-tac-toe board. If so, the Boolean value <code>true</code> is returned \u2014 otherwise, <code>false</code> is returned.</p><pre tabindex=\"0\"><code>function checkIfWinnerFound(currBdSt, currMark) {\n    if (\n        (currBdSt[0] === currMark &amp;&amp; currBdSt[1] === currMark &amp;&amp; currBdSt[2] === currMark) ||\n        (currBdSt[3] === currMark &amp;&amp; currBdSt[4] === currMark &amp;&amp; currBdSt[5] === currMark) ||\n        (currBdSt[6] === currMark &amp;&amp; currBdSt[7] === currMark &amp;&amp; currBdSt[8] === currMark) ||\n        (currBdSt[0] === currMark &amp;&amp; currBdSt[3] === currMark &amp;&amp; currBdSt[6] === currMark) ||\n        (currBdSt[1] === currMark &amp;&amp; currBdSt[4] === currMark &amp;&amp; currBdSt[7] === currMark) ||\n        (currBdSt[2] === currMark &amp;&amp; currBdSt[5] === currMark &amp;&amp; currBdSt[8] === currMark) ||\n        (currBdSt[0] === currMark &amp;&amp; currBdSt[4] === currMark &amp;&amp; currBdSt[8] === currMark) ||\n        (currBdSt[2] === currMark &amp;&amp; currBdSt[4] === currMark &amp;&amp; currBdSt[6] === currMark)\n    ) {\n        return true;\n    } else {\n        return false;\n    }\n}</code></pre><h2 id=\"step-6-create-the-minimax-algorithm\">Step 6: Create the minimax algorithm</h2><p>A <strong>minimax algorithm</strong> is just an ordinary function that contains statements to be executed once the function is invoked. Therefore, the process of creating the algorithm is the same as creating any other function. So, let\u2019s create one now.</p><pre tabindex=\"0\"><code>function minimax(currBdSt, currMark) {\n    \n    // Space for the minimax\u2019s statements \n    \n}</code></pre><p>That\u2019s it! We\u2019ve created a <strong>minimax</strong> function \u2014 albeit an empty one. Our next step is to fill up the function with statements that will be executed once the function is invoked \u2014 which we will do below.</p><p><strong>Note:</strong> The minimax function created above is designed to accept <em>two arguments</em>.<br/>The first is <em>an array</em> list of the current board\u2019s content \u2014 that is, the present value of the <code>currentBoardState</code> array. While the second argument is <em>the mark</em> of the player currently running the minimax algorithm \u2014 that is, mark <code>\u201cX\u201d</code> or mark <code>\u201cO\u201d</code>.</p><h2 id=\"step-7-first-minimax-invocation\">Step 7: First minimax invocation</h2><p>To avoid any confusion later in this tutorial, let\u2019s invoke our minimax function for the first time \u2014 while passing-in the <code>currentBoardState</code> array and the <code>aiMark</code> as the function\u2019s arguments.</p><pre tabindex=\"0\"><code>const bestPlayInfo = minimax(currentBoardState, aiMark);</code></pre><h2 id=\"step-8-store-the-indexes-of-all-empty-cells\">Step 8: Store the indexes of all empty cells</h2><p>In this step, we will invoke the <code>getAllEmptyCellsIndexes</code> function that we created at step 4 \u2014 while passing-in the <code>currentBoardState</code> array as the function\u2019s argument. </p><p>Then, we will store the <em>returned</em> array list of indexes inside a variable named <code>availCellsIndexes</code>.</p><pre tabindex=\"0\"><code>const availCellsIndexes = getAllEmptyCellsIndexes(currBdSt);</code></pre><h2 id=\"step-9-check-if-there-is-a-terminal-state\">Step 9: Check if there is a terminal state</h2><p>At this stage, we need to verify if there is a terminal state (that is, a loss state, a win state, or a draw state) on the tic-tac-toe board. We will accomplish this verification by invoking the <em>winner determiner function</em> (created in step 5) for each of the players.</p><p>If the function finds a win state for the human player (the minimizer), it will return <code>-1</code> (which signifies that the human player has won, and the AI has lost). But if it finds a win state for the AI player (the maximizer), it will return <code>+1</code> (which indicates that the AI has won, and the human player has lost).</p><p>However, suppose the winner determiner function cannot find any empty cell on the board or any win state for either player. In that case, it will return <code>0</code> (zero) \u2014 which signifies that the game has ended in a tie.</p><p><strong>Note:</strong> The scores (<code>-1</code>, <code>+1</code>, and <code>0</code>) indicated above are <a href=\"https://www.vocabulary.com/dictionary/heuristic\">heuristic</a> values \u2014 which means that we will still get the same result if we prefer to use -25, +25, and 0.</p><p>Let\u2019s now proceed to implement the terminal state verification by using an <em>if statement</em> like so:</p><pre tabindex=\"0\"><code>if (checkIfWinnerFound(currBdSt, humanMark)) {\n    return {score: -1};\n} else if (checkIfWinnerFound(currBdSt, aiMark)) {\n    return {score: 1};\n} else if (availCellsIndexes.length === 0) {\n    return {score: 0};\n}</code></pre><p>When there is a terminal state (lose, win, or draw), the active minimax function will return the appropriate terminal state score (<code>-1</code>, <code>+1</code>, or <code>0</code>) and end its invocation.</p><p>If the active minimax ends its invocation here, the algorithm will move on to step 12.</p><p>However, when there is <em>no</em> terminal state, the active minimax function will execute the next statement (step 10, below).</p><h2 id=\"step-10-get-ready-to-test-the-outcome-of-playing-the-current-player-s-mark-on-each-empty-cell\">Step 10: Get ready to test the outcome of playing the current player\u2019s mark on each empty cell</h2><p>As step 9 found no terminal state, we have to devise a way to test what will happen if the current player (who is to make the next game move) plays on each empty cell.</p><p>In other words, if the current player plays on the first available cell, and the opponent plays on the second empty cell, will the current player win, lose, or draw the game? Or will there still be no terminal state found?</p><p>Alternatively, what will happen if the current player plays on the second available cell, and the opponent plays on the first empty cell?</p><p>Or perhaps, will the third available cell be the best spot for the current player to play?</p><p>This test drive is what we need to do now. But before we begin, we need a place to record each test's outcome \u2014 so let\u2019s do that first by creating an array named <code>allTestPlayInfos</code>.</p><pre tabindex=\"0\"><code>const allTestPlayInfos = [];</code></pre><p>So, now that we have secured a place to store each test drive\u2019s result, let\u2019s begin the trials by creating a <em>for-loop statement</em> that will loop through each of the empty cells starting from the first one.</p><pre tabindex=\"0\"><code>for (let i = 0; i &lt; availCellsIndexes.length; i++) {\n    \n    // Space for the for-loop\u2019s codes\n    \n}</code></pre><p>In the next two steps, we will fill up the for-loop with the code it should run for each empty cell.</p><h2 id=\"step-11-test-play-the-current-player-s-mark-on-the-empty-cell-the-for-loop-is-currently-processing\">Step 11: Test-play the current player\u2019s mark on the empty cell the for-loop is currently processing</h2><p>Before doing anything in this step, let\u2019s review the current state of our board.</p><figure><img alt=\"Current tic-tac-toe board\" height=\"548\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2020/12/current-tic-tac-toe-minimax-board-codesweetly.png\" width=\"500\"/><figcaption>Figure 4: The current state of the tic-tac-toe board</figcaption></figure><p>Notice that the above board is still the same as that of figure 2, except that we\u2019ve highlighted \u2014 in red \u2014 the cell the for-loop is currently processing.</p><p>Next, it will be helpful to have a place to store this test-play\u2019s terminal score \u2014 so let\u2019s create an object like so:</p><pre tabindex=\"0\"><code>const currentTestPlayInfo = {};</code></pre><p>Also, before test-playing the current player\u2019s mark on the red cell, let\u2019s save the cell\u2019s index number \u2014 so that it will be easy to reset the cell\u2019s info after this test-play.</p><pre tabindex=\"0\"><code>currentTestPlayInfo.index = currBdSt[availCellsIndexes[i]];</code></pre><p>Let\u2019s now place the current player\u2019s mark on the red cell (that is, the cell currently being processed by the for-loop).</p><pre tabindex=\"0\"><code>currBdSt[availCellsIndexes[i]] = currMark;</code></pre><p>Based on the current player\u2019s gameplay, the board\u2019s state will change to reflect its latest move.</p><figure><img alt=\"New tic-tac-toe board\" height=\"602\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2020/12/ai-latest-move-tic-tac-toe-minimax-board-codesweetly.png\" width=\"500\"/><figcaption>Figure 5: The new board \u2014 which reflects the current player\u2019s latest move</figcaption></figure><p>Therefore, since the board\u2019s state has changed, we need to recursively run minimax on the new board \u2014 while passing in the new board's state and the next player's mark.</p><pre tabindex=\"0\"><code>if (currMark === aiMark) {\n    const result = minimax(currBdSt, humanMark);\n    currentTestPlayInfo.score = result.score;\n} else {\n    const result = minimax(currBdSt, aiMark);\n    currentTestPlayInfo.score = result.score;\n}</code></pre><ul><li>The recursive invocation of minimax at this very point will be the _____ time we are invoking the function. The first invocation happened in step 7.</li><li>This recursive invocation will cause the reiteration of steps 8 to 11.</li><li>Suppose there is a terminal state at step 9. In that case, the current minimax invocation will stop running \u2014 and store the returned terminal object (for example, <code>{score: 1}</code>) in the <code>result</code> variable.</li><li>Once there is a terminal state, step 12 will be the next step.</li><li>If there exists <em>no</em> terminal state, a <strong>second for-loop</strong> will begin for the new board at step 10.</li><li>If step 10 is repeated, please replace figure 4\u2019s board with the new board in figure 5. However, the cell highlighted in red will now be the cell the for-loop is currently processing. So please, do reflect the changes accordingly.</li></ul><h2 id=\"step-12-save-the-latest-terminal-score\">Step 12: Save the latest terminal score</h2><p>After the just concluded minimax invocation has returned its terminal state's value, the active for-loop will save the <code>result</code> variable's score into the <code>currentTestPlayInfo</code> object like so:</p><pre tabindex=\"0\"><code>currentTestPlayInfo.score = result.score;</code></pre><p>Then, since the returned score officially ends the current test-play, it is best to reset the current board back to the state before the current player made its move.</p><pre tabindex=\"0\"><code>currBdSt[availCellsIndexes[i]] = currentTestPlayInfo.index;</code></pre><p>Also, we need to save the result of the current player\u2019s test-play for future use. So, let\u2019s do that by pushing the <code>currentTestPlayInfo</code> object to the <code>allTestPlayInfos</code> array like so:</p><pre tabindex=\"0\"><code>allTestPlayInfos.push(currentTestPlayInfo);</code></pre><ul><li>If you got to this step from step 17, kindly continue this tutorial at <em>step 18</em>. Otherwise, consider the next point.</li><li>If the active for-loop has finished looping through all the current board's empty cells, the loop will end at this point, and <em>step 14</em> will be next. Otherwise, the loop will proceed to process the next available cell (step 13).</li></ul><h2 id=\"step-13-run-the-active-for-loop-on-the-next-empty-cell\">Step 13: Run the active for-loop on the next empty cell</h2><p>Remember that the currently active for-loop (that began at step 10) has only finished its work for the preceding empty cell(s). Therefore, the loop will proceed to test-play the current player\u2019s mark on the next free cell. </p><p>In other words, the currently running minimax function will repeat steps <strong>11</strong> and <strong>12</strong>. But, essentially, take note of the following:</p><ul><li>The red cell highlighted in figure 4 will change to the cell the for-loop is currently processing.</li><li>Please, be mindful that figure 5 will also change. In other words, the current player\u2019s move will now be on the cell the for-loop is currently processing.</li><li>After the active for-loop has completed its work, the <code>allTestPlayInfos</code> array will contain specific objects for each empty cell the for-loop has processed.</li><li>Each of the objects in the <code>allTestPlayInfos</code> array will contain an <code>index</code> property and a <code>score</code> property (take for example: <code>{index: 8, score: -1}</code>).</li><li>If you got to this step from step 20, then, <em>on completing step 12</em>, kindly continue this tutorial at <em>step 18</em>.</li></ul><h2 id=\"step-14-plan-how-to-get-the-object-with-the-best-test-play-score-for-the-current-player\">Step 14: Plan how to get the object with the best test-play score for the current player</h2><p>Immediately after the for-loop has completed its work of looping through all the empty cells of the current board, minimax will:</p><ol><li><strong>Create a space</strong> to store the reference number that will later help to get the best test-play object.</li><li><strong>Get the reference number</strong> to the current player\u2019s best test-play.</li><li><strong>Use the acquired reference number</strong> to get the object with the best test-play for the current player.</li></ol><p>Without any further ado, let\u2019s implement this plan in the next few steps.</p><h2 id=\"step-15-create-a-store-for-the-best-test-play-s-reference\">Step 15: Create a store for the best test-play\u2019s reference</h2><p>The variable below is the place we will later store the reference to the best test-play object. (Note that the value <code>null</code> indicates that we have deliberately left the variable empty).</p><pre tabindex=\"0\"><code>let bestTestPlay = null;</code></pre><h2 id=\"step-16-get-the-reference-to-the-current-player-s-best-test-play\">Step 16: Get the reference to the current player\u2019s best test-play</h2><p>Now that there is a <code>bestTestPlay</code> store, the active minimax function can proceed to get the reference to the current player\u2019s best test-play like so:</p><pre tabindex=\"0\"><code>if (currMark === aiMark) {\n    let bestScore = -Infinity;\n    for (let i = 0; i &lt; allTestPlayInfos.length; i++) {\n        if (allTestPlayInfos[i].score &gt; bestScore) {\n            bestScore = allTestPlayInfos[i].score;\n            bestTestPlay = i;\n        }\n    }\n} else {\n    let bestScore = Infinity;\n    for (let i = 0; i &lt; allTestPlayInfos.length; i++) {\n        if (allTestPlayInfos[i].score &lt; bestScore) {\n            bestScore = allTestPlayInfos[i].score;\n            bestTestPlay = i;\n        }\n    }\n}</code></pre><p>The code above means if the current mark is equal to the AI player\u2019s mark:</p><ol><li>Create a <code>bestScore</code> variable with the value of <code>-Infinity</code>. (Note that this value is just a placeholder value that needs to be <em>less than</em> all the scores in the <code>allTestPlayInfos</code> array. Therefore, using <code>-700</code> will do the same job).</li><li>Then, for every test-play object in the <code>allTestPlayInfos</code> array, check if the test-play the loop is currently processing has a <em>higher</em> score than the current <code>bestScore</code>. If so, record that test-play\u2019s details inside both the <code>bestScore</code> variable and the <code>bestTestPlay</code> variable.</li></ol><p>Otherwise, if the current mark is the human player\u2019s mark:</p><ol><li>Create a <code>bestScore</code> variable with the value of <code>+Infinity</code>. (Again, note that we will get the same outcome if we had preferred to use <code>+300</code>. It is just a placeholder value that needs to be <em>greater than</em> all the scores in the <code>allTestPlayInfos</code> array).</li><li>Then, for every test-play object in the <code>allTestPlayInfos</code> array, check if the test-play the loop is currently processing has a <em>lesser</em> score than the current <code>bestScore</code>. If so, record that test-play\u2019s details inside both the <code>bestScore</code> variable and the <code>bestTestPlay</code> variable.</li></ol><h2 id=\"step-17-get-the-object-with-the-best-test-play-score-for-the-current-player\">Step 17: Get the object with the best test-play score for the current player</h2><p>Finally, the currently running minimax invocation can now finish its work by returning the object with the best test-play for the current player like so:</p><pre tabindex=\"0\"><code>return allTestPlayInfos[bestTestPlay];</code></pre><p>Note that minimax will store the returned object inside the <code>result</code> variable of the first for-loop that began at step 11. It will then repeat step 12. Please revisit step 12 only. Then, continue this tutorial below.</p><h2 id=\"step-18-let-s-do-a-review\">Step 18: Let\u2019s do a review</h2><p>This stage is an excellent time to review what we've done thus far pictorially.</p><ul><li>If this is your first time on this step, please use the diagram in <em>step 19</em>.</li><li>Is this your second time on this step? If so, the diagram in <em>step 21</em> is yours.</li><li>Are you here for the third time? Well-done! Check out the diagram in <em>step 23</em>.</li></ul><h2 id=\"step-19-tracing-our-steps-with-a-diagram\">Step 19: Tracing our steps with a diagram</h2><p>The diagram below shows the AI and the human player's <em>first test-play</em> for the first for-loop invocation initiated by the AI player.</p><figure><img alt=\"First tic-tac-toe test-play\" height=\"1016\" loading=\"lazy\" sizes=\"(min-width: 1200px) 1200px\" src=\"https://www.freecodecamp.org/news/content/images/2020/12/tic-tac-toe-minimax-first-test-play-codesweetly-1.png\" srcset=\"https://www.freecodecamp.org/news/content/images/size/w600/2020/12/tic-tac-toe-minimax-first-test-play-codesweetly-1.png 600w, https://www.freecodecamp.org/news/content/images/size/w1000/2020/12/tic-tac-toe-minimax-first-test-play-codesweetly-1.png 1000w, https://www.freecodecamp.org/news/content/images/2020/12/tic-tac-toe-minimax-first-test-play-codesweetly-1.png 1600w\" width=\"1600\"/><figcaption>Figure 6: First test-play which predicts a loss state for the AI (maximizer)</figcaption></figure><h2 id=\"step-20-the-first-for-loop-moves-forward-to-process-the-next-empty-cell\">Step 20: The first for-loop moves forward to process the next empty cell</h2><p>On concluding that playing on the first empty cell will end in a loss state, the AI forges ahead to test the outcome of playing on the <em>second free cell</em> by repeating step 13.</p><h2 id=\"step-21-tracing-our-steps-with-a-diagram\">Step 21: Tracing our steps with a diagram</h2><p>The diagram below shows the AI and the human player's <em>second test-play</em> for the first for-loop invocation initiated by the AI player.</p><figure><img alt=\"Second tic-tac-toe test-play\" height=\"1016\" loading=\"lazy\" sizes=\"(min-width: 1200px) 1200px\" src=\"https://www.freecodecamp.org/news/content/images/2020/12/tic-tac-toe-minimax-second-test-play-codesweetly-1.png\" srcset=\"https://www.freecodecamp.org/news/content/images/size/w600/2020/12/tic-tac-toe-minimax-second-test-play-codesweetly-1.png 600w, https://www.freecodecamp.org/news/content/images/size/w1000/2020/12/tic-tac-toe-minimax-second-test-play-codesweetly-1.png 1000w, https://www.freecodecamp.org/news/content/images/2020/12/tic-tac-toe-minimax-second-test-play-codesweetly-1.png 1600w\" width=\"1600\"/><figcaption>Figure 7: Second test-play which predicts a win state for the AI (maximizer)</figcaption></figure><h2 id=\"step-22-the-first-for-loop-moves-forward-to-process-the-next-empty-cell\">Step 22: The first for-loop moves forward to process the next empty cell</h2><p>Now that the AI has confirmed that playing on the second empty cell will result in a win state, it further checks the outcome of playing on the <em>third free cell</em> by repeating step 13.</p><h2 id=\"step-23-tracing-our-steps-with-a-diagram\">Step 23: Tracing our steps with a diagram</h2><p>The diagram below shows the AI and the human player's <em>third test-play</em> for the first for-loop invocation initiated by the AI player.</p><figure><img alt=\"Third tic-tac-toe test-play\" height=\"1016\" loading=\"lazy\" sizes=\"(min-width: 1200px) 1200px\" src=\"https://www.freecodecamp.org/news/content/images/2020/12/tic-tac-toe-minimax-third-test-play-codesweetly-1.png\" srcset=\"https://www.freecodecamp.org/news/content/images/size/w600/2020/12/tic-tac-toe-minimax-third-test-play-codesweetly-1.png 600w, https://www.freecodecamp.org/news/content/images/size/w1000/2020/12/tic-tac-toe-minimax-third-test-play-codesweetly-1.png 1000w, https://www.freecodecamp.org/news/content/images/2020/12/tic-tac-toe-minimax-third-test-play-codesweetly-1.png 1600w\" width=\"1600\"/><figcaption>Figure 8: Third test-play which predicts a loss state for the AI (maximizer)</figcaption></figure><h2 id=\"step-24-get-the-object-with-the-best-test-play-score-for-the-ai-player\">Step 24: Get the object with the best test-play score for the AI player</h2><p>At this point (after the third test-play), the first for-loop would have processed all the three empty cells of the first board (passed-in to minimax at step 7). </p><p>Therefore, minimax will forge ahead to get the object with the best test-play for the AI player \u2014 by repeating steps 15 to 17. However, <em>when at step 17</em>, kindly note the following:</p><ul><li>The returned object will now get stored in the <code>bestPlayInfo</code> variable that we created at step 7.</li><li>Minimax will not repeat step 12 because the for-loop statement is no longer active.</li></ul><figure><img alt=\"Overview of all tic-tac-toe test-plays and scores\" height=\"1016\" loading=\"lazy\" sizes=\"(min-width: 1200px) 1200px\" src=\"https://www.freecodecamp.org/news/content/images/2020/12/tic-tac-toe-minimax-view-of-all-test-plays-codesweetly-1.png\" srcset=\"https://www.freecodecamp.org/news/content/images/size/w600/2020/12/tic-tac-toe-minimax-view-of-all-test-plays-codesweetly-1.png 600w, https://www.freecodecamp.org/news/content/images/size/w1000/2020/12/tic-tac-toe-minimax-view-of-all-test-plays-codesweetly-1.png 1000w, https://www.freecodecamp.org/news/content/images/2020/12/tic-tac-toe-minimax-view-of-all-test-plays-codesweetly-1.png 1600w\" width=\"1600\"/><figcaption>Figure 9: Overview of all test-plays and scores</figcaption></figure><h2 id=\"step-25-use-the-data-inside-bestplayinfo\">Step 25: Use the data inside bestPlayInfo</h2><p>Considering this tutorial\u2019s board (a near-the-end state game board \u2014 as shown in figure 2 of step 2), the object in the <code>bestPlayInfo</code> variable will be <code>{index: 4, score: 1}</code>. Therefore, the AI can now use its index value to choose the best cell to play on.</p><h3 id=\"example\">Example</h3><pre tabindex=\"0\"><code>// Get all the board\u2019s cells:\nconst gameCells = document.querySelectorAll(\".cell\");\n\n// Below is the variable we created at step 3:\nconst aiMark = \"X\";\n\n// Here is the bestPlayInfo we created at step 7 to contain the best test-play object for the AI player:\nconst bestPlayInfo = minimax(currentBoardState, aiMark);\n\n// Play the AI\u2019s mark on the cell that is best for it:\ngameCells[bestPlayInfo.index].innerText = aiMark;</code></pre><p>Therefore, the AI player will win the game, and the new board will now look like so:</p><figure><img alt=\"AI's winning move\" height=\"536\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2020/12/ai-winning-move-tic-tac-toe-minimax-board-codesweetly.png\" width=\"500\"/><figcaption>Figure 10: Final gameboard showing that the AI (player X) has won the game</figcaption></figure><h2 id=\"step-26-a-bird-s-eye-view-of-this-tutorial-s-algorithm\">Step 26: A bird\u2019s-eye view of this tutorial\u2019s algorithm</h2><p>Below is this tutorial\u2019s minimax algorithm in one piece. Feel free to insert it into your editor. Play around with it for various game scenarios, and use the console to test, test, and test it again until you are comfortable building an unbeatable AI. </p><p>And remember, programming is better only when you <a href=\"https://www.codesweetly.com/\">code sweetly</a> \u2014 so have lots of fun with it!</p><pre tabindex=\"0\"><code>// Step 3 - Store the board\u2019s current state in an array and define each mark's owner:\nconst currentBoardState = [\"X\", 1, \"O\", \"X\", 4, \"X\", \"O\", \"O\", 8];\nconst aiMark = \"X\";\nconst humanMark = \"O\";\n\n// Step 4 - Create a function to get the indexes of all the empty cells:\nfunction getAllEmptyCellsIndexes(currBdSt) {\n    return currBdSt.filter(i =&gt; i != \"O\" &amp;&amp; i != \"X\");\n}\n\n// Step 5 - Create a winner determiner function:\nfunction checkIfWinnerFound(currBdSt, currMark) {\n    if (\n        (currBdSt[0] === currMark &amp;&amp; currBdSt[1] === currMark &amp;&amp; currBdSt[2] === currMark) ||\n        (currBdSt[3] === currMark &amp;&amp; currBdSt[4] === currMark &amp;&amp; currBdSt[5] === currMark) ||\n        (currBdSt[6] === currMark &amp;&amp; currBdSt[7] === currMark &amp;&amp; currBdSt[8] === currMark) ||\n        (currBdSt[0] === currMark &amp;&amp; currBdSt[3] === currMark &amp;&amp; currBdSt[6] === currMark) ||\n        (currBdSt[1] === currMark &amp;&amp; currBdSt[4] === currMark &amp;&amp; currBdSt[7] === currMark) ||\n        (currBdSt[2] === currMark &amp;&amp; currBdSt[5] === currMark &amp;&amp; currBdSt[8] === currMark) ||\n        (currBdSt[0] === currMark &amp;&amp; currBdSt[4] === currMark &amp;&amp; currBdSt[8] === currMark) ||\n        (currBdSt[2] === currMark &amp;&amp; currBdSt[4] === currMark &amp;&amp; currBdSt[6] === currMark)\n) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// Step 6 - Create the minimax algorithm:\nfunction minimax(currBdSt, currMark) {\n    // Step 8 - Store the indexes of all empty cells:\n    const availCellsIndexes = getAllEmptyCellsIndexes(currBdSt);\n    \n    // Step 9 - Check if there is a terminal state:\n    if (checkIfWinnerFound(currBdSt, humanMark)) {\n        return {score: -1};\n    } else if (checkIfWinnerFound(currBdSt, aiMark)) {\n        return {score: 1};\n    } else if (availCellsIndexes.length === 0) {\n        return {score: 0};\n    }\n    \n    // Step 10 - Create a place to record the outcome of each test drive:\n    const allTestPlayInfos = [];\n    \n    // Step 10 - Create a for-loop statement that will loop through each of the empty cells:\n    for (let i = 0; i &lt; availCellsIndexes.length; i++) {\n        // Step 11 - Create a place to store this test-play\u2019s terminal score:\n        const currentTestPlayInfo = {};\n        \n        // Step 11 - Save the index number of the cell this for-loop is currently processing:\n        currentTestPlayInfo.index = currBdSt[availCellsIndexes[i]];\n        \n        // Step 11 - Place the current player\u2019s mark on the cell for-loop is currently processing:\n        currBdSt[availCellsIndexes[i]] = currMark;\n        \n        if (currMark === aiMark) {\n            // Step 11 - Recursively run the minimax function for the new board:\n            const result = minimax(currBdSt, humanMark);\n            \n            // Step 12 - Save the result variable\u2019s score into the currentTestPlayInfo object:\n            currentTestPlayInfo.score = result.score;\n        } else {\n            // Step 11 - Recursively run the minimax function for the new board:\n            const result = minimax(currBdSt, aiMark);\n            \n            // Step 12 - Save the result variable\u2019s score into the currentTestPlayInfo object:\n            currentTestPlayInfo.score = result.score;\n        }\n        \n        // Step 12 - Reset the current board back to the state it was before the current player made its move:\n        currBdSt[availCellsIndexes[i]] = currentTestPlayInfo.index;\n        \n        // Step 12 - Save the result of the current player\u2019s test-play for future use:\n        allTestPlayInfos.push(currentTestPlayInfo);\n    }\n    \n    // Step 15 - Create a store for the best test-play\u2019s reference:\n    let bestTestPlay = null;\n    \n    // Step 16 - Get the reference to the current player\u2019s best test-play:\n    if (currMark === aiMark) {\n        let bestScore = -Infinity;\n        for (let i = 0; i &lt; allTestPlayInfos.length; i++) {\n            if (allTestPlayInfos[i].score &gt; bestScore) {\n                bestScore = allTestPlayInfos[i].score;\n                bestTestPlay = i;\n            }\n        }\n    } else {\n        let bestScore = Infinity;\n        for (let i = 0; i &lt; allTestPlayInfos.length; i++) {\n            if (allTestPlayInfos[i].score &lt; bestScore) {\n                bestScore = allTestPlayInfos[i].score;\n                bestTestPlay = i;\n            }\n        }\n    }\n    \n    // Step 17 - Get the object with the best test-play score for the current player:\n    return allTestPlayInfos[bestTestPlay];\n} \n\n// Step 7 - First minimax invocation:\nconst bestPlayInfo = minimax(currentBoardState, aiMark);</code></pre><h2 id=\"useful-resource\">Useful resource</h2><ul><li><a href=\"https://www.codesweetly.com/recursion/\">Recursion: What You Need to Know about Recursion</a></li></ul>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nRecently I wondered \u2013 how can I program the computer to be unbeatable in a tic-tac-toe game? Well, I thought I could easily get an answer to this question. But as I went back and forth from articles to videos to a series of coding meditations, I only succeeded in becoming more confused. However, my \u201cAha!\u201d moment came when I took the time to understand how the minimax algorithm works.If you are also on a similar path, let me take you through the steps to build an unbeatable AI (Artificial Intelligence).Step 1: Understand the basics of the minimax algorithmA minimax algorithm is a recursive program written to find the best gameplay that minimizes any tendency to lose a game while maximizing any opportunity to win the game.Graphically, we can represent minimax as an exploration of a game tree's nodes to discover the best game move to make. In such a case, the tree's root is the game's current state \u2014 where the minimax algorithm got invoked.Figure 1: The game tree of a concluding tic-tac-toe gameOur focus in this guide is to use minimax to create an unbeatable AI for a tic-tac-toe game. However, you can also use it for complex games, like chess, and general decision-making to resolve any uncertainties.In most cases, the player that initially invokes minimax is called the maximizing player. In other words, the original invocator of minimax is the player that wants to maximize any opportunity to win the game.In contrast, the maximizing player\u2019s opponent is called the minimizing player. As such, the minimizing player is the player whose chances of winning must be minimized.In short, a minimax algorithm is a recursive function created to help a player (the maximizer) decide on the gameplay that minimizes the maximum possibility to lose a game.Step 2: Get familiar with this tutorial\u2019s root nodeTo make this tutorial precise, the root node (the current state of the tic-tac-toe game) we will use will be a near-the-end state game board \u2014 as shown in figure 2 below. Also, the X mark will represent the AI\u2019s mark, while the O mark will be the human player\u2019s mark.Figure 2: This tutorial\u2019s root nodeIn the current stage of the tic-tac-toe game (as shown in figure 2 above), it\u2019s X\u2019s turn to play (that is, the AI\u2019s turn). And since there are three empty cells on the board, it implies that X has three possible play choices \u2014 top-middle, center, or bottom-right. But which is the best choice? Which move will best help X minimize the maximum possibility of losing the game?Figure 3: AI player\u2019s possible play choicesTo make the best decision, the AI needs to do the following:Store the current state (values) of the tic-tac-toe board in an array. (For any empty cell, the cell\u2019s index will get stored as its present content).Get an array list of only the empty cells\u2019 indexes.Check and confirm if a specific player has won the game.Recursively invoke minimax on each of the board\u2019s empty cells.Return a score for every possible move for both player X and player O.Out of all the returned scores, choose the best one (the highest) that is guaranteed to minimize the human player\u2019s possibilities of winning the game.Therefore, in the following steps below, we will configure the AI to accomplish the list above. So, let\u2019s get started by storing the board\u2019s current state in an array.Step 3: Store the board\u2019s current state in an arrayOur next step is to store the current content of each of the board's cells in an array like so:const currentBoardState = [\"X\", 1, \"O\", \"X\", 4, \"X\", \"O\", \"O\", 8];Note:The current state of our tic-tac-toe board is still as illustrated in figure 2.The values 1, 4, and 8 in the currentBoardState array are the board's empty cells' index numbers. In other words, instead of using empty strings, we chose to store the empty cells' current content as their respective indexes.Importantly, before moving to the next step, let us explicitly define whose mark is \u201cX\u201d and who owns \u201cO\u201d.const aiMark = \"X\";\nconst humanMark = \"O\";The two statements above denote that the AI\u2019s mark is X while the human player\u2019s mark is O.Step 4: Create a function to get the indexes of all the empty cellsThe function below will filter the currentBoardState array \u2014 which will be passed-in as the function\u2019s parameter\u2019s argument. It will then return a new array containing all the currentBoardState array\u2019s items that are neither \u201cX\u201d nor \u201cO\u201d.function getAllEmptyCellsIndexes(currBdSt) {\n    return currBdSt.filter(i => i != \"X\" && i != \"O\");\n}Note: Remember that the currentBoardState array we created in step 3 contains only the values \u201cX\u201d, \u201cO\u201d, and the board's empty cells' indexes. Therefore, the getAllEmptyCellsIndexes() function above filters out any occurrence of an index in the currentBoardState array.Step 5: Create a winner determiner functionThe primary purpose of the winner determiner function below is to receive a currentBoardState array and a specific player\u2019s mark (either mark \u201cX\u201d or \u201cO\u201d) as its parameters\u2019 arguments. Then, it checks if the received mark forms a winning combination on the tic-tac-toe board. If so, the Boolean value true is returned \u2014 otherwise, false is returned.function checkIfWinnerFound(currBdSt, currMark) {\n    if (\n        (currBdSt[0] === currMark && currBdSt[1] === currMark && currBdSt[2] === currMark) ||\n        (currBdSt[3] === currMark && currBdSt[4] === currMark && currBdSt[5] === currMark) ||\n        (currBdSt[6] === currMark && currBdSt[7] === currMark && currBdSt[8] === currMark) ||\n        (currBdSt[0] === currMark && currBdSt[3] === currMark && currBdSt[6] === currMark) ||\n        (currBdSt[1] === currMark && currBdSt[4] === currMark && currBdSt[7] === currMark) ||\n        (currBdSt[2] === currMark && currBdSt[5] === currMark && currBdSt[8] === currMark) ||\n        (currBdSt[0] === currMark && currBdSt[4] === currMark && currBdSt[8] === currMark) ||\n        (currBdSt[2] === currMark && currBdSt[4] === currMark && currBdSt[6] === currMark)\n    ) {\n        return true;\n    } else {\n        return false;\n    }\n}Step 6: Create the minimax algorithmA minimax algorithm is just an ordinary function that contains statements to be executed once the function is invoked. Therefore, the process of creating the algorithm is the same as creating any other function. So, let\u2019s create one now.function minimax(currBdSt, currMark) {\n    \n    // Space for the minimax\u2019s statements \n    \n}That\u2019s it! We\u2019ve created a minimax function \u2014 albeit an empty one. Our next step is to fill up the function with statements that will be executed once the function is invoked \u2014 which we will do below.Note: The minimax function created above is designed to accept two arguments.The first is an array list of the current board\u2019s content \u2014 that is, the present value of the currentBoardState array. While the second argument is the mark of the player currently running the minimax algorithm \u2014 that is, mark \u201cX\u201d or mark \u201cO\u201d.Step 7: First minimax invocationTo avoid any confusion later in this tutorial, let\u2019s invoke our minimax function for the first time \u2014 while passing-in the currentBoardState array and the aiMark as the function\u2019s arguments.const bestPlayInfo = minimax(currentBoardState, aiMark);Step 8: Store the indexes of all empty cellsIn this step, we will invoke the getAllEmptyCellsIndexes function that we created at step 4 \u2014 while passing-in the currentBoardState array as the function\u2019s argument. Then, we will store the returned array list of indexes inside a variable named availCellsIndexes.const availCellsIndexes = getAllEmptyCellsIndexes(currBdSt);Step 9: Check if there is a terminal stateAt this stage, we need to verify if there is a terminal state (that is, a loss state, a win state, or a draw state) on the tic-tac-toe board. We will accomplish this verification by invoking the winner determiner function (created in step 5) for each of the players.If the function finds a win state for the human player (the minimizer), it will return -1 (which signifies that the human player has won, and the AI has lost). But if it finds a win state for the AI player (the maximizer), it will return +1 (which indicates that the AI has won, and the human player has lost).However, suppose the winner determiner function cannot find any empty cell on the board or any win state for either player. In that case, it will return 0 (zero) \u2014 which signifies that the game has ended in a tie.Note: The scores (-1, +1, and 0) indicated above are heuristic values \u2014 which means that we will still get the same result if we prefer to use -25, +25, and 0.Let\u2019s now proceed to implement the terminal state verification by using an if statement like so:if (checkIfWinnerFound(currBdSt, humanMark)) {\n    return {score: -1};\n} else if (checkIfWinnerFound(currBdSt, aiMark)) {\n    return {score: 1};\n} else if (availCellsIndexes.length === 0) {\n    return {score: 0};\n}When there is a terminal state (lose, win, or draw), the active minimax function will return the appropriate terminal state score (-1, +1, or 0) and end its invocation.If the active minimax ends its invocation here, the algorithm will move on to step 12.However, when there is no terminal state, the active minimax function will execute the next statement (step 10, below).Step 10: Get ready to test the outcome of playing the current player\u2019s mark on each empty cellAs step 9 found no terminal state, we have to devise a way to test what will happen if the current player (who is to make the next game move) plays on each empty cell.In other words, if the current player plays on the first available cell, and the opponent plays on the second empty cell, will the current player win, lose, or draw the game? Or will there still be no terminal state found?Alternatively, what will happen if the current player plays on the second available cell, and the opponent plays on the first empty cell?Or perhaps, will the third available cell be the best spot for the current player to play?This test drive is what we need to do now. But before we begin, we need a place to record each test's outcome \u2014 so let\u2019s do that first by creating an array named allTestPlayInfos.const allTestPlayInfos = [];So, now that we have secured a place to store each test drive\u2019s result, let\u2019s begin the trials by creating a for-loop statement that will loop through each of the empty cells starting from the first one.for (let i = 0; i < availCellsIndexes.length; i++) {\n    \n    // Space for the for-loop\u2019s codes\n    \n}In the next two steps, we will fill up the for-loop with the code it should run for each empty cell.Step 11: Test-play the current player\u2019s mark on the empty cell the for-loop is currently processingBefore doing anything in this step, let\u2019s review the current state of our board.Figure 4: The current state of the tic-tac-toe boardNotice that the above board is still the same as that of figure 2, except that we\u2019ve highlighted \u2014 in red \u2014 the cell the for-loop is currently processing.Next, it will be helpful to have a place to store this test-play\u2019s terminal score \u2014 so let\u2019s create an object like so:const currentTestPlayInfo = {};Also, before test-playing the current player\u2019s mark on the red cell, let\u2019s save the cell\u2019s index number \u2014 so that it will be easy to reset the cell\u2019s info after this test-play.currentTestPlayInfo.index = currBdSt[availCellsIndexes[i]];Let\u2019s now place the current player\u2019s mark on the red cell (that is, the cell currently being processed by the for-loop).currBdSt[availCellsIndexes[i]] = currMark;Based on the current player\u2019s gameplay, the board\u2019s state will change to reflect its latest move.Figure 5: The new board \u2014 which reflects the current player\u2019s latest moveTherefore, since the board\u2019s state has changed, we need to recursively run minimax on the new board \u2014 while passing in the new board's state and the next player's mark.if (currMark === aiMark) {\n    const result = minimax(currBdSt, humanMark);\n    currentTestPlayInfo.score = result.score;\n} else {\n    const result = minimax(currBdSt, aiMark);\n    currentTestPlayInfo.score = result.score;\n}Note:The recursive invocation of minimax at this very point will be the _____ time we are invoking the function. The first invocation happened in step 7.This recursive invocation will cause the reiteration of steps 8 to 11.Suppose there is a terminal state at step 9. In that case, the current minimax invocation will stop running \u2014 and store the returned terminal object (for example, {score: 1}) in the result variable.Once there is a terminal state, step 12 will be the next step.If there exists no terminal state, a second for-loop will begin for the new board at step 10.If step 10 is repeated, please replace figure 4\u2019s board with the new board in figure 5. However, the cell highlighted in red will now be the cell the for-loop is currently processing. So please, do reflect the changes accordingly.Step 12: Save the latest terminal scoreAfter the just concluded minimax invocation has returned its terminal state's value, the active for-loop will save the result variable's score into the currentTestPlayInfo object like so:currentTestPlayInfo.score = result.score;Then, since the returned score officially ends the current test-play, it is best to reset the current board back to the state before the current player made its move.currBdSt[availCellsIndexes[i]] = currentTestPlayInfo.index;Also, we need to save the result of the current player\u2019s test-play for future use. So, let\u2019s do that by pushing the currentTestPlayInfo object to the allTestPlayInfos array like so:allTestPlayInfos.push(currentTestPlayInfo);Note:If you got to this step from step 17, kindly continue this tutorial at step 18. Otherwise, consider the next point.If the active for-loop has finished looping through all the current board's empty cells, the loop will end at this point, and step 14 will be next. Otherwise, the loop will proceed to process the next available cell (step 13).Step 13: Run the active for-loop on the next empty cellRemember that the currently active for-loop (that began at step 10) has only finished its work for the preceding empty cell(s). Therefore, the loop will proceed to test-play the current player\u2019s mark on the next free cell. In other words, the currently running minimax function will repeat steps 11 and 12. But, essentially, take note of the following:The red cell highlighted in figure 4 will change to the cell the for-loop is currently processing.Please, be mindful that figure 5 will also change. In other words, the current player\u2019s move will now be on the cell the for-loop is currently processing.After the active for-loop has completed its work, the allTestPlayInfos array will contain specific objects for each empty cell the for-loop has processed.Each of the objects in the allTestPlayInfos array will contain an index property and a score property (take for example: {index: 8, score: -1}).If you got to this step from step 20, then, on completing step 12, kindly continue this tutorial at step 18.Step 14: Plan how to get the object with the best test-play score for the current playerImmediately after the for-loop has completed its work of looping through all the empty cells of the current board, minimax will:Create a space to store the reference number that will later help to get the best test-play object.Get the reference number to the current player\u2019s best test-play.Use the acquired reference number to get the object with the best test-play for the current player.Without any further ado, let\u2019s implement this plan in the next few steps.Step 15: Create a store for the best test-play\u2019s referenceThe variable below is the place we will later store the reference to the best test-play object. (Note that the value null indicates that we have deliberately left the variable empty).let bestTestPlay = null;Step 16: Get the reference to the current player\u2019s best test-playNow that there is a bestTestPlay store, the active minimax function can proceed to get the reference to the current player\u2019s best test-play like so:if (currMark === aiMark) {\n    let bestScore = -Infinity;\n    for (let i = 0; i < allTestPlayInfos.length; i++) {\n        if (allTestPlayInfos[i].score > bestScore) {\n            bestScore = allTestPlayInfos[i].score;\n            bestTestPlay = i;\n        }\n    }\n} else {\n    let bestScore = Infinity;\n    for (let i = 0; i < allTestPlayInfos.length; i++) {\n        if (allTestPlayInfos[i].score < bestScore) {\n            bestScore = allTestPlayInfos[i].score;\n            bestTestPlay = i;\n        }\n    }\n}The code above means if the current mark is equal to the AI player\u2019s mark:Create a bestScore variable with the value of -Infinity. (Note that this value is just a placeholder value that needs to be less than all the scores in the allTestPlayInfos array. Therefore, using -700 will do the same job).Then, for every test-play object in the allTestPlayInfos array, check if the test-play the loop is currently processing has a higher score than the current bestScore. If so, record that test-play\u2019s details inside both the bestScore variable and the bestTestPlay variable.Otherwise, if the current mark is the human player\u2019s mark:Create a bestScore variable with the value of +Infinity. (Again, note that we will get the same outcome if we had preferred to use +300. It is just a placeholder value that needs to be greater than all the scores in the allTestPlayInfos array).Then, for every test-play object in the allTestPlayInfos array, check if the test-play the loop is currently processing has a lesser score than the current bestScore. If so, record that test-play\u2019s details inside both the bestScore variable and the bestTestPlay variable.Step 17: Get the object with the best test-play score for the current playerFinally, the currently running minimax invocation can now finish its work by returning the object with the best test-play for the current player like so:return allTestPlayInfos[bestTestPlay];Note that minimax will store the returned object inside the result variable of the first for-loop that began at step 11. It will then repeat step 12. Please revisit step 12 only. Then, continue this tutorial below.Step 18: Let\u2019s do a reviewThis stage is an excellent time to review what we've done thus far pictorially.Note:If this is your first time on this step, please use the diagram in step 19.Is this your second time on this step? If so, the diagram in step 21 is yours.Are you here for the third time? Well-done! Check out the diagram in step 23.Step 19: Tracing our steps with a diagramThe diagram below shows the AI and the human player's first test-play for the first for-loop invocation initiated by the AI player.Figure 6: First test-play which predicts a loss state for the AI (maximizer)Step 20: The first for-loop moves forward to process the next empty cellOn concluding that playing on the first empty cell will end in a loss state, the AI forges ahead to test the outcome of playing on the second free cell by repeating step 13.Step 21: Tracing our steps with a diagramThe diagram below shows the AI and the human player's second test-play for the first for-loop invocation initiated by the AI player.Figure 7: Second test-play which predicts a win state for the AI (maximizer)Step 22: The first for-loop moves forward to process the next empty cellNow that the AI has confirmed that playing on the second empty cell will result in a win state, it further checks the outcome of playing on the third free cell by repeating step 13.Step 23: Tracing our steps with a diagramThe diagram below shows the AI and the human player's third test-play for the first for-loop invocation initiated by the AI player.Figure 8: Third test-play which predicts a loss state for the AI (maximizer)Step 24: Get the object with the best test-play score for the AI playerAt this point (after the third test-play), the first for-loop would have processed all the three empty cells of the first board (passed-in to minimax at step 7). Therefore, minimax will forge ahead to get the object with the best test-play for the AI player \u2014 by repeating steps 15 to 17. However, when at step 17, kindly note the following:The returned object will now get stored in the bestPlayInfo variable that we created at step 7.Minimax will not repeat step 12 because the for-loop statement is no longer active.Figure 9: Overview of all test-plays and scoresStep 25: Use the data inside bestPlayInfoConsidering this tutorial\u2019s board (a near-the-end state game board \u2014 as shown in figure 2 of step 2), the object in the bestPlayInfo variable will be {index: 4, score: 1}. Therefore, the AI can now use its index value to choose the best cell to play on.Example// Get all the board\u2019s cells:\nconst gameCells = document.querySelectorAll(\".cell\");\n\n// Below is the variable we created at step 3:\nconst aiMark = \"X\";\n\n// Here is the bestPlayInfo we created at step 7 to contain the best test-play object for the AI player:\nconst bestPlayInfo = minimax(currentBoardState, aiMark);\n\n// Play the AI\u2019s mark on the cell that is best for it:\ngameCells[bestPlayInfo.index].innerText = aiMark;Therefore, the AI player will win the game, and the new board will now look like so:Figure 10: Final gameboard showing that the AI (player X) has won the gameStep 26: A bird\u2019s-eye view of this tutorial\u2019s algorithmBelow is this tutorial\u2019s minimax algorithm in one piece. Feel free to insert it into your editor. Play around with it for various game scenarios, and use the console to test, test, and test it again until you are comfortable building an unbeatable AI. And remember, programming is better only when you code sweetly \u2014 so have lots of fun with it!// Step 3 - Store the board\u2019s current state in an array and define each mark's owner:\nconst currentBoardState = [\"X\", 1, \"O\", \"X\", 4, \"X\", \"O\", \"O\", 8];\nconst aiMark = \"X\";\nconst humanMark = \"O\";\n\n// Step 4 - Create a function to get the indexes of all the empty cells:\nfunction getAllEmptyCellsIndexes(currBdSt) {\n    return currBdSt.filter(i => i != \"O\" && i != \"X\");\n}\n\n// Step 5 - Create a winner determiner function:\nfunction checkIfWinnerFound(currBdSt, currMark) {\n    if (\n        (currBdSt[0] === currMark && currBdSt[1] === currMark && currBdSt[2] === currMark) ||\n        (currBdSt[3] === currMark && currBdSt[4] === currMark && currBdSt[5] === currMark) ||\n        (currBdSt[6] === currMark && currBdSt[7] === currMark && currBdSt[8] === currMark) ||\n        (currBdSt[0] === currMark && currBdSt[3] === currMark && currBdSt[6] === currMark) ||\n        (currBdSt[1] === currMark && currBdSt[4] === currMark && currBdSt[7] === currMark) ||\n        (currBdSt[2] === currMark && currBdSt[5] === currMark && currBdSt[8] === currMark) ||\n        (currBdSt[0] === currMark && currBdSt[4] === currMark && currBdSt[8] === currMark) ||\n        (currBdSt[2] === currMark && currBdSt[4] === currMark && currBdSt[6] === currMark)\n) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// Step 6 - Create the minimax algorithm:\nfunction minimax(currBdSt, currMark) {\n    // Step 8 - Store the indexes of all empty cells:\n    const availCellsIndexes = getAllEmptyCellsIndexes(currBdSt);\n    \n    // Step 9 - Check if there is a terminal state:\n    if (checkIfWinnerFound(currBdSt, humanMark)) {\n        return {score: -1};\n    } else if (checkIfWinnerFound(currBdSt, aiMark)) {\n        return {score: 1};\n    } else if (availCellsIndexes.length === 0) {\n        return {score: 0};\n    }\n    \n    // Step 10 - Create a place to record the outcome of each test drive:\n    const allTestPlayInfos = [];\n    \n    // Step 10 - Create a for-loop statement that will loop through each of the empty cells:\n    for (let i = 0; i < availCellsIndexes.length; i++) {\n        // Step 11 - Create a place to store this test-play\u2019s terminal score:\n        const currentTestPlayInfo = {};\n        \n        // Step 11 - Save the index number of the cell this for-loop is currently processing:\n        currentTestPlayInfo.index = currBdSt[availCellsIndexes[i]];\n        \n        // Step 11 - Place the current player\u2019s mark on the cell for-loop is currently processing:\n        currBdSt[availCellsIndexes[i]] = currMark;\n        \n        if (currMark === aiMark) {\n            // Step 11 - Recursively run the minimax function for the new board:\n            const result = minimax(currBdSt, humanMark);\n            \n            // Step 12 - Save the result variable\u2019s score into the currentTestPlayInfo object:\n            currentTestPlayInfo.score = result.score;\n        } else {\n            // Step 11 - Recursively run the minimax function for the new board:\n            const result = minimax(currBdSt, aiMark);\n            \n            // Step 12 - Save the result variable\u2019s score into the currentTestPlayInfo object:\n            currentTestPlayInfo.score = result.score;\n        }\n        \n        // Step 12 - Reset the current board back to the state it was before the current player made its move:\n        currBdSt[availCellsIndexes[i]] = currentTestPlayInfo.index;\n        \n        // Step 12 - Save the result of the current player\u2019s test-play for future use:\n        allTestPlayInfos.push(currentTestPlayInfo);\n    }\n    \n    // Step 15 - Create a store for the best test-play\u2019s reference:\n    let bestTestPlay = null;\n    \n    // Step 16 - Get the reference to the current player\u2019s best test-play:\n    if (currMark === aiMark) {\n        let bestScore = -Infinity;\n        for (let i = 0; i < allTestPlayInfos.length; i++) {\n            if (allTestPlayInfos[i].score > bestScore) {\n                bestScore = allTestPlayInfos[i].score;\n                bestTestPlay = i;\n            }\n        }\n    } else {\n        let bestScore = Infinity;\n        for (let i = 0; i < allTestPlayInfos.length; i++) {\n            if (allTestPlayInfos[i].score < bestScore) {\n                bestScore = allTestPlayInfos[i].score;\n                bestTestPlay = i;\n            }\n        }\n    }\n    \n    // Step 17 - Get the object with the best test-play score for the current player:\n    return allTestPlayInfos[bestTestPlay];\n} \n\n// Step 7 - First minimax invocation:\nconst bestPlayInfo = minimax(currentBoardState, aiMark);Useful resourceRecursion: What You Need to Know about Recursion\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 26884, "excerpt": "Recently I wondered \u2013 how can I program the computer to be unbeatable in a\ntic-tac-toe game? \n\nWell, I thought I could easily get an answer to this question. But as I went\nback and forth from articles to videos to a series of coding meditations, I only\nsucceeded in becoming more confused. \n\nHowever, my \u201cAha!\u201d moment came when I took the time to understand how the \nminimax algorithm works.\n\nIf you are also on a similar path, let me take you through the steps to build an\nunbeatable AI (Artificial", "siteName": "freeCodeCamp.org", "publishedTime": "2020-12-09T16:16:23.000Z", "id": "eeb2693eb7d4b5b23f5b4cccc25acff14e3a7850", "url": "https://www.freecodecamp.org/news/minimax-algorithm-guide-how-to-create-an-unbeatable-ai/", "domain": "freecodecamp.org", "date": "2023-12-27T18:06:24.581336", "resultUri": "http://localhost:3000/result/eeb2693eb7d4b5b23f5b4cccc25acff14e3a7850", "query": {"url": ["https://www.freecodecamp.org/news/minimax-algorithm-guide-how-to-create-an-unbeatable-ai/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "Minimax Algorithm Guide: How to Create an Unbeatable AI", "description": "Recently I wondered \u2013 how can I program the computer to be unbeatable in a tic-tac-toe game?  Well, I thought I could easily get an answer to this question. But as I went back and forth from articles to videos to a series of coding meditations, I only succeeded", "url": "https://www.freecodecamp.org/news/minimax-algorithm-guide-how-to-create-an-unbeatable-ai/", "image": "https://cdn-media-2.freecodecamp.org/w1280/5fc9fb8be6787e0983939c87.jpg", "image:width": "1280", "image:height": "854"}, "twitter": {"card": "summary_large_image", "title": "Minimax Algorithm Guide: How to Create an Unbeatable AI", "description": "Recently I wondered \u2013 how can I program the computer to be unbeatable in a tic-tac-toe game?  Well, I thought I could easily get an answer to this question. But as I went back and forth from articles to videos to a series of coding meditations, I only succeeded", "url": "https://www.freecodecamp.org/news/minimax-algorithm-guide-how-to-create-an-unbeatable-ai/", "image": "https://cdn-media-2.freecodecamp.org/w1280/5fc9fb8be6787e0983939c87.jpg", "label1": "Written by", "data1": "Oluwatobi Sofela", "label2": "Filed under", "data2": "Programming, Game Development, Algorithms, Artificial Intelligence, JavaScript", "site": "@freecodecamp", "creator": "@oluwatobiss"}}}