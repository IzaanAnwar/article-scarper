{"title": "Higher Order Functions in JavaScript \u2013 Reach New Heights in Your JS Code", "byline": "Dave Gray", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>Higher Order Functions in JavaScript \u2013 Reach New Heights in Your JS Code</h1>\n<section>\n<section data-test-label=\"post-content\">\n<h2 id=\"what-is-a-higher-order-function\">What is a Higher Order Function?</h2><p>Let's look at the name, and consider how we talk about things.</p><p>We dig <em>down</em> into the details, but sometimes we want a <em>high</em> level view of things.</p><p>This high level view indicates more abstraction. We go down into details, but we elevate into a more abstract viewpoint.</p><p>Higher Order Functions are exactly that: A higher level of abstraction than your typical functions.</p><h3 id=\"so-how-can-we-define-a-higher-order-function\">So how can we define a Higher Order Function?</h3><p>Higher Orders Functions are functions that perform operations on other functions.</p><p>In this definition, <em>operations</em> can mean taking one or more functions as an argument OR returning a function as the result. It doesn't have to do both. Doing one or the other qualifies a function as a higher order function.</p><h2 id=\"let-s-look-at-an-example-of-a-higher-order-function\">Let's look at an example of a higher order function</h2><p>Without a higher order function, if I want to add one to each number in an array and display it in the console, I can do the following:</p><pre><code>const numbers = [1, 2, 3, 4, 5];\n\nfunction addOne(array) {\n  for (let i = 0; i &lt; array.length; i++) {\n    console.log(array[i] + 1);\n  }\n}\n\naddOne(numbers);\n</code></pre><p>The function <code>addOne()</code> accepts an array, adds one to each number in the array, and displays it in the console. The original values remain unchanged in the array, but the function is doing something for each value.</p><p>However, using what may be the most common higher order function, <code>forEach()</code>, we can simplify this process:</p><pre><code>const numbers = [1, 2, 3, 4, 5];\n\nnumbers.forEach((number) =&gt; console.log(number + 1));\n</code></pre><p>We've abstracted the function definition and call in the original code above to just one line!</p><p>We apply <code>forEach()</code> to the array named \"numbers.\" There is an anonymous function at the beginning of <code>forEach()</code> that accepts each element of the array - one at a time. </p><p>With the array named numbers, it makes sense to name each element of the array \"number\" although we could have named it \"element\" or \"el\" or even \"whatever\".</p><p>The anonymous arrow function logs the value of the number + 1 to the console.</p><p>The higher order function <code>forEach()</code> applies a function to each element of an array.</p><h2 id=\"another-higher-order-function-example\">Another higher order function example</h2><p>Without a higher order function, if I wanted to create a new array that only has the odd numbers from the numbers array, I could do the following:</p><pre><code>const numbers = [1, 2, 3, 4, 5];\n\nfunction isOdd(array, oddArr = []) {\n  for (let i = 0; i &lt; array.length; i++) {\n    if (array[i] % 2 !== 0) {\n      oddArr.push(array[i]);\n    }\n  }\n  return oddArr;\n}\n\nconst oddArray = isOdd(numbers);\nconsole.log(oddArray);\n</code></pre><p>The function <code>isOdd()</code> accepts an array and has a second optional parameter for an array. If not provided, the array has a default value of an empty array. </p><p>The function checks each number in the array to see if it is an odd number. If the number is odd, it adds it to the array from the second parameter. After all numbers are checked, the array from the second parameter is returned.</p><p>So yeah, that's a lot to keep track of.</p><p>If we use the higher order function, <code>filter()</code>, we can abstract so much:</p><pre><code>const numbers = [1, 2, 3, 4, 5];\n\nconst oddArray = numbers.filter((number) =&gt; number % 2 !== 0);\nconsole.log(oddArray);\n</code></pre><p>Pardon me for getting excited, but that is a big improvement.</p><p>We start by defining the new array <code>oddArray</code> because applying <code>filter()</code> will create a new array. The higher order function will return each element that meets the condition set within the anonymous function it receives. The anonymous function is once again applied to each element in the numbers array.</p><h2 id=\"since-we-re-on-a-roll-another-higher-order-function-example\">Since We're On A Roll \u2013 Another Higher Order Function Example</h2><p>We've come this far, and I think you're starting to see why higher order functions are so good!</p><p>Let's look at another example...</p><p>Back in our <code>forEach()</code> example, we added one to each number in the array and logged each value to the console. But what about creating a new array with those new values instead? Without a higher order function, I could do the following:</p><pre><code>const numbers = [1, 2, 3, 4, 5];\n\nfunction addOneMore(array, newArr = []) {\n  for (let i = 0; i &lt; array.length; i++) {\n    newArr.push(array[i] + 1);\n  }\n  return newArr;\n}\n\nconst newArray = addOneMore(numbers);\nconsole.log(newArray);\n</code></pre><p>The function <code>addOneMore()</code> once again accepts an array and has an array as a second parameter which has a default value of empty. One is added to each element of the existing numbers array and the result is pushed to the new array which is returned.</p><p>We abstract this away with the higher order function, <code>map()</code>:</p><pre><code>const numbers = [1, 2, 3, 4, 5];\n\nconst newArray = numbers.map((number) =&gt; number + 1);\nconsole.log(numbers);\n</code></pre><p>We start by defining the newArray because <code>map()</code> creates a new array. Like <code>forEach()</code>, <code>map()</code> applies an anonymous function to each element of the numbers array. However, <code>map()</code> creates a new array in the process.</p><h2 id=\"just-one-more-example\">Just One More Example</h2><p>What if we wanted to find the total of all values in the numbers array?</p><p>Without a higher order function, I could do this:</p><pre><code>const numbers = [1, 2, 3, 4, 5];\n\nfunction getTotalValue(array) {\n  let total = 0;\n  for (let i = 0; i &lt; array.length; i++) {\n    total += array[i];\n  }\n  return total;\n}\n\nconst totalValue = getTotalValue(numbers);\nconsole.log(totalValue);\n</code></pre><p>The function <code>getTotalValue()</code> accepts an array, defines the total variable as equal to zero, and loops through the array while adding each element to the total variable. Finally, it returns the total.</p><p>With the higher order function <code>reduce()</code>, this process can yet again be abstracted away:</p><pre><code>const numbers = [1, 2, 3, 4, 5];\n\nconst totalValue = numbers.reduce((sum, number) =&gt; sum + number);\nconsole.log(totalValue);\n</code></pre><p>The higher order function <code>reduce()</code> expects two parameters in the anonymous function within. </p><p>The first parameter is an accumulator and the second parameter is an element from the numbers array. </p><p>The accumulator parameter (sum in the example above) keeps track of the total as <code>reduce()</code> applies the anonymous function to each element of the array.</p><h2 id=\"conclusion\">Conclusion</h2><p>Higher Order Functions provide a higher level of abstraction for functions.</p><p>They have the potential to take your JavaScript code to new heights!</p><p>I'll leave you with a tutorial from my YouTube channel that applies Higher Order Functions to JSON data.</p><figure data-test-label=\"fitted\">\n\n</figure>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nWhat is a Higher Order Function?Let's look at the name, and consider how we talk about things.We dig down into the details, but sometimes we want a high level view of things.This high level view indicates more abstraction. We go down into details, but we elevate into a more abstract viewpoint.Higher Order Functions are exactly that: A higher level of abstraction than your typical functions.So how can we define a Higher Order Function?Higher Orders Functions are functions that perform operations on other functions.In this definition, operations can mean taking one or more functions as an argument OR returning a function as the result. It doesn't have to do both. Doing one or the other qualifies a function as a higher order function.Let's look at an example of a higher order functionWithout a higher order function, if I want to add one to each number in an array and display it in the console, I can do the following:const numbers = [1, 2, 3, 4, 5];\n\nfunction addOne(array) {\n  for (let i = 0; i < array.length; i++) {\n    console.log(array[i] + 1);\n  }\n}\n\naddOne(numbers);\nThe function addOne() accepts an array, adds one to each number in the array, and displays it in the console. The original values remain unchanged in the array, but the function is doing something for each value.However, using what may be the most common higher order function, forEach(), we can simplify this process:const numbers = [1, 2, 3, 4, 5];\n\nnumbers.forEach((number) => console.log(number + 1));\nWhoa.We've abstracted the function definition and call in the original code above to just one line!We apply forEach() to the array named \"numbers.\" There is an anonymous function at the beginning of forEach() that accepts each element of the array - one at a time. With the array named numbers, it makes sense to name each element of the array \"number\" although we could have named it \"element\" or \"el\" or even \"whatever\".The anonymous arrow function logs the value of the number + 1 to the console.The higher order function forEach() applies a function to each element of an array.Another higher order function exampleWithout a higher order function, if I wanted to create a new array that only has the odd numbers from the numbers array, I could do the following:const numbers = [1, 2, 3, 4, 5];\n\nfunction isOdd(array, oddArr = []) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] % 2 !== 0) {\n      oddArr.push(array[i]);\n    }\n  }\n  return oddArr;\n}\n\nconst oddArray = isOdd(numbers);\nconsole.log(oddArray);\nThe function isOdd() accepts an array and has a second optional parameter for an array. If not provided, the array has a default value of an empty array. The function checks each number in the array to see if it is an odd number. If the number is odd, it adds it to the array from the second parameter. After all numbers are checked, the array from the second parameter is returned.So yeah, that's a lot to keep track of.If we use the higher order function, filter(), we can abstract so much:const numbers = [1, 2, 3, 4, 5];\n\nconst oddArray = numbers.filter((number) => number % 2 !== 0);\nconsole.log(oddArray);\nYES!Pardon me for getting excited, but that is a big improvement.We start by defining the new array oddArray because applying filter() will create a new array. The higher order function will return each element that meets the condition set within the anonymous function it receives. The anonymous function is once again applied to each element in the numbers array.Since We're On A Roll \u2013 Another Higher Order Function ExampleWe've come this far, and I think you're starting to see why higher order functions are so good!Let's look at another example...Back in our forEach() example, we added one to each number in the array and logged each value to the console. But what about creating a new array with those new values instead? Without a higher order function, I could do the following:const numbers = [1, 2, 3, 4, 5];\n\nfunction addOneMore(array, newArr = []) {\n  for (let i = 0; i < array.length; i++) {\n    newArr.push(array[i] + 1);\n  }\n  return newArr;\n}\n\nconst newArray = addOneMore(numbers);\nconsole.log(newArray);\nThe function addOneMore() once again accepts an array and has an array as a second parameter which has a default value of empty. One is added to each element of the existing numbers array and the result is pushed to the new array which is returned.We abstract this away with the higher order function, map():const numbers = [1, 2, 3, 4, 5];\n\nconst newArray = numbers.map((number) => number + 1);\nconsole.log(numbers);\nWe start by defining the newArray because map() creates a new array. Like forEach(), map() applies an anonymous function to each element of the numbers array. However, map() creates a new array in the process.Just One More ExampleWhat if we wanted to find the total of all values in the numbers array?Without a higher order function, I could do this:const numbers = [1, 2, 3, 4, 5];\n\nfunction getTotalValue(array) {\n  let total = 0;\n  for (let i = 0; i < array.length; i++) {\n    total += array[i];\n  }\n  return total;\n}\n\nconst totalValue = getTotalValue(numbers);\nconsole.log(totalValue);\nThe function getTotalValue() accepts an array, defines the total variable as equal to zero, and loops through the array while adding each element to the total variable. Finally, it returns the total.With the higher order function reduce(), this process can yet again be abstracted away:const numbers = [1, 2, 3, 4, 5];\n\nconst totalValue = numbers.reduce((sum, number) => sum + number);\nconsole.log(totalValue);\nThe higher order function reduce() expects two parameters in the anonymous function within. The first parameter is an accumulator and the second parameter is an element from the numbers array. The accumulator parameter (sum in the example above) keeps track of the total as reduce() applies the anonymous function to each element of the array.ConclusionHigher Order Functions provide a higher level of abstraction for functions.They have the potential to take your JavaScript code to new heights!I'll leave you with a tutorial from my YouTube channel that applies Higher Order Functions to JSON data.\n        \n          \n            \n          \n        \n      \n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 6916, "excerpt": "What is a Higher Order Function?\nLet's look at the name, and consider how we talk about things.\n\nWe dig down into the details, but sometimes we want a high level view of things.\n\nThis high level view indicates more abstraction. We go down into details, but we\nelevate into a more abstract viewpoint.\n\nHigher Order Functions are exactly that: A higher level of abstraction than your\ntypical functions.\n\nSo how can we define a Higher Order Function?\nHigher Orders Functions are functions that perform o", "siteName": "freeCodeCamp.org", "publishedTime": "2021-03-12T21:44:55.000Z", "id": "efc405a9874905fc8fc05b2ad4953b117038a8c9", "url": "https://www.freecodecamp.org/news/higher-order-functions-in-javascript-examples/", "domain": "freecodecamp.org", "date": "2023-12-27T18:06:09.660596", "resultUri": "http://localhost:3000/result/efc405a9874905fc8fc05b2ad4953b117038a8c9", "query": {"url": ["https://www.freecodecamp.org/news/higher-order-functions-in-javascript-examples/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "Higher Order Functions in JavaScript \u2013 Reach New Heights in Your JS Code", "description": "What is a Higher Order Function? Let's look at the name, and consider how we talk about things. We dig down into the details, but sometimes we want a high level view of things. This high level view indicates more abstraction. We go down into details, but we elevate into", "url": "https://www.freecodecamp.org/news/higher-order-functions-in-javascript-examples/", "image": "https://www.freecodecamp.org/news/content/images/2021/03/spacex-uj3hvdfQujI-unsplash.jpg", "image:width": "2000", "image:height": "1333"}, "twitter": {"card": "summary_large_image", "title": "Higher Order Functions in JavaScript \u2013 Reach New Heights in Your JS Code", "description": "What is a Higher Order Function? Let's look at the name, and consider how we talk about things. We dig down into the details, but sometimes we want a high level view of things. This high level view indicates more abstraction. We go down into details, but we elevate into", "url": "https://www.freecodecamp.org/news/higher-order-functions-in-javascript-examples/", "image": "https://www.freecodecamp.org/news/content/images/2021/03/spacex-uj3hvdfQujI-unsplash.jpg", "label1": "Written by", "data1": "Dave Gray", "label2": "Filed under", "data2": "JavaScript, Programming, Web Development, Software Development, Coding", "site": "@freecodecamp", "creator": "@yesdavidgray"}}}