{"title": "JavaScript Rest vs Spread Operator \u2013 What\u2019s the Difference?", "byline": "Oluwatobi Sofela", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>JavaScript Rest vs Spread Operator \u2013 What\u2019s the Difference?</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>JavaScript uses three dots (<code>...</code>) for both the rest and spread operators. But these two operators are not the same.</p><p>The main difference between rest and spread is that the rest operator puts the rest of some specific user-supplied values into a JavaScript array. But the spread syntax expands iterables into individual elements.</p><p>For instance, consider this code that uses rest to enclose some values into an array:</p><pre tabindex=\"0\"><code>// Use rest to enclose the rest of specific user-supplied values into an array:\nfunction myBio(firstName, lastName, ...otherInfo) { \n  return otherInfo;\n}\n\n// Invoke myBio function while passing five arguments to its parameters:\nmyBio(\"Oluwatobi\", \"Sofela\", \"CodeSweetly\", \"Web Developer\", \"Male\");\n\n// The invocation above will return:\n[\"CodeSweetly\", \"Web Developer\", \"Male\"]</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-t3kcyw?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>In the snippet above, we used the <code>...otherInfo</code> rest parameter to put <code>\"CodeSweetly\"</code>, <code>\"Web Developer\"</code>, and <code>\"Male\"</code> into an array.</p><p>Now, consider this example of a spread operator:</p><pre tabindex=\"0\"><code>// Define a function with three parameters:\nfunction myBio(firstName, lastName, company) { \n  return `${firstName} ${lastName} runs ${company}`;\n}\n\n// Use spread to expand an array\u2019s items into individual arguments:\nmyBio(...[\"Oluwatobi\", \"Sofela\", \"CodeSweetly\"]);\n\n// The invocation above will return:\n\u201cOluwatobi Sofela runs CodeSweetly\u201d</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-ppjslx?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>In the snippet above, we used the spread operator (<code>...</code>) to spread <code>[\"Oluwatobi\", \"Sofela\", \"CodeSweetly\"]</code>\u2019s content across <code>myBio()</code>\u2019s parameters.</p><p>Don\u2019t worry if you don\u2019t understand the rest or spread operators yet. This article has got you covered!</p><p>In the following sections, we will discuss how rest and spread work in JavaScript.</p><p>So, without any further ado, let\u2019s get started with the rest operator.</p><h2 id=\"what-exactly-is-the-rest-operator\">What Exactly Is the Rest Operator?</h2><p>The <strong>rest operator</strong> is used to put the rest of some specific user-supplied values into a JavaScript array.</p><p>So, for instance, here is the rest syntax:</p><pre tabindex=\"0\"><code>...yourValues</code></pre><p>The three dots (<code>...</code>) in the snippet above symbolize the rest operator.</p><p>The text after the rest operator references the values you wish to encase inside an array. You can only use it before the last parameter in a function definition.</p><p>To understand the syntax better, let\u2019s see how rest works with JavaScript functions.</p><h3 id=\"how-does-the-rest-operator-work-in-a-function\">How Does the Rest Operator Work in a Function?</h3><p>In JavaScript functions, rest gets used as a prefix of the function\u2019s last parameter.</p><p><strong>Here\u2019s an example:</strong></p><pre tabindex=\"0\"><code>// Define a function with two regular parameters and one rest parameter:\nfunction myBio(firstName, lastName, ...otherInfo) { \n  return otherInfo;\n}</code></pre><p>The rest operator (<code>...</code>) instructs the computer to add whatever <code>otherInfo</code> (arguments) supplied by the user into an array. Then, assign that array to the <code>otherInfo</code> parameter.</p><p>As such, we call <code>...otherInfo</code> a rest parameter.</p><p><strong>Note: </strong><a href=\"https://www.codesweetly.com/javascript-arguments\">Arguments</a> are optional values you may pass to a function\u2019s parameter through an invocator.</p><p><strong>Here\u2019s another example:</strong></p><pre tabindex=\"0\"><code>// Define a function with two regular parameters and one rest parameter:\nfunction myBio(firstName, lastName, ...otherInfo) { \n  return otherInfo;\n}\n\n// Invoke myBio function while passing five arguments to its parameters:\nmyBio(\"Oluwatobi\", \"Sofela\", \"CodeSweetly\", \"Web Developer\", \"Male\");\n\n// The invocation above will return:\n[\"CodeSweetly\", \"Web Developer\", \"Male\"]</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-t3kcyw?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>In the snippet above, notice that <code>myBio</code>\u2019s invocation passed five arguments to the function.</p><p>In other words, <code>\"Oluwatobi\"</code> and <code>\"Sofela\"</code> got assigned to the <code>firstName</code> and <code>lastName</code> parameters.</p><p>At the same time, the rest operator added the remaining arguments ( <code>\"CodeSweetly\"</code>, <code>\"Web Developer\"</code>, and <code>\"Male\"</code>) into an array and assigned that array to the <code>otherInfo</code> parameter.</p><p>Therefore, <code>myBio()</code> function correctly returned <code>[\"CodeSweetly\", \"Web Developer\", \"Male\"]</code> as the content of the <code>otherInfo</code> rest parameter.</p><h3 id=\"beware-you-cannot-use-use-strict-inside-a-function-containing-a-rest-parameter\">Beware! You Cannot Use <code>\u201cuse strict\u201d</code> Inside a Function Containing a Rest Parameter</h3><p>Keep in mind that you <em>cannot </em>use the <code>\u201cuse strict\u201d</code> directive inside any function containing a rest parameter, default parameter, or <a href=\"https://www.codesweetly.com/destructuring-object#how-to-use-a-destructuring-object-to-copy-values-from-properties-to-a-functions-parameters\">destructuring parameter</a>. Otherwise, the computer will throw a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Strict_Non_Simple_Params\">syntax error</a>.</p><p>For instance, consider this example below:</p><pre tabindex=\"0\"><code>// Define a function with one rest parameter:\nfunction printMyName(...value) {\n  \"use strict\";\n  return value;\n}\n\n// The definition above will return:\n\"Uncaught SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list\"</code></pre><p><a href=\"https://codesandbox.io/s/you-cannot-use-use-strict-inside-a-function-containing-a-spread-parameter-cvis3\"><strong>Try it on CodeSandbox</strong></a></p><p><code>printMyName()</code> returned a syntax error because we used the <code>\u201cuse strict\u201d</code> directive inside a function with a rest parameter.</p><p>But suppose you need your function to be in strict mode while also using the rest parameter. In such a case, you can write the <code>\u201cuse strict\u201d</code> directive outside the function.</p><p><strong>Here\u2019s an example:</strong></p><pre tabindex=\"0\"><code>// Define a \u201cuse strict\u201d directive outside your function:\n\"use strict\";\n\n// Define a function with one rest parameter:\nfunction printMyName(...value) {\n  return value;\n}\n\n// Invoke the printMyName function while passing two arguments to its parameters:\nprintMyName(\"Oluwatobi\", \"Sofela\");\n\n// The invocation above will return:\n[\"Oluwatobi\", \"Sofela\"]</code></pre><p><a href=\"https://codesandbox.io/s/you-can-use-use-strict-outside-a-function-containing-a-spread-parameter-spbmh\"><strong>Try it on CodeSandbox</strong></a></p><p><strong>Note: </strong>Only place the <code>\u201cuse strict\u201d</code> directive outside your function if it is okay for the entire script or <a href=\"https://www.codesweetly.com/javascript-lexical-scope\">enclosing scope</a> to be in strict mode.</p><p>So now that we know how rest works in a function, we can talk about how it works in a <a href=\"https://www.codesweetly.com/destructuring-array\">destructuring assignment</a>.</p><h3 id=\"how-the-rest-operator-works-in-a-destructuring-assignment\">How the Rest Operator Works in a Destructuring Assignment</h3><p>The rest operator typically gets used as a prefix of the destructuring assignment\u2019s last variable.</p><p><strong>Here\u2019s an example:</strong></p><pre tabindex=\"0\"><code>// Define a destructuring array with two regular variables and one rest variable:\nconst [firstName, lastName, ...otherInfo] = [\n  \"Oluwatobi\", \"Sofela\", \"CodeSweetly\", \"Web Developer\", \"Male\"\n];\n\n// Invoke the otherInfo variable:\nconsole.log(otherInfo); \n\n// The invocation above will return:\n[\"CodeSweetly\", \"Web Developer\", \"Male\"]</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-tckdt8?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>The rest operator (<code>...</code>) instructs the computer to add the rest of the user-supplied values into an array. Then, it assigns that array to the <code>otherInfo</code> variable.</p><p>As such, you may call <code>...otherInfo</code> a rest variable.</p><p><strong>Here\u2019s another example:</strong></p><pre tabindex=\"0\"><code>// Define a destructuring object with two regular variables and one rest variable:\nconst { firstName, lastName, ...otherInfo } = {\n  firstName: \"Oluwatobi\",\n  lastName: \"Sofela\", \n  companyName: \"CodeSweetly\",\n  profession: \"Web Developer\",\n  gender: \"Male\"\n}\n\n// Invoke the otherInfo variable:\nconsole.log(otherInfo);\n\n// The invocation above will return:\n{companyName: \"CodeSweetly\", profession: \"Web Developer\", gender: \"Male\"}</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-fmr3dr?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>In the snippet above, notice that the rest operator assigned a properties object \u2014 not an array \u2014 to the <code>otherInfo</code> variable.</p><p>In other words, whenever you use rest in a <a href=\"https://www.codesweetly.com/destructuring-object\">destructuring object</a>, the rest operator will produce a properties object.</p><p>However, if you use rest in a <a href=\"https://www.codesweetly.com/destructuring-array\">destructuring array</a> or function, the operator will yield an array literal.</p><p>Before we wrap up our discussion on rest, you should be aware of some differences between JavaScript <a href=\"https://www.codesweetly.com/javascript-arguments\">arguments</a> and the rest parameter. So, let\u2019s talk about that below.</p><h3 id=\"arguments-vs-rest-parameters-what-s-the-difference\">Arguments vs Rest Parameters: What\u2019s the Difference?</h3><p>Here are some of the differences between JavaScript arguments and the rest parameter:</p><h4 id=\"difference-1-the-arguments-object-is-an-array-like-object-not-a-real-array-\">Difference 1: The <code>arguments</code> object is an array-like object \u2014 not a real array!</h4><p>Keep in mind that the JavaScript arguments object is not a real array. Instead, it is an <a href=\"https://www.codesweetly.com/javascript-arguments#what-is-an-arraylike-object\">array-like</a> object that does not have the comprehensive features of a regular JavaScript array.</p><p>The rest parameter, however, is a real array object. As such, you can use all array methods on it.</p><p>So for instance, you can call the <code>sort()</code>, <code>map()</code>, <code>forEach()</code>, or <code>pop()</code> method on a rest parameter. But you cannot do the same on the arguments object.</p><h4 id=\"difference-2-you-cannot-use-the-arguments-object-in-an-arrow-function\">Difference 2: You cannot use the <code>arguments</code> object in an arrow function</h4><p>The <code>arguments</code> object is not available within an arrow function, so you can\u2019t use it there. But you can use the rest parameter within all functions \u2014 including the arrow function.</p><h4 id=\"difference-3-let-rest-be-your-preference\">Difference 3: Let rest be your preference</h4><p>It is best to use rest parameters instead of the <code>arguments</code> object \u2014 especially while writing ES6 compatible code.</p><p>Now that we know how rest works, let's discuss the <code>spread</code> operator so we can see the differences.</p><h2 id=\"what-is-the-spread-operator-and-how-does-spread-work-in-javascript\">What Is the Spread Operator and How Does <code>spread</code> work in JavaScript?</h2><p>The <strong>spread operator</strong> (<code>...</code>) helps you expand iterables into individual elements.</p><p>The spread syntax works within array literals, function calls, and initialized property objects to spread the values of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterables\">iterable objects</a> into separate items. So effectively, it does the opposite thing from the rest operator.</p><p><strong>Note: </strong>A spread operator is effective only when used within array literals, function calls, or initialized properties objects.</p><p>So, what exactly does this mean? Let\u2019s see with some examples.</p><h3 id=\"spread-example-1-how-spread-works-in-an-array-literal\">Spread Example 1: How Spread Works in an Array Literal</h3><pre tabindex=\"0\"><code>const myName = [\"Sofela\", \"is\", \"my\"];\nconst aboutMe = [\"Oluwatobi\", ...myName, \"name.\"];\n\nconsole.log(aboutMe);\n\n// The invocation above will return:\n[ \"Oluwatobi\", \"Sofela\", \"is\", \"my\", \"name.\" ]</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-rd1npd?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>The snippet above used spread (<code>...</code>) to copy the <code>myName</code> array into <code>aboutMe</code>.</p><ul><li>Alterations to <code>myName</code> will not reflect in <code>aboutMe</code> because all the values inside <code>myName</code> are <a href=\"https://www.codesweetly.com/web-tech-glossary#primitive-data-js\">primitives</a>. Therefore, the spread operator simply copied and pasted <code>myName</code>\u2019s content into <code>aboutMe</code> without creating any reference back to the original array.</li><li>As mentioned by <a href=\"https://dev.to/oluwatobiss/spread-operator-how-spread-works-in-javascript-4fdn#comment-node-767546\">@nombrekeff</a> in a comment <a href=\"https://dev.to/oluwatobiss/spread-operator-how-spread-works-in-javascript-4fdn\">here</a>, the spread operator only does shallow copy. So, keep in mind that supposing <code>myName</code> contained any <a href=\"https://www.codesweetly.com/web-tech-glossary#non-primitive-data-js\">non-primitive</a> value, the computer would have created a reference between <code>myName</code> and <code>aboutMe</code>. See <a href=\"#info-3-beware-of-how-spread-works-when-used-on-objects-containing-non-primitives-\">info 3</a> for more on how the spread operator works with primitive and non-primitive values.</li><li>Suppose we did not use the spread syntax to duplicate <code>myName</code>\u2019s content. For instance, if we had written <code>const aboutMe = [\"Oluwatobi\", myName, \"name.\"]</code>. In such a case, the computer would have assigned a reference back to <code>myName</code>. As such, any change made in the original array would reflect in the duplicated one.</li></ul><h3 id=\"spread-example-2-how-to-use-spread-to-convert-a-string-into-individual-array-items\">Spread Example 2: How to Use Spread to Convert a String into Individual Array Items</h3><pre tabindex=\"0\"><code>const myName = \"Oluwatobi Sofela\";\n\nconsole.log([...myName]);\n\n// The invocation above will return:\n[ \"O\", \"l\", \"u\", \"w\", \"a\", \"t\", \"o\", \"b\", \"i\", \" \", \"S\", \"o\", \"f\", \"e\", \"l\", \"a\" ]</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-axvtye?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>In the snippet above, we used the spread syntax (<code>...</code>) within an array literal object (<code>[...]</code>) to expand <code>myName</code>\u2019s string value into individual items.</p><p>As such, <code>\"Oluwatobi Sofela\"</code> got expanded into <code>[ \"O\", \"l\", \"u\", \"w\", \"a\", \"t\", \"o\", \"b\", \"i\", \" \", \"S\", \"o\", \"f\", \"e\", \"l\", \"a\" ]</code>.</p><h3 id=\"spread-example-3-how-the-spread-operator-works-in-a-function-call\">Spread Example 3: How the Spread Operator Works in a Function Call</h3><pre tabindex=\"0\"><code>const numbers = [1, 3, 5, 7];\n\nfunction addNumbers(a, b, c, d) {\n  return a + b + c + d;\n}\n\nconsole.log(addNumbers(...numbers));\n\n// The invocation above will return:\n16</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-nrn8f3?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>In the snippet above, we used the spread syntax to spread the <code>numbers</code> array\u2019s content across <code>addNumbers()</code>\u2019s parameters.</p><p>Suppose the <code>numbers</code> array had more than four items. In such a case, the computer will only use the first four items as <code>addNumbers()</code> argument and ignore the rest.</p><p><strong>Here\u2019s an example:</strong></p><pre tabindex=\"0\"><code>const numbers = [1, 3, 5, 7, 10, 200, 90, 59];\n\nfunction addNumbers(a, b, c, d) {\n  return a + b + c + d;\n}\n\nconsole.log(addNumbers(...numbers));\n\n// The invocation above will return:\n16</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-ef3ncm?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p><strong>Here\u2019s another example:</strong></p><pre tabindex=\"0\"><code>const myName = \"Oluwatobi Sofela\";\n\nfunction spellName(a, b, c) {\n  return a + b + c;\n}\n\nconsole.log(spellName(...myName));      // returns: \"Olu\"\n\nconsole.log(spellName(...myName[3]));   // returns: \"wundefinedundefined\"\n\nconsole.log(spellName([...myName]));    // returns: \"O,l,u,w,a,t,o,b,i, ,S,o,f,e,l,aundefinedundefined\"\n\nconsole.log(spellName({...myName}));    // returns: \"[object Object]undefinedundefined\"</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-pkrxjd?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><h3 id=\"spread-example-4-how-spread-works-in-an-object-literal\">Spread Example 4: How Spread Works in an Object Literal</h3><pre tabindex=\"0\"><code>const myNames = [\"Oluwatobi\", \"Sofela\"];\nconst bio = { ...myNames, runs: \"codesweetly.com\" };\n\nconsole.log(bio);\n\n// The invocation above will return:\n{ 0: \"Oluwatobi\", 1: \"Sofela\", runs: \"codesweetly.com\" }</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-qnmxsu?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>In the snippet above, we used spread inside the <code>bio</code> object to expand <code>myNames</code> values into individual properties.</p><h3 id=\"what-to-know-about-the-spread-operator\">What to Know About the Spread Operator</h3><p>Keep these three essential pieces of info in mind whenever you choose to use the spread operator.</p><h4 id=\"info-1-spread-operators-can-t-expand-object-literal-s-values\">Info 1: Spread operators can\u2019t expand object literal\u2019s values</h4><p>Since a properties object is not an iterable object, you cannot use the spread operator to expand its values.</p><p>However, you can use the spread operator to clone properties<em> </em>from one object into another.</p><p><strong>Here\u2019s an example:</strong></p><pre tabindex=\"0\"><code>const myName = { firstName: \"Oluwatobi\", lastName: \"Sofela\" };\nconst bio = { ...myName, website: \"codesweetly.com\" };\n\nconsole.log(bio);\n\n// The invocation above will return:\n{ firstName: \"Oluwatobi\", lastName: \"Sofela\", website: \"codesweetly.com\" };</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-psnsa8?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>The snippet above used the spread operator to clone <code>myName</code>\u2019s content into the <code>bio</code> object.</p><ul><li>The spread operator can expand iterable objects\u2019 values only.</li><li>An object is iterable only if it (or any object in its prototype chain) has a property with a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol\">@@iterator</a> key.</li><li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/@@iterator\">Array</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/@@iterator\">TypedArray</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/@@iterator\">String</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\">Map</a>, and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/@@iterator\">Set</a> are all built-in iterable types because they have the <code>@@iterator</code> property by default.</li><li>A properties object is not an iterable data type because it does not have the <code>@@iterator</code> property by default.</li><li>You can <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator#user-defined_iterables\">make a properties object iterable</a> by adding <code>@@iterator</code> onto it.</li></ul><h4 id=\"info-2-the-spread-operator-does-not-clone-identical-properties\">Info 2: The spread operator does not clone identical properties</h4><p>Suppose you used the spread operator to clone properties from object A into object B. And suppose object B contains properties identical to those in object A. In such a case, B\u2019s versions will override those inside A.</p><p><strong>Here\u2019s an example:</strong></p><pre tabindex=\"0\"><code>const myName = { firstName: \"Tobi\", lastName: \"Sofela\" };\nconst bio = { ...myName, firstName: \"Oluwatobi\", website: \"codesweetly.com\" };\n\nconsole.log(bio);\n\n// The invocation above will return:\n{ firstName: \"Oluwatobi\", lastName: \"Sofela\", website: \"codesweetly.com\" };</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-gjhjue?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>Observe that the spread operator did not copy <code>myName</code>\u2019s <code>firstName</code> property into the <code>bio</code> object because <code>bio</code> already contains a <code>firstName</code> property.</p><h4 id=\"info-3-beware-of-how-spread-works-when-used-on-objects-containing-non-primitives-\">Info 3: Beware of how spread works when used on objects containing non-primitives!</h4><p>Suppose you used the spread operator on an object (or array) containing only<em> </em>primitive values. The computer will<em> </em>not<em> </em>create any reference between the original object and the duplicated one.</p><p>For instance, consider this code below:</p><pre tabindex=\"0\"><code>const myName = [\"Sofela\", \"is\", \"my\"];\nconst aboutMe = [\"Oluwatobi\", ...myName, \"name.\"];\n\nconsole.log(aboutMe);\n\n// The invocation above will return:\n[\"Oluwatobi\", \"Sofela\", \"is\", \"my\", \"name.\"]</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-rd1npd?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>Observe that every item in <code>myName</code> is a primitive value. Therefore, when we used the spread operator to clone <code>myName</code> into <code>aboutMe</code>, the computer did not create any reference between the two arrays.</p><p>As such, any alteration you make to <code>myName</code> will not reflect in <code>aboutMe</code>, and vice versa.</p><p>As an example, let\u2019s add more content to <code>myName</code>:</p><pre tabindex=\"0\"><code>myName.push(\"real\");</code></pre><p>Now, let\u2019s check the current state of <code>myName</code> and <code>aboutMe</code>:</p><pre tabindex=\"0\"><code>console.log(myName); // [\"Sofela\", \"is\", \"my\", \"real\"]\n\nconsole.log(aboutMe); // [\"Oluwatobi\", \"Sofela\", \"is\", \"my\", \"name.\"]</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-ujs6ny?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>Notice that <code>myName</code>\u2019s updated content did not reflect in <code>aboutMe</code> \u2014 because spread created no reference between the original array and the duplicated one.</p><h5 id=\"what-if-myname-contains-non-primitive-items\">What if <code>myName</code> contains non-primitive items?</h5><p>Suppose <code>myName</code> contained non-primitives. In that case, spread will create a reference between the original non-primitive and the cloned one.</p><p><strong>Here is an example:</strong></p><pre tabindex=\"0\"><code>const myName = [[\"Sofela\", \"is\", \"my\"]];\nconst aboutMe = [\"Oluwatobi\", ...myName, \"name.\"];\n\nconsole.log(aboutMe);\n\n// The invocation above will return:\n[ \"Oluwatobi\", [\"Sofela\", \"is\", \"my\"], \"name.\" ]</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-ombp5w?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>Observe that <code>myName</code> contains a non-primitive value.</p><p>Therefore, using the spread operator to clone <code>myName</code>\u2019s content into <code>aboutMe</code> caused the computer to create a reference between the two arrays.</p><p>As such, any alteration you make to <code>myName</code>\u2019s copy will reflect in <code>aboutMe</code>\u2019s version, and vice versa.</p><p>As an example, let\u2019s add more content to <code>myName</code>:</p><pre tabindex=\"0\"><code>myName[0].push(\"real\");</code></pre><p>Now, let\u2019s check the current state of <code>myName</code> and <code>aboutMe</code>:</p><pre tabindex=\"0\"><code>console.log(myName); // [[\"Sofela\", \"is\", \"my\", \"real\"]]\n\nconsole.log(aboutMe); // [\"Oluwatobi\", [\"Sofela\", \"is\", \"my\", \"real\"], \"name.\"]</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-qpyy8n?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>Notice that <code>myName</code>\u2019s updated content is reflected in <code>aboutMe</code> \u2014 because spread created a reference between the original array and the duplicated one.</p><p><strong>Here\u2019s another example:</strong></p><pre tabindex=\"0\"><code>const myName = { firstName: \"Oluwatobi\", lastName: \"Sofela\" };\nconst bio = { ...myName };\n\nmyName.firstName = \"Tobi\";\n\nconsole.log(myName); // { firstName: \"Tobi\", lastName: \"Sofela\" }\n\nconsole.log(bio); // { firstName: \"Oluwatobi\", lastName: \"Sofela\" }</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-tbmtgm?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>In the snippet above, <code>myName</code>\u2019s update did not reflect in <code>bio</code> because we used the spread operator on an object that contains primitive values only.</p><p><strong>Note: </strong>A developer would call <code>myName</code> a <strong>shallow object </strong>because it contains only primitive items.</p><p><strong>Here\u2019s one more example:</strong></p><pre tabindex=\"0\"><code>const myName = { \n  fullName: { firstName: \"Oluwatobi\", lastName: \"Sofela\" }\n};\n\nconst bio = { ...myName };\n\nmyName.fullName.firstName = \"Tobi\";\n\nconsole.log(myName); // { fullName: { firstName: \"Tobi\", lastName: \"Sofela\" } }\n\nconsole.log(bio); // { fullName: { firstName: \"Tobi\", lastName: \"Sofela\" } }</code></pre><p><a href=\"https://stackblitz.com/edit/web-platform-9uce9g?file=script.js\"><strong>Try it on StackBlitz</strong></a></p><p>In the snippet above, <code>myName</code>\u2019s update is reflected in <code>bio</code> because we used the spread operator on an object that contains a non-primitive value.</p><ul><li>We call <code>myName</code> a <strong>deep object </strong>because it contains a non-primitive item.</li><li>You do <strong>shallow copy </strong>when you create references while cloning one object into another. For instance, <code>...myName</code> produces a shallow copy of the <code>myName</code> object because whatever alteration you make in one will reflect in the other.</li><li>You do <strong>deep copy</strong> when you clone objects without creating references. For instance, I could deep copy <code>myName</code> into <code>bio</code> by doing <code>const bio = JSON.parse(JSON.stringify(myName))</code>. By doing so, the computer will clone <code>myName</code> into <code>bio</code> without<em> </em>creating any reference.</li><li>You can break off the reference between the two objects by replacing the <code>fullName</code> object inside <code>myName</code> or <code>bio</code> with a new object. For instance, doing <code>myName.fullName = { firstName: \"Tobi\", lastName: \"Sofela\" }</code> would disconnect the pointer between <code>myName</code> and <code>bio</code>.</li></ul><h2 id=\"wrapping-it-up\">Wrapping it up</h2><p>This article discussed the differences between the rest and spread operators. We also used examples to see how each operator works.</p><p>Thanks for reading!</p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nJavaScript uses three dots (...) for both the rest and spread operators. But these two operators are not the same.The main difference between rest and spread is that the rest operator puts the rest of some specific user-supplied values into a JavaScript array. But the spread syntax expands iterables into individual elements.For instance, consider this code that uses rest to enclose some values into an array:// Use rest to enclose the rest of specific user-supplied values into an array:\nfunction myBio(firstName, lastName, ...otherInfo) { \n  return otherInfo;\n}\n\n// Invoke myBio function while passing five arguments to its parameters:\nmyBio(\"Oluwatobi\", \"Sofela\", \"CodeSweetly\", \"Web Developer\", \"Male\");\n\n// The invocation above will return:\n[\"CodeSweetly\", \"Web Developer\", \"Male\"]Try it on StackBlitzIn the snippet above, we used the ...otherInfo rest parameter to put \"CodeSweetly\", \"Web Developer\", and \"Male\" into an array.Now, consider this example of a spread operator:// Define a function with three parameters:\nfunction myBio(firstName, lastName, company) { \n  return `${firstName} ${lastName} runs ${company}`;\n}\n\n// Use spread to expand an array\u2019s items into individual arguments:\nmyBio(...[\"Oluwatobi\", \"Sofela\", \"CodeSweetly\"]);\n\n// The invocation above will return:\n\u201cOluwatobi Sofela runs CodeSweetly\u201dTry it on StackBlitzIn the snippet above, we used the spread operator (...) to spread [\"Oluwatobi\", \"Sofela\", \"CodeSweetly\"]\u2019s content across myBio()\u2019s parameters.Don\u2019t worry if you don\u2019t understand the rest or spread operators yet. This article has got you covered!In the following sections, we will discuss how rest and spread work in JavaScript.So, without any further ado, let\u2019s get started with the rest operator.What Exactly Is the Rest Operator?The rest operator is used to put the rest of some specific user-supplied values into a JavaScript array.So, for instance, here is the rest syntax:...yourValuesThe three dots (...) in the snippet above symbolize the rest operator.The text after the rest operator references the values you wish to encase inside an array. You can only use it before the last parameter in a function definition.To understand the syntax better, let\u2019s see how rest works with JavaScript functions.How Does the Rest Operator Work in a Function?In JavaScript functions, rest gets used as a prefix of the function\u2019s last parameter.Here\u2019s an example:// Define a function with two regular parameters and one rest parameter:\nfunction myBio(firstName, lastName, ...otherInfo) { \n  return otherInfo;\n}The rest operator (...) instructs the computer to add whatever otherInfo (arguments) supplied by the user into an array. Then, assign that array to the otherInfo parameter.As such, we call ...otherInfo a rest parameter.Note: Arguments are optional values you may pass to a function\u2019s parameter through an invocator.Here\u2019s another example:// Define a function with two regular parameters and one rest parameter:\nfunction myBio(firstName, lastName, ...otherInfo) { \n  return otherInfo;\n}\n\n// Invoke myBio function while passing five arguments to its parameters:\nmyBio(\"Oluwatobi\", \"Sofela\", \"CodeSweetly\", \"Web Developer\", \"Male\");\n\n// The invocation above will return:\n[\"CodeSweetly\", \"Web Developer\", \"Male\"]Try it on StackBlitzIn the snippet above, notice that myBio\u2019s invocation passed five arguments to the function.In other words, \"Oluwatobi\" and \"Sofela\" got assigned to the firstName and lastName parameters.At the same time, the rest operator added the remaining arguments ( \"CodeSweetly\", \"Web Developer\", and \"Male\") into an array and assigned that array to the otherInfo parameter.Therefore, myBio() function correctly returned [\"CodeSweetly\", \"Web Developer\", \"Male\"] as the content of the otherInfo rest parameter.Beware! You Cannot Use \u201cuse strict\u201d Inside a Function Containing a Rest ParameterKeep in mind that you cannot use the \u201cuse strict\u201d directive inside any function containing a rest parameter, default parameter, or destructuring parameter. Otherwise, the computer will throw a syntax error.For instance, consider this example below:// Define a function with one rest parameter:\nfunction printMyName(...value) {\n  \"use strict\";\n  return value;\n}\n\n// The definition above will return:\n\"Uncaught SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list\"Try it on CodeSandboxprintMyName() returned a syntax error because we used the \u201cuse strict\u201d directive inside a function with a rest parameter.But suppose you need your function to be in strict mode while also using the rest parameter. In such a case, you can write the \u201cuse strict\u201d directive outside the function.Here\u2019s an example:// Define a \u201cuse strict\u201d directive outside your function:\n\"use strict\";\n\n// Define a function with one rest parameter:\nfunction printMyName(...value) {\n  return value;\n}\n\n// Invoke the printMyName function while passing two arguments to its parameters:\nprintMyName(\"Oluwatobi\", \"Sofela\");\n\n// The invocation above will return:\n[\"Oluwatobi\", \"Sofela\"]Try it on CodeSandboxNote: Only place the \u201cuse strict\u201d directive outside your function if it is okay for the entire script or enclosing scope to be in strict mode.So now that we know how rest works in a function, we can talk about how it works in a destructuring assignment.How the Rest Operator Works in a Destructuring AssignmentThe rest operator typically gets used as a prefix of the destructuring assignment\u2019s last variable.Here\u2019s an example:// Define a destructuring array with two regular variables and one rest variable:\nconst [firstName, lastName, ...otherInfo] = [\n  \"Oluwatobi\", \"Sofela\", \"CodeSweetly\", \"Web Developer\", \"Male\"\n];\n\n// Invoke the otherInfo variable:\nconsole.log(otherInfo); \n\n// The invocation above will return:\n[\"CodeSweetly\", \"Web Developer\", \"Male\"]Try it on StackBlitzThe rest operator (...) instructs the computer to add the rest of the user-supplied values into an array. Then, it assigns that array to the otherInfo variable.As such, you may call ...otherInfo a rest variable.Here\u2019s another example:// Define a destructuring object with two regular variables and one rest variable:\nconst { firstName, lastName, ...otherInfo } = {\n  firstName: \"Oluwatobi\",\n  lastName: \"Sofela\", \n  companyName: \"CodeSweetly\",\n  profession: \"Web Developer\",\n  gender: \"Male\"\n}\n\n// Invoke the otherInfo variable:\nconsole.log(otherInfo);\n\n// The invocation above will return:\n{companyName: \"CodeSweetly\", profession: \"Web Developer\", gender: \"Male\"}Try it on StackBlitzIn the snippet above, notice that the rest operator assigned a properties object \u2014 not an array \u2014 to the otherInfo variable.In other words, whenever you use rest in a destructuring object, the rest operator will produce a properties object.However, if you use rest in a destructuring array or function, the operator will yield an array literal.Before we wrap up our discussion on rest, you should be aware of some differences between JavaScript arguments and the rest parameter. So, let\u2019s talk about that below.Arguments vs Rest Parameters: What\u2019s the Difference?Here are some of the differences between JavaScript arguments and the rest parameter:Difference 1: The arguments object is an array-like object \u2014 not a real array!Keep in mind that the JavaScript arguments object is not a real array. Instead, it is an array-like object that does not have the comprehensive features of a regular JavaScript array.The rest parameter, however, is a real array object. As such, you can use all array methods on it.So for instance, you can call the sort(), map(), forEach(), or pop() method on a rest parameter. But you cannot do the same on the arguments object.Difference 2: You cannot use the arguments object in an arrow functionThe arguments object is not available within an arrow function, so you can\u2019t use it there. But you can use the rest parameter within all functions \u2014 including the arrow function.Difference 3: Let rest be your preferenceIt is best to use rest parameters instead of the arguments object \u2014 especially while writing ES6 compatible code.Now that we know how rest works, let's discuss the spread operator so we can see the differences.What Is the Spread Operator and How Does spread work in JavaScript?The spread operator (...) helps you expand iterables into individual elements.The spread syntax works within array literals, function calls, and initialized property objects to spread the values of iterable objects into separate items. So effectively, it does the opposite thing from the rest operator.Note: A spread operator is effective only when used within array literals, function calls, or initialized properties objects.So, what exactly does this mean? Let\u2019s see with some examples.Spread Example 1: How Spread Works in an Array Literalconst myName = [\"Sofela\", \"is\", \"my\"];\nconst aboutMe = [\"Oluwatobi\", ...myName, \"name.\"];\n\nconsole.log(aboutMe);\n\n// The invocation above will return:\n[ \"Oluwatobi\", \"Sofela\", \"is\", \"my\", \"name.\" ]Try it on StackBlitzThe snippet above used spread (...) to copy the myName array into aboutMe.Note:Alterations to myName will not reflect in aboutMe because all the values inside myName are primitives. Therefore, the spread operator simply copied and pasted myName\u2019s content into aboutMe without creating any reference back to the original array.As mentioned by @nombrekeff in a comment here, the spread operator only does shallow copy. So, keep in mind that supposing myName contained any non-primitive value, the computer would have created a reference between myName and aboutMe. See info 3 for more on how the spread operator works with primitive and non-primitive values.Suppose we did not use the spread syntax to duplicate myName\u2019s content. For instance, if we had written const aboutMe = [\"Oluwatobi\", myName, \"name.\"]. In such a case, the computer would have assigned a reference back to myName. As such, any change made in the original array would reflect in the duplicated one.Spread Example 2: How to Use Spread to Convert a String into Individual Array Itemsconst myName = \"Oluwatobi Sofela\";\n\nconsole.log([...myName]);\n\n// The invocation above will return:\n[ \"O\", \"l\", \"u\", \"w\", \"a\", \"t\", \"o\", \"b\", \"i\", \" \", \"S\", \"o\", \"f\", \"e\", \"l\", \"a\" ]Try it on StackBlitzIn the snippet above, we used the spread syntax (...) within an array literal object ([...]) to expand myName\u2019s string value into individual items.As such, \"Oluwatobi Sofela\" got expanded into [ \"O\", \"l\", \"u\", \"w\", \"a\", \"t\", \"o\", \"b\", \"i\", \" \", \"S\", \"o\", \"f\", \"e\", \"l\", \"a\" ].Spread Example 3: How the Spread Operator Works in a Function Callconst numbers = [1, 3, 5, 7];\n\nfunction addNumbers(a, b, c, d) {\n  return a + b + c + d;\n}\n\nconsole.log(addNumbers(...numbers));\n\n// The invocation above will return:\n16Try it on StackBlitzIn the snippet above, we used the spread syntax to spread the numbers array\u2019s content across addNumbers()\u2019s parameters.Suppose the numbers array had more than four items. In such a case, the computer will only use the first four items as addNumbers() argument and ignore the rest.Here\u2019s an example:const numbers = [1, 3, 5, 7, 10, 200, 90, 59];\n\nfunction addNumbers(a, b, c, d) {\n  return a + b + c + d;\n}\n\nconsole.log(addNumbers(...numbers));\n\n// The invocation above will return:\n16Try it on StackBlitzHere\u2019s another example:const myName = \"Oluwatobi Sofela\";\n\nfunction spellName(a, b, c) {\n  return a + b + c;\n}\n\nconsole.log(spellName(...myName));      // returns: \"Olu\"\n\nconsole.log(spellName(...myName[3]));   // returns: \"wundefinedundefined\"\n\nconsole.log(spellName([...myName]));    // returns: \"O,l,u,w,a,t,o,b,i, ,S,o,f,e,l,aundefinedundefined\"\n\nconsole.log(spellName({...myName}));    // returns: \"[object Object]undefinedundefined\"Try it on StackBlitzSpread Example 4: How Spread Works in an Object Literalconst myNames = [\"Oluwatobi\", \"Sofela\"];\nconst bio = { ...myNames, runs: \"codesweetly.com\" };\n\nconsole.log(bio);\n\n// The invocation above will return:\n{ 0: \"Oluwatobi\", 1: \"Sofela\", runs: \"codesweetly.com\" }Try it on StackBlitzIn the snippet above, we used spread inside the bio object to expand myNames values into individual properties.What to Know About the Spread OperatorKeep these three essential pieces of info in mind whenever you choose to use the spread operator.Info 1: Spread operators can\u2019t expand object literal\u2019s valuesSince a properties object is not an iterable object, you cannot use the spread operator to expand its values.However, you can use the spread operator to clone properties from one object into another.Here\u2019s an example:const myName = { firstName: \"Oluwatobi\", lastName: \"Sofela\" };\nconst bio = { ...myName, website: \"codesweetly.com\" };\n\nconsole.log(bio);\n\n// The invocation above will return:\n{ firstName: \"Oluwatobi\", lastName: \"Sofela\", website: \"codesweetly.com\" };Try it on StackBlitzThe snippet above used the spread operator to clone myName\u2019s content into the bio object.Note:The spread operator can expand iterable objects\u2019 values only.An object is iterable only if it (or any object in its prototype chain) has a property with a @@iterator key.Array, TypedArray, String, Map, and Set are all built-in iterable types because they have the @@iterator property by default.A properties object is not an iterable data type because it does not have the @@iterator property by default.You can make a properties object iterable by adding @@iterator onto it.Info 2: The spread operator does not clone identical propertiesSuppose you used the spread operator to clone properties from object A into object B. And suppose object B contains properties identical to those in object A. In such a case, B\u2019s versions will override those inside A.Here\u2019s an example:const myName = { firstName: \"Tobi\", lastName: \"Sofela\" };\nconst bio = { ...myName, firstName: \"Oluwatobi\", website: \"codesweetly.com\" };\n\nconsole.log(bio);\n\n// The invocation above will return:\n{ firstName: \"Oluwatobi\", lastName: \"Sofela\", website: \"codesweetly.com\" };Try it on StackBlitzObserve that the spread operator did not copy myName\u2019s firstName property into the bio object because bio already contains a firstName property.Info 3: Beware of how spread works when used on objects containing non-primitives!Suppose you used the spread operator on an object (or array) containing only primitive values. The computer will not create any reference between the original object and the duplicated one.For instance, consider this code below:const myName = [\"Sofela\", \"is\", \"my\"];\nconst aboutMe = [\"Oluwatobi\", ...myName, \"name.\"];\n\nconsole.log(aboutMe);\n\n// The invocation above will return:\n[\"Oluwatobi\", \"Sofela\", \"is\", \"my\", \"name.\"]Try it on StackBlitzObserve that every item in myName is a primitive value. Therefore, when we used the spread operator to clone myName into aboutMe, the computer did not create any reference between the two arrays.As such, any alteration you make to myName will not reflect in aboutMe, and vice versa.As an example, let\u2019s add more content to myName:myName.push(\"real\");Now, let\u2019s check the current state of myName and aboutMe:console.log(myName); // [\"Sofela\", \"is\", \"my\", \"real\"]\n\nconsole.log(aboutMe); // [\"Oluwatobi\", \"Sofela\", \"is\", \"my\", \"name.\"]Try it on StackBlitzNotice that myName\u2019s updated content did not reflect in aboutMe \u2014 because spread created no reference between the original array and the duplicated one.What if myName contains non-primitive items?Suppose myName contained non-primitives. In that case, spread will create a reference between the original non-primitive and the cloned one.Here is an example:const myName = [[\"Sofela\", \"is\", \"my\"]];\nconst aboutMe = [\"Oluwatobi\", ...myName, \"name.\"];\n\nconsole.log(aboutMe);\n\n// The invocation above will return:\n[ \"Oluwatobi\", [\"Sofela\", \"is\", \"my\"], \"name.\" ]Try it on StackBlitzObserve that myName contains a non-primitive value.Therefore, using the spread operator to clone myName\u2019s content into aboutMe caused the computer to create a reference between the two arrays.As such, any alteration you make to myName\u2019s copy will reflect in aboutMe\u2019s version, and vice versa.As an example, let\u2019s add more content to myName:myName[0].push(\"real\");Now, let\u2019s check the current state of myName and aboutMe:console.log(myName); // [[\"Sofela\", \"is\", \"my\", \"real\"]]\n\nconsole.log(aboutMe); // [\"Oluwatobi\", [\"Sofela\", \"is\", \"my\", \"real\"], \"name.\"]Try it on StackBlitzNotice that myName\u2019s updated content is reflected in aboutMe \u2014 because spread created a reference between the original array and the duplicated one.Here\u2019s another example:const myName = { firstName: \"Oluwatobi\", lastName: \"Sofela\" };\nconst bio = { ...myName };\n\nmyName.firstName = \"Tobi\";\n\nconsole.log(myName); // { firstName: \"Tobi\", lastName: \"Sofela\" }\n\nconsole.log(bio); // { firstName: \"Oluwatobi\", lastName: \"Sofela\" }Try it on StackBlitzIn the snippet above, myName\u2019s update did not reflect in bio because we used the spread operator on an object that contains primitive values only.Note: A developer would call myName a shallow object because it contains only primitive items.Here\u2019s one more example:const myName = { \n  fullName: { firstName: \"Oluwatobi\", lastName: \"Sofela\" }\n};\n\nconst bio = { ...myName };\n\nmyName.fullName.firstName = \"Tobi\";\n\nconsole.log(myName); // { fullName: { firstName: \"Tobi\", lastName: \"Sofela\" } }\n\nconsole.log(bio); // { fullName: { firstName: \"Tobi\", lastName: \"Sofela\" } }Try it on StackBlitzIn the snippet above, myName\u2019s update is reflected in bio because we used the spread operator on an object that contains a non-primitive value.Note:We call myName a deep object because it contains a non-primitive item.You do shallow copy when you create references while cloning one object into another. For instance, ...myName produces a shallow copy of the myName object because whatever alteration you make in one will reflect in the other.You do deep copy when you clone objects without creating references. For instance, I could deep copy myName into bio by doing const bio = JSON.parse(JSON.stringify(myName)). By doing so, the computer will clone myName into bio without creating any reference.You can break off the reference between the two objects by replacing the fullName object inside myName or bio with a new object. For instance, doing myName.fullName = { firstName: \"Tobi\", lastName: \"Sofela\" } would disconnect the pointer between myName and bio.Wrapping it upThis article discussed the differences between the rest and spread operators. We also used examples to see how each operator works.Thanks for reading!\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 19190, "excerpt": "JavaScript uses three dots (...) for both the rest and spread operators. But\nthese two operators are not the same.\n\nThe main difference between rest and spread is that the rest operator puts the\nrest of some specific user-supplied values into a JavaScript array. But the\nspread syntax expands iterables into individual elements.\n\nFor instance, consider this code that uses rest to enclose some values into an\narray:\n\n// Use rest to enclose the rest of specific user-supplied values into an array:\nfun", "siteName": "freeCodeCamp.org", "publishedTime": "2021-09-15T22:27:26.000Z", "id": "52af467c10e43d8418e35e96b49f9882ff943e3c", "url": "https://www.freecodecamp.org/news/javascript-rest-vs-spread-operators/", "domain": "freecodecamp.org", "date": "2023-12-27T18:05:49.078349", "resultUri": "http://localhost:3000/result/52af467c10e43d8418e35e96b49f9882ff943e3c", "query": {"url": ["https://www.freecodecamp.org/news/javascript-rest-vs-spread-operators/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "JavaScript Rest vs Spread Operator \u2013 What\u2019s the Difference?", "description": "JavaScript uses three dots (...) for both the rest and spread operators. But these two operators are not the same. The main difference between rest and spread is that the rest operator puts the rest of some specific user-supplied values into a JavaScript array. But the spread syntax expands iterables", "url": "https://www.freecodecamp.org/news/javascript-rest-vs-spread-operators/", "image": "https://www.freecodecamp.org/news/content/images/2021/09/javascript-rest-vs-spread-operators-codesweetly-1.png", "image:width": "1920", "image:height": "1280"}, "twitter": {"card": "summary_large_image", "title": "JavaScript Rest vs Spread Operator \u2013 What\u2019s the Difference?", "description": "JavaScript uses three dots (...) for both the rest and spread operators. But these two operators are not the same. The main difference between rest and spread is that the rest operator puts the rest of some specific user-supplied values into a JavaScript array. But the spread syntax expands iterables", "url": "https://www.freecodecamp.org/news/javascript-rest-vs-spread-operators/", "image": "https://www.freecodecamp.org/news/content/images/2021/09/javascript-rest-vs-spread-operators-codesweetly-1.png", "label1": "Written by", "data1": "Oluwatobi Sofela", "label2": "Filed under", "data2": "JavaScript, Coding, Programming, Web Development", "site": "@freecodecamp", "creator": "@oluwatobiss"}}}