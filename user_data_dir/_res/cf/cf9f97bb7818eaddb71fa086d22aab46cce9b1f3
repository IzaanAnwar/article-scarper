{"title": "An introduction to Law Testing in Scala", "byline": "dor sever", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>An introduction to Law Testing in Scala</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>Property-based law testing is one of the most powerful tools in the scala ecosystem. In this post, I\u2019ll explain how to use law testing and the value it\u2019ll give you using in-depth code examples.</p><p>This post is aimed for Scala developers who want to improve their testing knowledge and skills. It assumes some knowledge of Scala, cats, and other functional libraries.</p><figure><img alt=\"GpUIRfAe79BTz8JGTvk0oOD376oxjBxj4CiS\" height=\"209\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/GpUIRfAe79BTz8JGTvk0oOD376oxjBxj4CiS\" width=\"498\"/></figure><h4 id=\"introduction\"><strong>Introduction</strong></h4><ul><li>You might be familiar with types which are a set of values (for example Int values are : <code>1,2,3</code>\u2026 String values are : <code>\u201cJohn Doe\u201d </code>etc).</li><li>You also might be familiar with functions which is a mapping from Input type to Output type.</li><li>A property is defined on a type or a function and describes its desired behavior.</li></ul><p>So what is a Law? <strong>Keep on reading!</strong></p><h4 id=\"a-concrete-example\"><strong>A concrete example</strong></h4><p>Here is our beloved <code><em>Person</em></code> data type:</p><pre><code>case class Person(name: String, age: Int)</code></pre><p>And serialization code using the<code> Play-Json</code> , a library that allows transforming your <code>Person</code> type into <code>JSON :</code></p><pre tabindex=\"0\"><code>val personFormat: OFormat[Person] = new OFormat[Person] {\n  override def reads(json: JsValue): JsResult[Person] = {\n    val name = (json \\ \"name\").as[String]\n    val age = (json \\ \"age\").as[Int]\n    JsSuccess(Person(name, age))\n  }\noverride def writes(o: Person): JsObject =\n    JsObject(Seq(\"name\" -&gt; JsString(o.name), \n                 \"age\" -&gt; JsNumber(o.age)))\n}</code></pre><p>We can now test this serialization function on a specific input like this:</p><pre tabindex=\"0\"><code>import org.scalatest._\nclass PersonSerdeSpec extends WordSpecLike with Matchers {\n  \"should serialize and deserialize a person\" in {\n    val person = Person(\"John Doe\", 32)\n    val actualPerson =\n      personFormat.reads(personFormat.writes(person))\n    actualPerson.asOpt.shouldEqual(Some(person))\n  }\n}</code></pre><p>But, we now need to ask ourselves, whether all people will serialize successfully? What about a person with invalid data (such as negative age)? Will we want to repeat this thought process of finding edge-cases for all our test data?</p><p>And most importantly, will this code remain readable over time? (e.g.: changing the <code>person</code> data type [adding a <code>LastName</code> field], repeated tests for other data types, etc)</p><blockquote>\u201c We can solve any problem by introducing an extra level of indirection\u201d.</blockquote><h3 id=\"property-based-testing\">Property-based testing</h3><p>The first weapon in our disposal is Property-based testing (PBT). PBT works by defining a property, which is a high-level specification of behavior that should hold for all values of the specific type.</p><p>In our example, the <strong>property</strong> will be:</p><ul><li>For every person p, if we serialize and deserialize them, we should get back the same person.</li></ul><p>Writing this property using scala check looks like this:</p><pre tabindex=\"0\"><code>object PersonSerdeSpec extends org.scalacheck.Properties(\"PersonCodec\") {\n  property(\"round trip consistency\") = \norg.scalacheck.Prop.forAll { a: Person =&gt;\n    personFormat.reads(personFormat.writes(a)).asOpt.contains(a)\n  }\n}</code></pre><p>The property check requires a way to generate Persons. This is done by using an <code>Arbitrary[Person]</code> which can be defined like this:</p><pre tabindex=\"0\"><code>implicit val personArb: Arbitrary[Person] = Arbitrary {\n  for {\n    name &lt;- Gen.alphaStr\n    age  &lt;- Gen.chooseNum(0, 120)\n  } yield Person(name, age)\n}</code></pre><p>Furthermore, we can use <code>\u201cscalacheck-shapeless\u201d</code>- an amazing library which eliminates (almost) all needs for the verbose (quite messy and highly bug-prone) arbitrary type definition by generating it for us!</p><figure><img alt=\"XgoIxileqrYUmSnMMkzuGFJJCkxvy6-Ryj-Q\" height=\"252\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/XgoIxileqrYUmSnMMkzuGFJJCkxvy6-Ryj-Q\" width=\"275\"/></figure><p>This can be done by adding:</p><pre><code>libraryDependencies += \"com.github.alexarchambault\" %% \"scalacheck-shapeless_1.14\" % \"1.2.0\"</code></pre><p>and importing the following in our code:</p><pre><code>import org.scalacheck.ScalacheckShapeless._</code></pre><p>And then we can remove the <code><em>personArb</em></code><em> </em>instance<em> </em>we defined earlier.</p><h3 id=\"the-codec-law\">The Codec Law</h3><p>Let\u2019s try to abstract further, by defining the <strong>laws</strong> of our data type:</p><pre tabindex=\"0\"><code>trait CodecLaws[A, B] {\n  def serialize: A =&gt; B\n  def deserialize: B =&gt; A\n  def codecRoundTrip(a: A): Boolean = serialize.\nandThen(deserialize)(a) == a\n}</code></pre><figure><img alt=\"De-BSLaDLDfZvMXrdBFzwvufzCyHVTONXTTg\" height=\"193\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/De-BSLaDLDfZvMXrdBFzwvufzCyHVTONXTTg\" width=\"416\"/></figure><p>This means That given</p><ul><li>The types <code>A, B</code></li><li>A function from <code>A to B</code></li><li>A function from <code>B to A</code></li></ul><p>We define a function called \u201c<code>codecRoundTrip</code>\u201d which takes an <code>\u201ca: A\u201d</code> and takes it through the functions and makes sure we get the same value of type A back.</p><p>This Law states (without giving away<strong> any implementation details</strong>), that the roundtrip we do on the given input does not \u201close\u201d any information.</p><blockquote>Another way of saying just that is by claiming that our types A and B are isomorphic.</blockquote><p>We can abstract even more, by using the cats-laws library with the <code>IsEq</code> case-class for defining an Equality description.</p><pre tabindex=\"0\"><code>import cats.laws._\ntrait CodecLaws[A, B] {\n  def serialize: A =&gt; B\n  def deserialize: B =&gt; A\n  def codecRoundTrip(a: A): cats.laws.IsEq[A] = serialize.andThen(deserialize)(a) &lt;-&gt; a\n}\n/** Represents two values of the same type that are expected to be equal. */\nfinal case class IsEq[A](lhs: A, rhs: A)</code></pre><p>What we get from this type and syntax is a <strong>description</strong> <strong>of equality</strong> between the two values instead of the equality result like before.</p><h3 id=\"the-codec-test\">The Codec Test</h3><p>It is time to test the laws we just defined. In order to do that, we will use the \u201c<a href=\"https://github.com/typelevel/discipline\" rel=\"noopener\">discipline</a>\u201d library.</p><pre><code>import cats.laws.discipline._\nimport org.scalacheck.{ Arbitrary, Prop }\ntrait CodecTests[A, B] extends org.typelevel.discipline.Laws {\n  def laws: CodecLaws[A, B]\n  def tests(\n    implicit\n    arbitrary: Arbitrary[A],\n    eqA: cats.Eq[A]\n  ): RuleSet =\n    new DefaultRuleSet(\n      name   = name,\n      parent = None,\n      \"roundTrip\" -&gt; Prop.forAll { a: A =&gt;\n        laws.codecRoundTrip(a)\n      }\n    )\n}</code></pre><p>We define a CodecTest trait that takes 2 type parameters <code>A and B</code>, which in our example will be <code>Person</code> and <code>JsResult</code>.</p><p>The trait holds an instance of the laws and defines a test method that takes an <code>Arbitrary[A]</code> and an equality checker (of type <code>Eq[A]</code>) and returns a <code>rule-set</code> for <code>scalacheck</code> to run.</p><p>Note that no tests actually run here. This gives us the power to run these tests which are defined just once for all the types we want</p><p>We can now commit to a specific type and implementation (like <code>Play-Json</code> serialization) by instantiating a <code>CodecTest</code> with the proper types.</p><pre tabindex=\"0\"><code>object JsonCodecTests {\n  def apply[A: Arbitrary](implicit format: Format[A]): CodecTests[A, JsValue] =\n    new CodecTests[A, JsValue] {\n      override def laws: CodecLaws[A, JsValue] =\n        CodecLaws[A, JsValue](format.reads, format.writes)\n    }\n}</code></pre><h4 id=\"a-type-detour\">A (type) detour</h4><p>But now we get the error:</p><pre tabindex=\"0\"><code>Error:(11, 38) type mismatch;\n found   : play.api.libs.json.JsResult[A]\n required: A</code></pre><p>We expected the types to flow from:</p><pre><code>  A  =&gt;  B  =&gt;  A</code></pre><p>But Play-Json types go from:</p><pre><code> A  =&gt;  JsValue  =&gt;  JsResult[A]</code></pre><p>This means that our deserialize function can succeed or fail and will not always return an A, but rather a container of A.</p><p>In order to abstract over the types, we now need to use the<code> F[_]</code> type constructor syntax:</p><pre tabindex=\"0\"><code>trait CodecLaws[F[_],A, B] {\n  def serialize: A =&gt; B\n  def deserialize: B =&gt; F[A]\n  def codecRoundTrip(a: A)(implicit app:Applicative[F]): IsEq[F[A]] =\n    serialize.andThen(deserialize)(a) &lt;-&gt; app.pure(a)\n}</code></pre><p>The <code>Applicative</code> instance is used to take a simple value of type A and lift it into the <code>Applicative</code> context which returns a value of type <code>F[A]</code>.</p><blockquote>This process is similar to taking some value <code>x</code> and lifting it to an <code>Option</code> context using <code>Some(x)</code>, or in our concrete example taking a value <code>a:A</code> and lifting it to the <code>JsResult</code> type using <code><a href=\"https://www.playframework.com/documentation/2.7.0/api/scala/play/api/libs/json/JsSuccess.html\" rel=\"noopener\">JsSuccess</a>(a)</code>.</blockquote><p>We can now finish the implementation for <code>CodecTests</code> and <code>JsonCodecTests</code> like this:</p><pre tabindex=\"0\"><code>trait CodecTests[F[_], A, B] extends org.typelevel.discipline.Laws {\n  def laws: CodecLaws[F, A, B]\n  def tests(\n    implicit\n    arbitrary: Arbitrary[A],\n    eqA: cats.Eq[F[A]],\n    applicative: Applicative[F]\n  ): RuleSet =\n    new DefaultRuleSet(\n      name   = name,\n      parent = None,\n      \"roundTrip\" -&gt; Prop.forAll { a: A =&gt;\n        laws.codecRoundTrip(a)\n      }\n    )\n}\nobject JsonCodecTests {\n  def apply[A: Arbitrary](implicit format: Format[A]): CodecTests[JsResult, A, JsValue] =\n    new CodecTests[JsResult, A, JsValue] {\n      override def laws: CodecLaws[JsResult, A, JsValue] =\n        CodecLaws[JsResult, A, JsValue](format.reads, format.writes)\n    }\n}</code></pre><p>And to define a working <code>Person</code> serialization test in <strong>1 line of code:</strong></p><pre tabindex=\"0\"><code>import JsonCodecSpec.Person\nimport play.api.libs.json._\nimport org.scalacheck.ScalacheckShapeless._\nimport org.scalatest.FunSuiteLike\nimport org.scalatest.prop.Checkers\nimport org.typelevel.discipline.scalatest.Discipline\nclass JsonCodecSpec extends Checkers with FunSuiteLike with Discipline { \n  checkAll(\"PersonSerdeTests\", JsonCodecTests[Person].tests)\n}</code></pre><figure><img alt=\"imdSWbMKWX8xBSGWLXuMy-iB04TAGBkgqg5l\" height=\"280\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/imdSWbMKWX8xBSGWLXuMy-iB04TAGBkgqg5l\" width=\"498\"/></figure><h3 id=\"the-power-of-abstraction\">The power of abstraction</h3><p>We were able to define our tests and laws without giving away any implementation details. This means we can switch to using a different library for serialization tomorrow and all our laws and tests will still hold.</p><h4 id=\"another-example\">Another example</h4><p>We can test this theory by adding support to BSON serialization using the <code>reactive-mongo</code> library:</p><pre tabindex=\"0\"><code>import cats.Id\nimport io.bigpanda.laws.serde.{ CodecLaws, CodecTests }\nimport org.scalacheck.Arbitrary\nimport reactivemongo.bson.{ BSONDocument, BSONReader, BSONWriter }\nobject BsonCodecTests {\n  def apply[A: Arbitrary](\n    implicit\n    reader: BSONReader[BSONDocument, A],\n    writer: BSONWriter[A, BSONDocument]\n  ): CodecTests[Id, A, BSONDocument] =\n    new CodecTests[Id, A, BSONDocument] {\n      override def laws: CodecLaws[Id, A, BSONDocument] =\n        CodecLaws[Id, A, BSONDocument](reader.read, writer.write)\noverride def name: String = \"BSON serde tests\"\n    }\n}</code></pre><p>The types here flow from</p><pre><code>A =&gt; BsonDocument =&gt; A</code></pre><p>and not <code>F[A]</code> as we had expected. Luckily for us, we have a solution and use the Id-type to represent just that.</p><p>And given the (very long) serializer definition:</p><pre tabindex=\"0\"><code>implicit val personBsonFormat\n  : BSONReader[BSONDocument, Person] with BSONWriter[Person, BSONDocument] =\n  new BSONReader[BSONDocument, Person] with BSONWriter[Person, BSONDocument] {\n    override def read(bson: BSONDocument): Person =\n      Person(bson.getAs[String](\"name\").get, bson.getAs[Int](\"age\").get)\noverride def write(t: Person): BSONDocument =\n      BSONDocument(\"name\" -&gt; t.name, \"age\" -&gt; t.age)\n  }</code></pre><p>we can now define BsonCodecTests in all its <strong>1</strong> line of logic glory.</p><pre tabindex=\"0\"><code>class BsonCodecSpec extends Checkers with FunSuiteLike with Discipline {\n    checkAll(\"PersonSerdeTests\", BsonCodecTests[Person].tests)\n}</code></pre><h3 id=\"a-first-order-logic-perspective-on-our-code\">A (First-order) logic perspective on our code</h3><p>Our first test attempt can be described as follows:</p><pre><code>\u2203p:Person,s:OFormat that holds : s.read(s.write(p)) &lt;-&gt; p</code></pre><p>Meaning, <code>for the specific person p(\u201cJohn Doe\u201d,32)</code> and <code>for the format <strong>s</strong></code>, the following statement is true:<code> decode(encode(p)) &lt;-</code>&gt; p.</p><p>The second attempt (using <code>PBT</code>) can be:</p><pre><code>\u2203s:OFormat, \u2200p:Person the following should hold :  s.read(s.write(p)) &lt;-&gt; p</code></pre><p>Which means,<code> <strong>for all </strong>persons p</code> and<code> for the specific format <strong>s</strong></code>, the following is true: <code>decode(encode(p))&lt;</code>-&gt;p.</p><p>The third (and most powerful statement thus far) using <code>law testing</code>:</p><pre><code>\u2200s:Encoder, \u2200p:Person the the following should hold :  s.read(s.write(p)) &lt;-&gt; p</code></pre><p>Which means,<strong> <code>for all </code></strong><code>formats s</code>, and <code><strong>for all</strong> persons p</code>, the following is true: <code>decode(encode(p))&lt;</code>-&gt;p.</p><h4 id=\"summary\"><strong>Summary</strong></h4><ul><li>Law testing allows you to reason about your data-types and functions in a mathematical and concise way and provides a totally new paradigm for testing your code!</li><li>Most of the type level libraries you use (like <code>cats</code>, <code>circe</code> and many more) use law testing internally to test their data-types.</li><li>Avoid writing specific test-cases for your data-types and functions and try to generalize them using property-based law tests.</li></ul><p>Thank you for reaching this far! I am super excited about finding more abstract and useful laws that I can use in my code! Please let me know about any you\u2019ve used or can think of.</p><p>More inspiring and detailed content can be found in the <a href=\"https://typelevel.org/cats/typeclasses/lawtesting.html\" rel=\"noopener\">cats-laws</a> site or <a href=\"https://github.com/circe/circe/blob/master/modules/testing/shared/src/main/scala/io/circe/testing/CodecTests.scala\" rel=\"noopener\">circe</a>.</p><p>The complete code examples can be found <a href=\"https://gist.github.com/dorsev/0fdd8315228d7ef6914b27650f817ae6\" rel=\"noopener\">here</a>.</p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nProperty-based law testing is one of the most powerful tools in the scala ecosystem. In this post, I\u2019ll explain how to use law testing and the value it\u2019ll give you using in-depth code examples.This post is aimed for Scala developers who want to improve their testing knowledge and skills. It assumes some knowledge of Scala, cats, and other functional libraries.IntroductionYou might be familiar with types which are a set of values (for example Int values are : 1,2,3\u2026 String values are : \u201cJohn Doe\u201d etc).You also might be familiar with functions which is a mapping from Input type to Output type.A property is defined on a type or a function and describes its desired behavior.So what is a Law? Keep on reading!A concrete exampleHere is our beloved Person data type:case class Person(name: String, age: Int)And serialization code using the Play-Json , a library that allows transforming your Person type into JSON :val personFormat: OFormat[Person] = new OFormat[Person] {\n  override def reads(json: JsValue): JsResult[Person] = {\n    val name = (json \\ \"name\").as[String]\n    val age = (json \\ \"age\").as[Int]\n    JsSuccess(Person(name, age))\n  }\noverride def writes(o: Person): JsObject =\n    JsObject(Seq(\"name\" -> JsString(o.name), \n                 \"age\" -> JsNumber(o.age)))\n}We can now test this serialization function on a specific input like this:import org.scalatest._\nclass PersonSerdeSpec extends WordSpecLike with Matchers {\n  \"should serialize and deserialize a person\" in {\n    val person = Person(\"John Doe\", 32)\n    val actualPerson =\n      personFormat.reads(personFormat.writes(person))\n    actualPerson.asOpt.shouldEqual(Some(person))\n  }\n}But, we now need to ask ourselves, whether all people will serialize successfully? What about a person with invalid data (such as negative age)? Will we want to repeat this thought process of finding edge-cases for all our test data?And most importantly, will this code remain readable over time? (e.g.: changing the person data type [adding a LastName field], repeated tests for other data types, etc)\u201c We can solve any problem by introducing an extra level of indirection\u201d.Property-based testingThe first weapon in our disposal is Property-based testing (PBT). PBT works by defining a property, which is a high-level specification of behavior that should hold for all values of the specific type.In our example, the property will be:For every person p, if we serialize and deserialize them, we should get back the same person.Writing this property using scala check looks like this:object PersonSerdeSpec extends org.scalacheck.Properties(\"PersonCodec\") {\n  property(\"round trip consistency\") = \norg.scalacheck.Prop.forAll { a: Person =>\n    personFormat.reads(personFormat.writes(a)).asOpt.contains(a)\n  }\n}The property check requires a way to generate Persons. This is done by using an Arbitrary[Person] which can be defined like this:implicit val personArb: Arbitrary[Person] = Arbitrary {\n  for {\n    name <- Gen.alphaStr\n    age  <- Gen.chooseNum(0, 120)\n  } yield Person(name, age)\n}Furthermore, we can use \u201cscalacheck-shapeless\u201d- an amazing library which eliminates (almost) all needs for the verbose (quite messy and highly bug-prone) arbitrary type definition by generating it for us!This can be done by adding:libraryDependencies += \"com.github.alexarchambault\" %% \"scalacheck-shapeless_1.14\" % \"1.2.0\"and importing the following in our code:import org.scalacheck.ScalacheckShapeless._And then we can remove the personArb instance we defined earlier.The Codec LawLet\u2019s try to abstract further, by defining the laws of our data type:trait CodecLaws[A, B] {\n  def serialize: A => B\n  def deserialize: B => A\n  def codecRoundTrip(a: A): Boolean = serialize.\nandThen(deserialize)(a) == a\n}This means That givenThe types A, BA function from A to BA function from B to AWe define a function called \u201ccodecRoundTrip\u201d which takes an \u201ca: A\u201d and takes it through the functions and makes sure we get the same value of type A back.This Law states (without giving away any implementation details), that the roundtrip we do on the given input does not \u201close\u201d any information.Another way of saying just that is by claiming that our types A and B are isomorphic.We can abstract even more, by using the cats-laws library with the IsEq case-class for defining an Equality description.import cats.laws._\ntrait CodecLaws[A, B] {\n  def serialize: A => B\n  def deserialize: B => A\n  def codecRoundTrip(a: A): cats.laws.IsEq[A] = serialize.andThen(deserialize)(a) <-> a\n}\n/** Represents two values of the same type that are expected to be equal. */\nfinal case class IsEq[A](lhs: A, rhs: A)What we get from this type and syntax is a description of equality between the two values instead of the equality result like before.The Codec TestIt is time to test the laws we just defined. In order to do that, we will use the \u201cdiscipline\u201d library.import cats.laws.discipline._\nimport org.scalacheck.{ Arbitrary, Prop }\ntrait CodecTests[A, B] extends org.typelevel.discipline.Laws {\n  def laws: CodecLaws[A, B]\n  def tests(\n    implicit\n    arbitrary: Arbitrary[A],\n    eqA: cats.Eq[A]\n  ): RuleSet =\n    new DefaultRuleSet(\n      name   = name,\n      parent = None,\n      \"roundTrip\" -> Prop.forAll { a: A =>\n        laws.codecRoundTrip(a)\n      }\n    )\n}We define a CodecTest trait that takes 2 type parameters A and B, which in our example will be Person and JsResult.The trait holds an instance of the laws and defines a test method that takes an Arbitrary[A] and an equality checker (of type Eq[A]) and returns a rule-set for scalacheck to run.Note that no tests actually run here. This gives us the power to run these tests which are defined just once for all the types we wantWe can now commit to a specific type and implementation (like Play-Json serialization) by instantiating a CodecTest with the proper types.object JsonCodecTests {\n  def apply[A: Arbitrary](implicit format: Format[A]): CodecTests[A, JsValue] =\n    new CodecTests[A, JsValue] {\n      override def laws: CodecLaws[A, JsValue] =\n        CodecLaws[A, JsValue](format.reads, format.writes)\n    }\n}A (type) detourBut now we get the error:Error:(11, 38) type mismatch;\n found   : play.api.libs.json.JsResult[A]\n required: AWe expected the types to flow from:  A  =>  B  =>  ABut Play-Json types go from: A  =>  JsValue  =>  JsResult[A]This means that our deserialize function can succeed or fail and will not always return an A, but rather a container of A.In order to abstract over the types, we now need to use the F[_] type constructor syntax:trait CodecLaws[F[_],A, B] {\n  def serialize: A => B\n  def deserialize: B => F[A]\n  def codecRoundTrip(a: A)(implicit app:Applicative[F]): IsEq[F[A]] =\n    serialize.andThen(deserialize)(a) <-> app.pure(a)\n}The Applicative instance is used to take a simple value of type A and lift it into the Applicative context which returns a value of type F[A].This process is similar to taking some value x and lifting it to an Option context using Some(x), or in our concrete example taking a value a:A and lifting it to the JsResult type using JsSuccess(a).We can now finish the implementation for CodecTests and JsonCodecTests like this:trait CodecTests[F[_], A, B] extends org.typelevel.discipline.Laws {\n  def laws: CodecLaws[F, A, B]\n  def tests(\n    implicit\n    arbitrary: Arbitrary[A],\n    eqA: cats.Eq[F[A]],\n    applicative: Applicative[F]\n  ): RuleSet =\n    new DefaultRuleSet(\n      name   = name,\n      parent = None,\n      \"roundTrip\" -> Prop.forAll { a: A =>\n        laws.codecRoundTrip(a)\n      }\n    )\n}\nobject JsonCodecTests {\n  def apply[A: Arbitrary](implicit format: Format[A]): CodecTests[JsResult, A, JsValue] =\n    new CodecTests[JsResult, A, JsValue] {\n      override def laws: CodecLaws[JsResult, A, JsValue] =\n        CodecLaws[JsResult, A, JsValue](format.reads, format.writes)\n    }\n}And to define a working Person serialization test in 1 line of code:import JsonCodecSpec.Person\nimport play.api.libs.json._\nimport org.scalacheck.ScalacheckShapeless._\nimport org.scalatest.FunSuiteLike\nimport org.scalatest.prop.Checkers\nimport org.typelevel.discipline.scalatest.Discipline\nclass JsonCodecSpec extends Checkers with FunSuiteLike with Discipline { \n  checkAll(\"PersonSerdeTests\", JsonCodecTests[Person].tests)\n}The power of abstractionWe were able to define our tests and laws without giving away any implementation details. This means we can switch to using a different library for serialization tomorrow and all our laws and tests will still hold.Another exampleWe can test this theory by adding support to BSON serialization using the reactive-mongo library:import cats.Id\nimport io.bigpanda.laws.serde.{ CodecLaws, CodecTests }\nimport org.scalacheck.Arbitrary\nimport reactivemongo.bson.{ BSONDocument, BSONReader, BSONWriter }\nobject BsonCodecTests {\n  def apply[A: Arbitrary](\n    implicit\n    reader: BSONReader[BSONDocument, A],\n    writer: BSONWriter[A, BSONDocument]\n  ): CodecTests[Id, A, BSONDocument] =\n    new CodecTests[Id, A, BSONDocument] {\n      override def laws: CodecLaws[Id, A, BSONDocument] =\n        CodecLaws[Id, A, BSONDocument](reader.read, writer.write)\noverride def name: String = \"BSON serde tests\"\n    }\n}The types here flow fromA => BsonDocument => Aand not F[A] as we had expected. Luckily for us, we have a solution and use the Id-type to represent just that.And given the (very long) serializer definition:implicit val personBsonFormat\n  : BSONReader[BSONDocument, Person] with BSONWriter[Person, BSONDocument] =\n  new BSONReader[BSONDocument, Person] with BSONWriter[Person, BSONDocument] {\n    override def read(bson: BSONDocument): Person =\n      Person(bson.getAs[String](\"name\").get, bson.getAs[Int](\"age\").get)\noverride def write(t: Person): BSONDocument =\n      BSONDocument(\"name\" -> t.name, \"age\" -> t.age)\n  }we can now define BsonCodecTests in all its 1 line of logic glory.class BsonCodecSpec extends Checkers with FunSuiteLike with Discipline {\n    checkAll(\"PersonSerdeTests\", BsonCodecTests[Person].tests)\n}A (First-order) logic perspective on our codeOur first test attempt can be described as follows:\u2203p:Person,s:OFormat that holds : s.read(s.write(p)) <-> pMeaning, for the specific person p(\u201cJohn Doe\u201d,32) and for the format s, the following statement is true: decode(encode(p)) <-> p.The second attempt (using PBT) can be:\u2203s:OFormat, \u2200p:Person the following should hold :  s.read(s.write(p)) <-> pWhich means, for all persons p and for the specific format s, the following is true: decode(encode(p))<->p.The third (and most powerful statement thus far) using law testing:\u2200s:Encoder, \u2200p:Person the the following should hold :  s.read(s.write(p)) <-> pWhich means, for all formats s, and for all persons p, the following is true: decode(encode(p))<->p.SummaryLaw testing allows you to reason about your data-types and functions in a mathematical and concise way and provides a totally new paradigm for testing your code!Most of the type level libraries you use (like cats, circe and many more) use law testing internally to test their data-types.Avoid writing specific test-cases for your data-types and functions and try to generalize them using property-based law tests.Thank you for reaching this far! I am super excited about finding more abstract and useful laws that I can use in my code! Please let me know about any you\u2019ve used or can think of.More inspiring and detailed content can be found in the cats-laws site or circe.The complete code examples can be found here.\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 12195, "excerpt": "Property-based law testing is one of the most powerful tools in the scala\necosystem. In this post, I\u2019ll explain how to use law testing and the value it\u2019ll\ngive you using in-depth code examples.\n\nThis post is aimed for Scala developers who want to improve their testing\nknowledge and skills. It assumes some knowledge of Scala, cats, and other\nfunctional libraries.\n\nIntroduction\n * You might be familiar with types which are a set of values (for example Int\n   values are : 1,2,3\u2026 String values are :", "siteName": "freeCodeCamp.org", "publishedTime": "2019-04-22T16:48:22.000Z", "id": "cf9f97bb7818eaddb71fa086d22aab46cce9b1f3", "url": "https://www.freecodecamp.org/news/an-introduction-to-law-testing-in-scala-4243d72272f9/", "domain": "freecodecamp.org", "date": "2023-12-27T18:11:49.414854", "resultUri": "http://localhost:3000/result/cf9f97bb7818eaddb71fa086d22aab46cce9b1f3", "query": {"url": ["https://www.freecodecamp.org/news/an-introduction-to-law-testing-in-scala-4243d72272f9/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "An introduction to Law Testing in Scala", "description": "Property-based law testing is one of the most powerful tools in the scala ecosystem. In this post, I\u2019ll explain how to use law testing and the value it\u2019ll give you using in-depth code examples. This post is aimed for Scala developers who want to improve their testing knowledge and skills.", "url": "https://www.freecodecamp.org/news/an-introduction-to-law-testing-in-scala-4243d72272f9/", "image": "https://cdn-media-2.freecodecamp.org/w1280/5f9ca2eb740569d1a4ca57e8.jpg", "image:width": "1280", "image:height": "647"}, "twitter": {"card": "summary_large_image", "title": "An introduction to Law Testing in Scala", "description": "Property-based law testing is one of the most powerful tools in the scala ecosystem. In this post, I\u2019ll explain how to use law testing and the value it\u2019ll give you using in-depth code examples. This post is aimed for Scala developers who want to improve their testing knowledge and skills.", "url": "https://www.freecodecamp.org/news/an-introduction-to-law-testing-in-scala-4243d72272f9/", "image": "https://cdn-media-2.freecodecamp.org/w1280/5f9ca2eb740569d1a4ca57e8.jpg", "label1": "Written by", "data1": "dor sever", "label2": "Filed under", "data2": "Scala, Programming, Functional Programming, Testing, Tech", "site": "@freecodecamp", "creator": "@dor_sever"}}}