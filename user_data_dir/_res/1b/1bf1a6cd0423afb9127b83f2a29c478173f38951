{"title": "You should never ever run directly against Node.js in production. Maybe.", "byline": "Burke Holland", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>You should never ever run directly against Node.js in production. Maybe.</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>Sometimes I wonder if I know much of anything at all.</p><p>Just a few weeks ago I was talking to a friend who mentioned off-hand, \u201cyou would never run an application directly against Node in production\u201d. </p><p>I nodded vigorously to signal that I <em>also</em> would never ever run against Node in production because\u2026hahaha\u2026.everyone knows that. But I didn\u2019t know that! Should I have known that?!?? AM I STILL ALLOWED TO PROGRAM?</p><p>If I was to draw a Venn Diagram of what I know vs what I feel like everyone else knows, it would look like this\u2026</p><figure><img alt=\"1*ThJbM2JMjrnTuHczo0tLqw\" height=\"801\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1*ThJbM2JMjrnTuHczo0tLqw.png\" width=\"800\"/></figure><p>By the way, that tiny dot gets smaller the older I get.</p><p>There is a better diagram created by <a href=\"https://medium.com/counter-intuition/overcoming-impostor-syndrome-bdae04e46ec5\" rel=\"noopener\">Alicia Liu</a> that kind of changed my life. She says that it\u2019s more like this\u2026</p><figure><img alt=\"1*N7vv39ri9yC0l6krsSFlQA\" height=\"300\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1*N7vv39ri9yC0l6krsSFlQA.png\" width=\"800\"/></figure><p>I love this diagram so much because I want it to be true. I don\u2019t want to spend the rest of my life as a tiny, shrinking blue dot of insignificance.</p><p>SO DRAMATIC. Blame Pandora. I don\u2019t control what gets played next while I\u2019m writing this article and <a href=\"https://www.youtube.com/watch?v=ixG3DgrPC3c\" rel=\"noopener\">Dashboard Confessional</a> is a helluva drug.</p><p>Well, assuming that Alicia\u2019s diagram is true, I would like to share with you what I <em>now</em> know about running Node apps in production. Perhaps our relative Venn Diagrams don\u2019t overlap on this subject.</p><p>First off, let\u2019s address the statement \u201cnever run apps directly against Node in production\u201d.</p><h4 id=\"never-run-directly-against-node-in-production\">Never run directly against Node in production</h4><p>Maybe. But maybe not. Let\u2019s talk about the reasoning behind this statement. First, let\u2019s look at why not.</p><p>Say we have a simple Express server. The simplest Express server I can think of\u2026</p><pre tabindex=\"0\"><code>const express = require(\"express\");\nconst app = express();\nconst port = process.env.PORT || 3000;\n\n// viewed at http://localhost:3000\napp.get(\"/\", function(req, res) {\n  res.send(\"Again I Go Unnoticed\");\n});\n\napp.listen(port, () =&gt; console.log(`Example app listening on port ${port}!`));</code></pre><p>We would run this with a start script in the <code>package.json</code> file.</p><pre><code>\"scripts\": {\n  \"dev\": \"npx supervisor index.js\",\n  \"start\": \"node index.js\"\n}</code></pre><figure><img alt=\"1*VceC98Qk5zKqzBmiu1szDQ\" height=\"478\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1*VceC98Qk5zKqzBmiu1szDQ.png\" width=\"800\"/></figure><p>There are sort of two problems here. The first is a development problem and the second is a production problem.</p><p>The development problem is that when we change the code, we have to stop and start the application to get our changes picked up.</p><p>To solve that, we usually use some sort of Node process manager like <code>supervisor</code> or <code>nodemon</code>. These packages will watch our project and restart our server whenever we make changes. I usually do that like this\u2026</p><pre><code>\"scripts\": {  \"dev\": \"npx supervisor index.js\",  \"start\": \"node index.js\"}</code></pre><p>Then I run <code>npm run dev</code>. Note that I\u2019m running <code>npx supervisor</code> here which allows me to use the <code>supervisor</code> package without having to install it. I \u2764\ufe0f 2019. Mostly.</p><p>Our other problem is that we\u2019re still running directly against Node and we already said that was bad and now we\u2019re about to find out why.</p><p>I\u2019m going to add another route here that attempts to read a file from disk that does not exist. This is an error that could easily show up in any real-world application.</p><pre tabindex=\"0\"><code>const express = require(\"express\");\nconst app = express();\nconst fs = require(\"fs\");\nconst port = process.env.PORT || 3000;\n\n// viewed at http://localhost:3000\napp.get(\"/\", function(req, res) {\n  res.send(\"Again I Go Unnoticed\");\n});\n\napp.get(\"/read\", function(req, res) {\n  // this does not exist\n  fs.createReadStream(\"my-self-esteem.txt\");\n});\n\napp.listen(port, () =&gt; console.log(`Example app listening on port ${port}!`));</code></pre><p>If we run this directly against Node with <code>npm start</code> and navigate to the <code>read </code>endpoint, we get an error because that file doesn\u2019t exist.</p><figure><img alt=\"1*pAUoJV-LRJwxs7MRegnuoA\" height=\"478\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1*pAUoJV-LRJwxs7MRegnuoA.png\" width=\"800\"/></figure><p>Which \u2014 no big deal right? It\u2019s one error. It happens.</p><p>NO. Big deal. If you go back to your terminal you will see that the application is completely down.</p><figure><img alt=\"1*69LuEt53W2isIXP34vUlYA\" height=\"450\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1*69LuEt53W2isIXP34vUlYA.png\" width=\"800\"/></figure><p>Which means if you go back to the browser and try to go to the root URL of the site, you get the same error page. One error in one method took the application down for <strong>everyone</strong>.</p><p>That\u2019s bad. Like really bad. This is one of the main reasons why people say <strong>\u201cnever run directly against Node in production\u201d</strong>.</p><p>OK. So if we can\u2019t run against Node in production, what is the right way to run Node in production?</p><h4 id=\"options-for-production-node\">Options for production Node</h4><p>We\u2019ve got a few options.</p><p>One of them would be to simply use something like <code>supervisor</code> or <code>nodemon</code> in production the same way we are using them in dev. That would work, but these tools are a little on the lightweight side. A better option is something called pm2.</p><h4 id=\"pm2-the-rescue\">pm2 the rescue</h4><p>pm2 is a Node process manager that has lots of bells and whistles. Just like everything else \u201cJavaScript\u201d, you install it (globally) from <code>npm</code> \u2014 or you can just use <code>npx</code> again. I don\u2019t want to tell you how to live your life.</p><p>There are a lot of ways to run your app with pm2. The simplest way is to just call <code>pm2 start</code> on your entry point.</p><pre><code>\"scripts\": {\n  \"start\": \"pm2 start index.js\",\n  \"dev\": \"npx supervisor index.js\"\n},</code></pre><p>And you\u2019ll see something like this in the terminal\u2026</p><figure><img alt=\"1*uvsnmQahRBHtnh0X7tt_xA\" height=\"450\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1*uvsnmQahRBHtnh0X7tt_xA.png\" width=\"800\"/></figure><p>That\u2019s our process running in the background monitored by pm2. If you visit the <code>read</code> endpoint and crash the application, pm2 will automatically restart it. You won\u2019t see any of that in the terminal because it\u2019s running in the background. If you want to watch pm2 do its thing, you gotta run <code>pm2 log 0</code>. The <code>0</code> is the ID of the process we want to see logs for.</p><figure><img alt=\"1*AbR1eyySpr2IllYtA4wE-Q\" height=\"450\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1*AbR1eyySpr2IllYtA4wE-Q.png\" width=\"800\"/></figure><p>There we go! You can see pm2 restart the application when it goes down because of our unhandled error.</p><p>We can also pull out our dev command and have pm2 watch files for us and restart on any changes.</p><pre><code>\"scripts\": {\n  \"start\": \"pm2 start index.js --watch\",\n  \"dev\": \"npx supervisor index.js\"\n},</code></pre><p>Note that because pm2 runs things in the background, you can\u2019t just <code>ctrl+c</code> your way out of a running pm2 process. You have to stop it by passing the ID or the name.</p><p><code>pm2 stop 0</code></p><p><code>pm2 stop index</code></p><p>Also, note that pm2 retains a reference to the process so you can restart it.</p><figure><img alt=\"1*Z4yLru6TmwUVQv84DkZDAQ\" height=\"450\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1*Z4yLru6TmwUVQv84DkZDAQ.png\" width=\"800\"/></figure><p>If you want to delete that process reference, you need to run <code>pm2 delete</code>. You can stop and delete a process in one command with <code>delete</code>.</p><p><code>pm2 delete index</code></p><p>We can also use pm2 to run multiple processes of our application. pm2 will automatically balance the load across those instances.</p><h4 id=\"multiple-processes-with-pm2-fork-mode\">Multiple processes with pm2 fork mode</h4><p>pm2 has a ton of configuration options and those are contained in an \u201cecosystem\u201d file. To create one, run <code>pm2 init</code>. You\u2019ll get something like this\u2026</p><pre tabindex=\"0\"><code>module.exports = {\n  apps: [\n    {\n      name: \"Express App\",\n      script: \"index.js\",\n      instances: 4,\n      autorestart: true,\n      watch: true,\n      max_memory_restart: \"1G\",\n      env: {\n        NODE_ENV: \"development\"\n      },\n      env_production: {\n        NODE_ENV: \"production\"\n      }\n    }\n  ]\n};</code></pre><p>I\u2019m going to ignore the \u201cdeploy\u201d section in this article because I have no idea what it does.</p><p>The \u201capps\u201d section is where you define the apps you want pm2 to run and monitor. You can run more than one. A lot of these configuration settings are probably self-explanatory. The one that I want to focus on here is the <strong>instances</strong> setting.</p><p>pm2 can run multiple instances of your application. You can pass in a number of instances that you want to run and pm2 will spin up that many. So if we wanted to run 4 instances, we could have the following configuration file.</p><pre tabindex=\"0\"><code>module.exports = {\n  apps: [\n    {\n      name: \"Express App\",\n      script: \"index.js\",\n      instances: 4,\n      autorestart: true,\n      watch: true,\n      max_memory_restart: \"1G\",\n      env: {\n        NODE_ENV: \"development\"\n      },\n      env_production: {\n        NODE_ENV: \"production\"\n      }\n    }\n  ]\n};</code></pre><p>Then we just run it with <code>pm2 start</code>.</p><figure><img alt=\"1*_rYp7NMQTCMmOfBV0w0RTw\" height=\"450\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1*_rYp7NMQTCMmOfBV0w0RTw.png\" width=\"800\"/></figure><p>pm2 is now running in \u201ccluster\u201d mode. Each of these processes is running on a different CPU on my machine, depending on how many cores I have. If we wanted to run a process for each core without knowing how many cores we have, we can just pass the <code>max</code> parameter to the <code>instances</code> value.</p><pre><code>{\n   ...\n   instances: \"max\",\n   ...\n}</code></pre><p>Let\u2019s find out how many cores I\u2019ve got in this machine.</p><figure><img alt=\"1*nhjuG0xFsMgkYB382_xfyw\" height=\"450\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1*nhjuG0xFsMgkYB382_xfyw.png\" width=\"800\"/></figure><p>8 CORES! Holy crap. I\u2019m gonna install Subnautica on my Microsoft issued machine. Don\u2019t tell them I said that.</p><p>The good thing about running processes on separate CPU\u2019s is that if you have a process that runs amok and takes up 100% of the CPU, the others will still function. If you pass in more instances than you have cores, pm2 will double up processes on CPU\u2019s as necessary.</p><p>You can do a WHOLE lot more with pm2, including monitoring and otherwise wrangling those pesky <a href=\"https://medium.freecodecamp.org/\" rel=\"noopener\">environment variables</a>.</p><p>One other item of note: if for some reason you want pm2 to run your <code>npm start</code> script, you can do that by running npm as the process and passing the <code>-- start</code>. The space before the \u201cstart\u201d is super important here.</p><pre><code>pm2 start npm -- start</code></pre><p>In <a href=\"https://docs.microsoft.com/en-us/azure/app-service/?WT.mc_id=medium-blog-buhollan\" rel=\"noopener\">Azure AppService</a>, we include pm2 by default in the background. If you want to use pm2 in Azure, you don\u2019t need to include it in your <code>package.json</code> file. You can just add an ecosystem file and you\u2019re good to go.</p><figure><img alt=\"1*TYOm2q57lXad3te35tGwqg\" height=\"495\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1*TYOm2q57lXad3te35tGwqg.png\" width=\"800\"/></figure><p>OK! Now that we\u2019ve learned all about pm2, let\u2019s talk about why you may not want to use it and it might indeed be ok to run directly against Node.</p><h4 id=\"running-directly-against-node-in-production\">Running directly against Node in production</h4><p>I had some questions on this so I reached out to <a href=\"https://twitter.com/bitandbang\" rel=\"noopener\">Tierney Cyren</a> who is part of the enormous orange circle of knowledge, especially when it comes to Node.</p><p>Tierney pointed out a few drawbacks to using Node based process managers like pm2.</p><p>The main reason is that you shouldn\u2019t use Node to monitor Node. You don\u2019t want to use the thing that you are monitoring to monitor that thing. It\u2019s kind of like you asking my teenage son to supervise himself on a Friday night: Will that end badly? It might, and it might not. But you\u2019re about to find out the hard way.</p><p>Tierney recommends that you not have a Node process manager running your application at all. Instead, have something at a higher level which watches multiple separate instances of your application. For example, an ideal setup would be if you had a Kubernetes cluster with your app running on separate containers. Kubernetes can then monitor those containers and if any of them go down, it can bring them back and report on their health.</p><p>In this case, you <strong>can</strong> run directly against Node because you are monitoring at a higher level.</p><p>As it turns out, Azure is already doing this. If we don\u2019t push a pm2 ecosystem file to Azure, it will start the application with our <code>package.json</code> file start script and we can run directly against Node.</p><pre><code>\"scripts\": {\n  \"start\": \"node index.js\"\n}</code></pre><p>In this case, we are running directly against Node and it\u2019s OK. If the application were to crash, you\u2019ll notice that it comes back. That\u2019s because in Azure, your app runs in a container. Azure is orchestrating the container in which your app is running and knows when it faceplants.</p><figure><img alt=\"1*YSvtZOR4DIt1McSdDChVew\" height=\"495\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1*YSvtZOR4DIt1McSdDChVew.png\" width=\"800\"/></figure><p>But you still only have one instance here. It takes the container a second to come back online after it crashes meaning that there could be a few seconds of downtime for your users.</p><p>Ideally, you would want more than one container running. The solution to this would be to deploy multiple instances of your application to multiple Azure AppService sites and then use Azure Front Door to load balance the apps behind a single IP address. Front Door will know when a container is down and will route traffic to other healthy instances of your application.</p><p><a href=\"https://azure.microsoft.com/en-us/services/frontdoor/?WT.mc_id=medium-blog-buhollan\" rel=\"noopener\"><strong>Azure Front Door Service | Microsoft Azure</strong></a><br/><a href=\"https://azure.microsoft.com/en-us/services/frontdoor/?WT.mc_id=medium-blog-buhollan\" rel=\"noopener\"><em>Deliver, protect and track the performance of your globally distributed microservice applications with Azure Front Door\u2026</em>azure.microsoft.com</a></p><h4 id=\"systemd\">systemd</h4><p>Another suggestion that Tierney had is to run Node with <code>systemd</code>. I don\u2019t understand too much (or anything at all) about <code>systemd</code> and I\u2019ve already messed this phrasing up once already, so I\u2019ll let Tierney say it in his own words\u2026</p><blockquote>This option is only possible if you have access to Linux in your deployment and you control the way that Node is started on a service level. If you\u2019re running your Node.js process in a long-running Linux VM, like Azure VMs, you\u2019re in a good place to run Node.js with systemd. If you are just deploying your files to a service like Azure AppService or Heroku or running inside of a containerized environment like Azure Container Instances, you should probably steer clear of this option.</blockquote><p><a href=\"https://nodesource.com/blog/running-your-node-js-app-with-systemd-part-1/\" rel=\"noopener\"><strong>Running Your Node.js App With Systemd - Part 1</strong></a><br/><a href=\"https://nodesource.com/blog/running-your-node-js-app-with-systemd-part-1/\" rel=\"noopener\"><em>You've written the next great application, in Node, and you are ready to unleash it upon the world. Which means you can\u2026</em>nodesource.com</a></p><h4 id=\"node-js-worker-threads\">Node.js Worker Threads</h4><p>Tierney also wants you to know that Worker Threads are coming in Node. This will allow you to start your app on multiple \u201cworkers\u201d (threads) thusly negating the need for something like pm2. Maybe. I don\u2019t know. I didn\u2019t really read the article.</p><p><a href=\"https://nodejs.org/api/worker_threads.html\" rel=\"noopener\"><strong>Node.js v11.14.0 Documentation</strong></a><br/><a href=\"https://nodejs.org/api/worker_threads.html\" rel=\"noopener\"><em>The worker_threads module enables the use of threads that execute JavaScript in parallel. To access it: const worker =\u2026</em>nodejs.org</a></p><h4 id=\"be-an-adult\">Be an Adult</h4><p>Tierney\u2019s last suggestion was to just handle the error and write some tests like an adult. But who has time for that?</p><h4 id=\"the-tiny-circle-abides\">The tiny circle abides</h4><p>Now you know most of what is in the tiny blue circle. The rest is just useless facts about emo bands and beer.</p><p>For more information on pm2, Node and Azure, check out the following resources\u2026</p><ul><li><a href=\"http://pm2.keymetrics.io/\" rel=\"noopener\">http://pm2.keymetrics.io/</a></li><li><a href=\"https://code.visualstudio.com/tutorials/nodejs-deployment/getting-started?WT.mc_id=medium-blog-buhollan\" rel=\"noopener\">Node.js deployment on VS Code</a></li><li><a href=\"https://azurecasts.com/2019/03/31/002-node-vscode/\" rel=\"noopener\">Deploy a simple Node site to Azure</a></li></ul>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nSometimes I wonder if I know much of anything at all.Just a few weeks ago I was talking to a friend who mentioned off-hand, \u201cyou would never run an application directly against Node in production\u201d. I nodded vigorously to signal that I also would never ever run against Node in production because\u2026hahaha\u2026.everyone knows that. But I didn\u2019t know that! Should I have known that?!?? AM I STILL ALLOWED TO PROGRAM?If I was to draw a Venn Diagram of what I know vs what I feel like everyone else knows, it would look like this\u2026By the way, that tiny dot gets smaller the older I get.There is a better diagram created by Alicia Liu that kind of changed my life. She says that it\u2019s more like this\u2026I love this diagram so much because I want it to be true. I don\u2019t want to spend the rest of my life as a tiny, shrinking blue dot of insignificance.SO DRAMATIC. Blame Pandora. I don\u2019t control what gets played next while I\u2019m writing this article and Dashboard Confessional is a helluva drug.Well, assuming that Alicia\u2019s diagram is true, I would like to share with you what I now know about running Node apps in production. Perhaps our relative Venn Diagrams don\u2019t overlap on this subject.First off, let\u2019s address the statement \u201cnever run apps directly against Node in production\u201d.Never run directly against Node in productionMaybe. But maybe not. Let\u2019s talk about the reasoning behind this statement. First, let\u2019s look at why not.Say we have a simple Express server. The simplest Express server I can think of\u2026const express = require(\"express\");\nconst app = express();\nconst port = process.env.PORT || 3000;\n\n// viewed at http://localhost:3000\napp.get(\"/\", function(req, res) {\n  res.send(\"Again I Go Unnoticed\");\n});\n\napp.listen(port, () => console.log(`Example app listening on port ${port}!`));We would run this with a start script in the package.json file.\"scripts\": {\n  \"dev\": \"npx supervisor index.js\",\n  \"start\": \"node index.js\"\n}There are sort of two problems here. The first is a development problem and the second is a production problem.The development problem is that when we change the code, we have to stop and start the application to get our changes picked up.To solve that, we usually use some sort of Node process manager like supervisor or nodemon. These packages will watch our project and restart our server whenever we make changes. I usually do that like this\u2026\"scripts\": {  \"dev\": \"npx supervisor index.js\",  \"start\": \"node index.js\"}Then I run npm run dev. Note that I\u2019m running npx supervisor here which allows me to use the supervisor package without having to install it. I \u2764\ufe0f 2019. Mostly.Our other problem is that we\u2019re still running directly against Node and we already said that was bad and now we\u2019re about to find out why.I\u2019m going to add another route here that attempts to read a file from disk that does not exist. This is an error that could easily show up in any real-world application.const express = require(\"express\");\nconst app = express();\nconst fs = require(\"fs\");\nconst port = process.env.PORT || 3000;\n\n// viewed at http://localhost:3000\napp.get(\"/\", function(req, res) {\n  res.send(\"Again I Go Unnoticed\");\n});\n\napp.get(\"/read\", function(req, res) {\n  // this does not exist\n  fs.createReadStream(\"my-self-esteem.txt\");\n});\n\napp.listen(port, () => console.log(`Example app listening on port ${port}!`));If we run this directly against Node with npm start and navigate to the read endpoint, we get an error because that file doesn\u2019t exist.Which \u2014 no big deal right? It\u2019s one error. It happens.NO. Big deal. If you go back to your terminal you will see that the application is completely down.Which means if you go back to the browser and try to go to the root URL of the site, you get the same error page. One error in one method took the application down for everyone.That\u2019s bad. Like really bad. This is one of the main reasons why people say \u201cnever run directly against Node in production\u201d.OK. So if we can\u2019t run against Node in production, what is the right way to run Node in production?Options for production NodeWe\u2019ve got a few options.One of them would be to simply use something like supervisor or nodemon in production the same way we are using them in dev. That would work, but these tools are a little on the lightweight side. A better option is something called pm2.pm2 the rescuepm2 is a Node process manager that has lots of bells and whistles. Just like everything else \u201cJavaScript\u201d, you install it (globally) from npm \u2014 or you can just use npx again. I don\u2019t want to tell you how to live your life.There are a lot of ways to run your app with pm2. The simplest way is to just call pm2 start on your entry point.\"scripts\": {\n  \"start\": \"pm2 start index.js\",\n  \"dev\": \"npx supervisor index.js\"\n},And you\u2019ll see something like this in the terminal\u2026That\u2019s our process running in the background monitored by pm2. If you visit the read endpoint and crash the application, pm2 will automatically restart it. You won\u2019t see any of that in the terminal because it\u2019s running in the background. If you want to watch pm2 do its thing, you gotta run pm2 log 0. The 0 is the ID of the process we want to see logs for.There we go! You can see pm2 restart the application when it goes down because of our unhandled error.We can also pull out our dev command and have pm2 watch files for us and restart on any changes.\"scripts\": {\n  \"start\": \"pm2 start index.js --watch\",\n  \"dev\": \"npx supervisor index.js\"\n},Note that because pm2 runs things in the background, you can\u2019t just ctrl+c your way out of a running pm2 process. You have to stop it by passing the ID or the name.pm2 stop 0pm2 stop indexAlso, note that pm2 retains a reference to the process so you can restart it.If you want to delete that process reference, you need to run pm2 delete. You can stop and delete a process in one command with delete.pm2 delete indexWe can also use pm2 to run multiple processes of our application. pm2 will automatically balance the load across those instances.Multiple processes with pm2 fork modepm2 has a ton of configuration options and those are contained in an \u201cecosystem\u201d file. To create one, run pm2 init. You\u2019ll get something like this\u2026module.exports = {\n  apps: [\n    {\n      name: \"Express App\",\n      script: \"index.js\",\n      instances: 4,\n      autorestart: true,\n      watch: true,\n      max_memory_restart: \"1G\",\n      env: {\n        NODE_ENV: \"development\"\n      },\n      env_production: {\n        NODE_ENV: \"production\"\n      }\n    }\n  ]\n};I\u2019m going to ignore the \u201cdeploy\u201d section in this article because I have no idea what it does.The \u201capps\u201d section is where you define the apps you want pm2 to run and monitor. You can run more than one. A lot of these configuration settings are probably self-explanatory. The one that I want to focus on here is the instances setting.pm2 can run multiple instances of your application. You can pass in a number of instances that you want to run and pm2 will spin up that many. So if we wanted to run 4 instances, we could have the following configuration file.module.exports = {\n  apps: [\n    {\n      name: \"Express App\",\n      script: \"index.js\",\n      instances: 4,\n      autorestart: true,\n      watch: true,\n      max_memory_restart: \"1G\",\n      env: {\n        NODE_ENV: \"development\"\n      },\n      env_production: {\n        NODE_ENV: \"production\"\n      }\n    }\n  ]\n};Then we just run it with pm2 start.pm2 is now running in \u201ccluster\u201d mode. Each of these processes is running on a different CPU on my machine, depending on how many cores I have. If we wanted to run a process for each core without knowing how many cores we have, we can just pass the max parameter to the instances value.{\n   ...\n   instances: \"max\",\n   ...\n}Let\u2019s find out how many cores I\u2019ve got in this machine.8 CORES! Holy crap. I\u2019m gonna install Subnautica on my Microsoft issued machine. Don\u2019t tell them I said that.The good thing about running processes on separate CPU\u2019s is that if you have a process that runs amok and takes up 100% of the CPU, the others will still function. If you pass in more instances than you have cores, pm2 will double up processes on CPU\u2019s as necessary.You can do a WHOLE lot more with pm2, including monitoring and otherwise wrangling those pesky environment variables.One other item of note: if for some reason you want pm2 to run your npm start script, you can do that by running npm as the process and passing the -- start. The space before the \u201cstart\u201d is super important here.pm2 start npm -- startIn Azure AppService, we include pm2 by default in the background. If you want to use pm2 in Azure, you don\u2019t need to include it in your package.json file. You can just add an ecosystem file and you\u2019re good to go.OK! Now that we\u2019ve learned all about pm2, let\u2019s talk about why you may not want to use it and it might indeed be ok to run directly against Node.Running directly against Node in productionI had some questions on this so I reached out to Tierney Cyren who is part of the enormous orange circle of knowledge, especially when it comes to Node.Tierney pointed out a few drawbacks to using Node based process managers like pm2.The main reason is that you shouldn\u2019t use Node to monitor Node. You don\u2019t want to use the thing that you are monitoring to monitor that thing. It\u2019s kind of like you asking my teenage son to supervise himself on a Friday night: Will that end badly? It might, and it might not. But you\u2019re about to find out the hard way.Tierney recommends that you not have a Node process manager running your application at all. Instead, have something at a higher level which watches multiple separate instances of your application. For example, an ideal setup would be if you had a Kubernetes cluster with your app running on separate containers. Kubernetes can then monitor those containers and if any of them go down, it can bring them back and report on their health.In this case, you can run directly against Node because you are monitoring at a higher level.As it turns out, Azure is already doing this. If we don\u2019t push a pm2 ecosystem file to Azure, it will start the application with our package.json file start script and we can run directly against Node.\"scripts\": {\n  \"start\": \"node index.js\"\n}In this case, we are running directly against Node and it\u2019s OK. If the application were to crash, you\u2019ll notice that it comes back. That\u2019s because in Azure, your app runs in a container. Azure is orchestrating the container in which your app is running and knows when it faceplants.But you still only have one instance here. It takes the container a second to come back online after it crashes meaning that there could be a few seconds of downtime for your users.Ideally, you would want more than one container running. The solution to this would be to deploy multiple instances of your application to multiple Azure AppService sites and then use Azure Front Door to load balance the apps behind a single IP address. Front Door will know when a container is down and will route traffic to other healthy instances of your application.Azure Front Door Service | Microsoft AzureDeliver, protect and track the performance of your globally distributed microservice applications with Azure Front Door\u2026azure.microsoft.comsystemdAnother suggestion that Tierney had is to run Node with systemd. I don\u2019t understand too much (or anything at all) about systemd and I\u2019ve already messed this phrasing up once already, so I\u2019ll let Tierney say it in his own words\u2026This option is only possible if you have access to Linux in your deployment and you control the way that Node is started on a service level. If you\u2019re running your Node.js process in a long-running Linux VM, like Azure VMs, you\u2019re in a good place to run Node.js with systemd. If you are just deploying your files to a service like Azure AppService or Heroku or running inside of a containerized environment like Azure Container Instances, you should probably steer clear of this option.Running Your Node.js App With Systemd - Part 1You've written the next great application, in Node, and you are ready to unleash it upon the world. Which means you can\u2026nodesource.comNode.js Worker ThreadsTierney also wants you to know that Worker Threads are coming in Node. This will allow you to start your app on multiple \u201cworkers\u201d (threads) thusly negating the need for something like pm2. Maybe. I don\u2019t know. I didn\u2019t really read the article.Node.js v11.14.0 DocumentationThe worker_threads module enables the use of threads that execute JavaScript in parallel. To access it: const worker =\u2026nodejs.orgBe an AdultTierney\u2019s last suggestion was to just handle the error and write some tests like an adult. But who has time for that?The tiny circle abidesNow you know most of what is in the tiny blue circle. The rest is just useless facts about emo bands and beer.For more information on pm2, Node and Azure, check out the following resources\u2026http://pm2.keymetrics.io/Node.js deployment on VS CodeDeploy a simple Node site to Azure\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 13667, "excerpt": "Sometimes I wonder if I know much of anything at all.\n\nJust a few weeks ago I was talking to a friend who mentioned off-hand, \u201cyou\nwould never run an application directly against Node in production\u201d. \n\nI nodded vigorously to signal that I also would never ever run against Node in\nproduction because\u2026hahaha\u2026.everyone knows that. But I didn\u2019t know that! Should I\nhave known that?!?? AM I STILL ALLOWED TO PROGRAM?\n\nIf I was to draw a Venn Diagram of what I know vs what I feel like everyone else\nknows", "siteName": "freeCodeCamp.org", "publishedTime": "2019-04-22T17:22:55.000Z", "id": "1bf1a6cd0423afb9127b83f2a29c478173f38951", "url": "https://www.freecodecamp.org/news/you-should-never-ever-run-directly-against-node-js-in-production-maybe-7fdfaed51ec6/", "domain": "freecodecamp.org", "date": "2023-12-27T18:11:41.900797", "resultUri": "http://localhost:3000/result/1bf1a6cd0423afb9127b83f2a29c478173f38951", "query": {"url": ["https://www.freecodecamp.org/news/you-should-never-ever-run-directly-against-node-js-in-production-maybe-7fdfaed51ec6/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "You should never ever run directly against Node.js in production. Maybe.", "description": "Sometimes I wonder if I know much of anything at all. Just a few weeks ago I was talking to a friend who mentioned off-hand, \u201cyou would never run an application directly against Node in production\u201d.  I nodded vigorously to signal that I also would never ever run against", "url": "https://www.freecodecamp.org/news/you-should-never-ever-run-directly-against-node-js-in-production-maybe-7fdfaed51ec6/", "image": "https://cdn-media-1.freecodecamp.org/images/1*Lh8JaRfiqPj9bTrd8a3xgQ.png", "image:width": "800", "image:height": "450"}, "twitter": {"card": "summary_large_image", "title": "You should never ever run directly against Node.js in production. Maybe.", "description": "Sometimes I wonder if I know much of anything at all. Just a few weeks ago I was talking to a friend who mentioned off-hand, \u201cyou would never run an application directly against Node in production\u201d.  I nodded vigorously to signal that I also would never ever run against", "url": "https://www.freecodecamp.org/news/you-should-never-ever-run-directly-against-node-js-in-production-maybe-7fdfaed51ec6/", "image": "https://cdn-media-1.freecodecamp.org/images/1*Lh8JaRfiqPj9bTrd8a3xgQ.png", "label1": "Written by", "data1": "Burke Holland", "label2": "Filed under", "data2": "Nodejs, Programming, JavaScript, Tech, Technology", "site": "@freecodecamp", "creator": "@burkeholland"}}}