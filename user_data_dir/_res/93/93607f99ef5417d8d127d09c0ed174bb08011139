{"title": "An introduction to Functional JavaScript", "byline": "Cristian Salcescu", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>An introduction to Functional JavaScript</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>Hey everybody! I\u2019ve written a book called <a href=\"https://www.amazon.com/dp/B07PBQJYYG\" rel=\"noopener\">Discover Functional JavaScript</a>, and it\u2019s now ready in both paperback and Kindle formats.</p><p>After publishing several articles on Functional Programming in JavaScript, at some point I realized I have enough material to think about a book. So, I started from my previous writings, filled in the missing parts and created a book on Functional Programming in JavaScript.</p><p>What I tried to do in this book was to give practical examples of the core functional concepts. I think that if we master the fundamentals then it will be easier to handle more complex situations. And this is what this book is for.</p><p>I looked into a deeper understanding of pure functions other than that they are great. If they are so good, why don\u2019t we write the whole application using only pure functions?</p><p>The other reason behind the book is to emphasize the new way of building encapsulated objects without classes and prototypes in JavaScript. I even saw classes presented as a way to bring encapsulation to objects. Encapsulation means hiding information. Objects built with classes in JavaScript are built over the prototype system. All their properties are public, they are not encapsulated.</p><p>I tried and hope I have succeeded to present the fundamental functional programming concepts in an easy to learn and practical manner. After reading the book you will understand better concepts like first-class functions, closures, currying, and partial application. You will understand what pure functions are and how to create them. You will better understand immutability and how it can be achieved in JavaScript.</p><p>Another thing not taken so much into account is naming. With the rise of arrow functions, more and more anonymous functions are created. The pretext behind all this is the fact that arrow functions have no <code>this</code> and have a shorter syntax. I don\u2019t challenge that, I just challenge the fact that meaningful names are what we understand best. Removing that will make code harder to understand.</p><p>The book is pretty condensed, so you can even read it a few times. In regard to the core JavaScript concepts, it aims to make an overview of them, not to enter into great detail. There are a lot of resources for that.</p><p>For me, it was a great experience trying to organize my thoughts to express these ideas in a simple, practical way. I tried to focus on the main practical concepts and just eliminate everything that ads no value to the reader.</p><p>A deeper understanding of the fundamental concepts in JavaScript makes us better at resolving complex problems. I hope you will like it.</p><p>Here is what you can find inside:</p><h4 id=\"chapter-1-a-brief-overview-of-javascript\">Chapter 1: A brief overview of JavaScript</h4><p>JavaScript has primitives, objects and functions. All of them are values. All are treated as objects, even primitives.</p><p>Number, boolean, string, <code>undefined</code> and <code>null</code> are primitives.</p><p>Variables can be defined using <code>var</code>, <code>let</code> and <code>const</code>. The <code>let</code> declaration has a block scope.</p><p>Primitives, except <code>null</code> and <code>undefined</code>, are treated like objects, in the sense that they have methods but they are not objects.</p><p>Arrays are indexed collections of values. Each value is an element. Elements are ordered and accessed by their index number.</p><p>JavaScript has dynamic typing. Values have types, variables do not. Types can change at run time.</p><p>The main JavaScript runtime is single threaded. Two functions can\u2019t run at the same time.</p><h4 id=\"chapter-2-new-features-in-es6-\">Chapter 2: New features in ES6+</h4><p>ES6 brings more features to the JavaScript language. Some new syntax allows you to write code in a more expressive way, some features complete the functional programming toolbox, and some features are questionable.</p><p><code>let</code> declaration has block scope.</p><pre><code>function doTask(){   \n  let x = 1;   \n  {       \n    let x = 2;   \n  }\n   \n  console.log(x); \n}  \ndoTask(); //1</code></pre><p><code>var</code> declaration has function scope. It doesn't have block scope.</p><pre><code>function doTask(){   \n  var x = 1;   \n  {       \n    var x = 2;   \n  }\n   \n  console.log(x); \n}  \ndoTask(); //2</code></pre><h4 id=\"chapter-3-first-class-functions\">Chapter 3: First-class functions</h4><p>Functions are first-class objects. Functions can be stored in variables, objects or arrays, passed as arguments to other functions or returned from functions.</p><p>A higher-order function is a function that takes another function as an input, returns a function, or does both.</p><p><code>map()</code> transforms a list of values to another list of values using a mapping function.</p><pre><code>let numbers = [1,2,3,4,5];\n\nfunction doubleNo(x){\n  const result = x*2;\n  console.log(`${x} -&gt; ${result}`)\n  return result;\n}\n\nconst doubleNumbers = numbers.map(doubleNo);\n//1 -&gt; 2\n//2 -&gt; 4\n//3 -&gt; 6\n//4 -&gt; 8\n//5 -&gt; 10\n//[2, 4, 6, 8, 10]</code></pre><h4 id=\"chapter-4-closures\">Chapter 4: Closures</h4><figure><img alt=\"JSAYSH9IZCpQfKGWJdklasvq1VmXf7aLpBB5\" height=\"533\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/JSAYSH9IZCpQfKGWJdklasvq1VmXf7aLpBB5\" width=\"800\"/></figure><p>A closure is an inner function that has access to the outer scope, even after the outer scope container has executed.</p><p>The <code>count()</code> function in the next example is a closure:</p><pre><code>const count = (function(){\n  let state = 0;\n  return function(){\n    state = state + 1;\n    return state;\n  }\n})();\n\ncount(); //1\ncount(); //2\ncount(); //3</code></pre><h4 id=\"chapter-5-function-decorators\">Chapter 5: Function decorators</h4><blockquote>A function decorator is a higher-order function that takes one function as an argument and returns another function, and the returned function is a variation of the argument function \u2014 Reginald Braithwaite, author of <a href=\"https://leanpub.com/javascript-allonge/read#decorators\" rel=\"noopener\">Javascript Allong\u00e9</a></blockquote><p>The <code>unary()</code> decorator returns a new version of the function that accepts only one argument. It may be used to fix problems when the function is called with more arguments than we need.</p><pre><code>function unary(fn){\n return function(first){\n   return fn(first);\n }\n}\n\nconst numbers = ['1','2','3','4','5','6'];\nnumbers.map(parseInt); \n//[1, NaN, NaN, NaN, NaN, NaN]\n\nnumbers.map(unary(parseInt)); \n//[1, 2, 3, 4, 5, 6]</code></pre><h4 id=\"chapter-6-pure-functions\">Chapter 6: Pure functions</h4><figure><img alt=\"6XNeBIiQldZ1bK7AK3-5GrQuUyEprm50TNq8\" height=\"533\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/6XNeBIiQldZ1bK7AK3-5GrQuUyEprm50TNq8\" width=\"800\"/></figure><p>A pure function is a function that, given the same input, always returns the same output and has no side effects.</p><p>You may have seen examples of pure functions like the ones below and want to look at some practical examples of pure functions.</p><pre><code>function double(x){\n  return x * 2;\n}\n\nfunction add(a, b){\n  return a + b;\n}\n\nfunction multiply(a, b) {\n  return a * b;\n}</code></pre><p>Like other programming paradigms, Pure Functional Programming promises to make code easier to read, understand, test, debug, and compose. Can it deliver its promise? If it can, can we build an application using only pure functions? These are questions this chapter tries to answer.</p><h4 id=\"chapter-7-immutability\">Chapter 7: Immutability</h4><p>An immutable value is a value that, once created, cannot be changed.</p><p>Does immutability have to do with variables that cannot change or values that cannot change? And how can we make that happen? Why do we even care about that? This chapter tries to answers these questions.</p><figure><img alt=\"THSwkY8IPNQ0UjMPr5yzQG0vij3fEhdeaoIp\" height=\"533\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/THSwkY8IPNQ0UjMPr5yzQG0vij3fEhdeaoIp\" width=\"800\"/></figure><h4 id=\"chapter-8-partial-application-and-currying\">Chapter 8: Partial application and currying</h4><p>Partial application<strong> </strong>refers to the process of fixing a number of parameters by creating a new function with fewer parameters than the original.</p><p>Currying is the process of transforming a function with many parameters into a series of functions that each takes a single parameter.</p><p>Usually we find examples using currying to add or multiply a few numbers, like in the code below:</p><pre><code>function add(a) {\n  return function(b){\n    return function(c){\n      return a + b + c;\n    }\n  }\n}\n\nadd(1)(2)(3);\n//6</code></pre><p>Does currying have a practical application? This chapter shows some practical examples of using partial application and currying.</p><h4 id=\"chapter-9-function-composition\">Chapter 9: Function composition</h4><p>Function composition is applying one function to the result of another.</p><pre><code>function compose(...functions){\n  return function(x){\n    return functions.reduceRight((value, f) =&gt; f(value), x);\n  }\n}\n\nf(g(x)) === compose(f,g)(x);</code></pre><h4 id=\"chapter-10-intention-revealing-names\">Chapter 10: Intention revealing names</h4><p>Functions can be created with or without a name. The arrow syntax usually creates anonymous functions.</p><pre><code>(() =&gt; {\n    /*code*/\n    (() =&gt; {\n        /*code*/\n    })();\n})();</code></pre><p>Anonymous functions appear as \u201c(anonymous)\u201d in the CallStack.</p><p>Intention revealing names improve code readability.</p><h4 id=\"chapter-11-making-code-easier-to-read\">Chapter 11: Making code easier to read</h4><p>This chapter shows examples of refactoring imperative code with functional programming techniques and looks at the readability of the final code.</p><h4 id=\"chapter-12-asynchronous-programming\">Chapter 12: Asynchronous programming</h4><p>In an application, there are two kinds of functions: synchronous and asynchronous. We take a look at the asynchronous programming model in JavaScript.</p><h4 id=\"chapter-13-objects-with-prototypes\">Chapter 13: Objects with prototypes</h4><p>Objects are dynamic collections of properties, with a \u201chidden\u201d property to the object\u2019s prototype.</p><p>Objects inherit from other objects.</p><p><code>class</code> is a sugar syntax from creating objects with a custom prototype.</p><pre><code>class Counter {\n  constructor(){\n    this.state = 0;\n  }\n  \n  increment(){\n    this.state = this.state + 1;\n    return this.state;\n  }\n  \n  decrement(){\n    this.state = this.state - 1;\n    return this.state;\n  }\n}\n\nconst counter = new Counter();\ncounter.increment(); //1\ncounter.increment(); //2\ncounter.increment(); //3\ncounter.decrement(); //2</code></pre><h4 id=\"chapter-14-objects-with-closures\">Chapter 14: Objects with closures</h4><p>With closures we can create encapsulated and flexible objects. Consider the same counter object created with closures:</p><pre><code>function Counter() {\n  let state = 0;\n  \n  function increment(){\n    state = state + 1;\n    return state;\n  }\n  \n  function decrement(){\n    state = state - 1;\n    return state;\n  }\n  \n  return Object.freeze({\n    increment, \n    decrement\n  })\n}\n\nconst counter = Counter();\ncounter.increment(); //1\ncounter.increment(); //2\ncounter.increment(); //3\ncounter.decrement(); //2</code></pre><p>This chapter presents more encapsulated objects and discusses the difference between objects built with closures and prototypes.</p><h4 id=\"chapter-15-method-decorators\">Chapter 15: Method decorators</h4><p>Method decorators are a tool for reusing common logic.</p><h4 id=\"chapter-16-waiting-for-the-new-programming-paradigm\">Chapter 16: Waiting for the new programming paradigm</h4><p>The last chapter contains thoughts on Functional and Object Oriented Programming in JavaScript.</p><p><a href=\"https://read.amazon.com/kp/embed?asin=B07PBQJYYG&amp;preview=newtab&amp;linkCode=kpe&amp;ref_=cm_sw_r_kb_dp_j0hTCbF0B1230\" rel=\"noopener\"><strong>Enjoy the book</strong></a><strong>!</strong></p><p>You can find me on <a href=\"https://twitter.com/cristi_salcescu\" rel=\"noopener\">Twitter</a>.</p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nHey everybody! I\u2019ve written a book called Discover Functional JavaScript, and it\u2019s now ready in both paperback and Kindle formats.After publishing several articles on Functional Programming in JavaScript, at some point I realized I have enough material to think about a book. So, I started from my previous writings, filled in the missing parts and created a book on Functional Programming in JavaScript.What I tried to do in this book was to give practical examples of the core functional concepts. I think that if we master the fundamentals then it will be easier to handle more complex situations. And this is what this book is for.I looked into a deeper understanding of pure functions other than that they are great. If they are so good, why don\u2019t we write the whole application using only pure functions?The other reason behind the book is to emphasize the new way of building encapsulated objects without classes and prototypes in JavaScript. I even saw classes presented as a way to bring encapsulation to objects. Encapsulation means hiding information. Objects built with classes in JavaScript are built over the prototype system. All their properties are public, they are not encapsulated.I tried and hope I have succeeded to present the fundamental functional programming concepts in an easy to learn and practical manner. After reading the book you will understand better concepts like first-class functions, closures, currying, and partial application. You will understand what pure functions are and how to create them. You will better understand immutability and how it can be achieved in JavaScript.Another thing not taken so much into account is naming. With the rise of arrow functions, more and more anonymous functions are created. The pretext behind all this is the fact that arrow functions have no this and have a shorter syntax. I don\u2019t challenge that, I just challenge the fact that meaningful names are what we understand best. Removing that will make code harder to understand.The book is pretty condensed, so you can even read it a few times. In regard to the core JavaScript concepts, it aims to make an overview of them, not to enter into great detail. There are a lot of resources for that.For me, it was a great experience trying to organize my thoughts to express these ideas in a simple, practical way. I tried to focus on the main practical concepts and just eliminate everything that ads no value to the reader.A deeper understanding of the fundamental concepts in JavaScript makes us better at resolving complex problems. I hope you will like it.Here is what you can find inside:Chapter 1: A brief overview of JavaScriptJavaScript has primitives, objects and functions. All of them are values. All are treated as objects, even primitives.Number, boolean, string, undefined and null are primitives.Variables can be defined using var, let and const. The let declaration has a block scope.Primitives, except null and undefined, are treated like objects, in the sense that they have methods but they are not objects.Arrays are indexed collections of values. Each value is an element. Elements are ordered and accessed by their index number.JavaScript has dynamic typing. Values have types, variables do not. Types can change at run time.The main JavaScript runtime is single threaded. Two functions can\u2019t run at the same time.Chapter 2: New features in ES6+ES6 brings more features to the JavaScript language. Some new syntax allows you to write code in a more expressive way, some features complete the functional programming toolbox, and some features are questionable.let declaration has block scope.function doTask(){   \n  let x = 1;   \n  {       \n    let x = 2;   \n  }\n   \n  console.log(x); \n}  \ndoTask(); //1var declaration has function scope. It doesn't have block scope.function doTask(){   \n  var x = 1;   \n  {       \n    var x = 2;   \n  }\n   \n  console.log(x); \n}  \ndoTask(); //2Chapter 3: First-class functionsFunctions are first-class objects. Functions can be stored in variables, objects or arrays, passed as arguments to other functions or returned from functions.A higher-order function is a function that takes another function as an input, returns a function, or does both.map() transforms a list of values to another list of values using a mapping function.let numbers = [1,2,3,4,5];\n\nfunction doubleNo(x){\n  const result = x*2;\n  console.log(`${x} -> ${result}`)\n  return result;\n}\n\nconst doubleNumbers = numbers.map(doubleNo);\n//1 -> 2\n//2 -> 4\n//3 -> 6\n//4 -> 8\n//5 -> 10\n//[2, 4, 6, 8, 10]Chapter 4: ClosuresA closure is an inner function that has access to the outer scope, even after the outer scope container has executed.The count() function in the next example is a closure:const count = (function(){\n  let state = 0;\n  return function(){\n    state = state + 1;\n    return state;\n  }\n})();\n\ncount(); //1\ncount(); //2\ncount(); //3Chapter 5: Function decoratorsA function decorator is a higher-order function that takes one function as an argument and returns another function, and the returned function is a variation of the argument function \u2014 Reginald Braithwaite, author of Javascript Allong\u00e9The unary() decorator returns a new version of the function that accepts only one argument. It may be used to fix problems when the function is called with more arguments than we need.function unary(fn){\n return function(first){\n   return fn(first);\n }\n}\n\nconst numbers = ['1','2','3','4','5','6'];\nnumbers.map(parseInt); \n//[1, NaN, NaN, NaN, NaN, NaN]\n\nnumbers.map(unary(parseInt)); \n//[1, 2, 3, 4, 5, 6]Chapter 6: Pure functionsA pure function is a function that, given the same input, always returns the same output and has no side effects.You may have seen examples of pure functions like the ones below and want to look at some practical examples of pure functions.function double(x){\n  return x * 2;\n}\n\nfunction add(a, b){\n  return a + b;\n}\n\nfunction multiply(a, b) {\n  return a * b;\n}Like other programming paradigms, Pure Functional Programming promises to make code easier to read, understand, test, debug, and compose. Can it deliver its promise? If it can, can we build an application using only pure functions? These are questions this chapter tries to answer.Chapter 7: ImmutabilityAn immutable value is a value that, once created, cannot be changed.Does immutability have to do with variables that cannot change or values that cannot change? And how can we make that happen? Why do we even care about that? This chapter tries to answers these questions.Chapter 8: Partial application and curryingPartial application refers to the process of fixing a number of parameters by creating a new function with fewer parameters than the original.Currying is the process of transforming a function with many parameters into a series of functions that each takes a single parameter.Usually we find examples using currying to add or multiply a few numbers, like in the code below:function add(a) {\n  return function(b){\n    return function(c){\n      return a + b + c;\n    }\n  }\n}\n\nadd(1)(2)(3);\n//6Does currying have a practical application? This chapter shows some practical examples of using partial application and currying.Chapter 9: Function compositionFunction composition is applying one function to the result of another.function compose(...functions){\n  return function(x){\n    return functions.reduceRight((value, f) => f(value), x);\n  }\n}\n\nf(g(x)) === compose(f,g)(x);Chapter 10: Intention revealing namesFunctions can be created with or without a name. The arrow syntax usually creates anonymous functions.(() => {\n    /*code*/\n    (() => {\n        /*code*/\n    })();\n})();Anonymous functions appear as \u201c(anonymous)\u201d in the CallStack.Intention revealing names improve code readability.Chapter 11: Making code easier to readThis chapter shows examples of refactoring imperative code with functional programming techniques and looks at the readability of the final code.Chapter 12: Asynchronous programmingIn an application, there are two kinds of functions: synchronous and asynchronous. We take a look at the asynchronous programming model in JavaScript.Chapter 13: Objects with prototypesObjects are dynamic collections of properties, with a \u201chidden\u201d property to the object\u2019s prototype.Objects inherit from other objects.class is a sugar syntax from creating objects with a custom prototype.class Counter {\n  constructor(){\n    this.state = 0;\n  }\n  \n  increment(){\n    this.state = this.state + 1;\n    return this.state;\n  }\n  \n  decrement(){\n    this.state = this.state - 1;\n    return this.state;\n  }\n}\n\nconst counter = new Counter();\ncounter.increment(); //1\ncounter.increment(); //2\ncounter.increment(); //3\ncounter.decrement(); //2Chapter 14: Objects with closuresWith closures we can create encapsulated and flexible objects. Consider the same counter object created with closures:function Counter() {\n  let state = 0;\n  \n  function increment(){\n    state = state + 1;\n    return state;\n  }\n  \n  function decrement(){\n    state = state - 1;\n    return state;\n  }\n  \n  return Object.freeze({\n    increment, \n    decrement\n  })\n}\n\nconst counter = Counter();\ncounter.increment(); //1\ncounter.increment(); //2\ncounter.increment(); //3\ncounter.decrement(); //2This chapter presents more encapsulated objects and discusses the difference between objects built with closures and prototypes.Chapter 15: Method decoratorsMethod decorators are a tool for reusing common logic.Chapter 16: Waiting for the new programming paradigmThe last chapter contains thoughts on Functional and Object Oriented Programming in JavaScript.Enjoy the book!You can find me on Twitter.\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 10323, "excerpt": "Hey everybody! I\u2019ve written a book called Discover Functional JavaScript\n[https://www.amazon.com/dp/B07PBQJYYG], and it\u2019s now ready in both paperback and\nKindle formats.\n\nAfter publishing several articles on Functional Programming in JavaScript, at\nsome point I realized I have enough material to think about a book. So, I\nstarted from my previous writings, filled in the missing parts and created a\nbook on Functional Programming in JavaScript.\n\nWhat I tried to do in this book was to give practical", "siteName": "freeCodeCamp.org", "publishedTime": "2019-05-20T17:31:24.000Z", "id": "93607f99ef5417d8d127d09c0ed174bb08011139", "url": "https://www.freecodecamp.org/news/an-introduction-to-functional-javascript-e8dab63bb51d/", "domain": "freecodecamp.org", "date": "2023-12-27T18:09:35.739687", "resultUri": "http://localhost:3000/result/93607f99ef5417d8d127d09c0ed174bb08011139", "query": {"url": ["https://www.freecodecamp.org/news/an-introduction-to-functional-javascript-e8dab63bb51d/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "An introduction to Functional JavaScript", "description": "Hey everybody! I\u2019ve written a book called Discover Functional JavaScript [https://www.amazon.com/dp/B07PBQJYYG], and it\u2019s now ready in both paperback and Kindle formats. After publishing several articles on Functional Programming in JavaScript, at some point I realized I have enough material to think about a book. So, I started from my previous", "url": "https://www.freecodecamp.org/news/an-introduction-to-functional-javascript-e8dab63bb51d/", "image": "https://cdn-media-1.freecodecamp.org/images/1*DxjfBur9XKUWgSgceIv11Q.jpeg", "image:width": "800", "image:height": "533"}, "twitter": {"card": "summary_large_image", "title": "An introduction to Functional JavaScript", "description": "Hey everybody! I\u2019ve written a book called Discover Functional JavaScript [https://www.amazon.com/dp/B07PBQJYYG], and it\u2019s now ready in both paperback and Kindle formats. After publishing several articles on Functional Programming in JavaScript, at some point I realized I have enough material to think about a book. So, I started from my previous", "url": "https://www.freecodecamp.org/news/an-introduction-to-functional-javascript-e8dab63bb51d/", "image": "https://cdn-media-1.freecodecamp.org/images/1*DxjfBur9XKUWgSgceIv11Q.jpeg", "label1": "Written by", "data1": "Cristian Salcescu", "label2": "Filed under", "data2": "Functional Programming, JavaScript, Books, Technology, Programming", "site": "@freecodecamp", "creator": "@cristi_salcescu"}}}