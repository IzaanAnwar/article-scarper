{"title": "How to Rock the Coding Interview \u2013 Tips That Helped Me Land Job Offers from Google, Airbnb, and Dropbox", "byline": "Yangshun Tay", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>How to Rock the Coding Interview \u2013 Tips That Helped Me Land Job Offers from Google, Airbnb, and Dropbox</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>Back in 2017, I went through some coding interviews and got offers from several large tech companies. So at that point, I decided to share what I'd learned in this article.</p><p>And I've just updated it for 2022 so it'll be super useful and relevant if you're job hunting now.</p><p>Despite scoring decent grades in both my CS101 Algorithm class and my Data Structures class in university, I shudder at the thought of going through a coding interview that focuses on algorithms.</p><p>Hence I spent the last three months figuring out how to improve my coding interview skills and eventually received offers from big tech companies like <strong>Google, Facebook, Airbnb, Lyft, Dropbox</strong> and more. </p><p>In this post, I\u2019ll be sharing the insights and tips I gained along the way. Experienced candidates can also expect System Design questions, but that is out of the scope of this post.</p><p>Many of the algorithmic concepts tested in coding interviews are not what I usually use at work, where I am a Front End Engineer (web). Naturally, I have forgotten quite a bit about these algorithms and data structures, which I learned mostly during my freshmen and sophomore years of college.</p><p>It\u2019s stressful to have to produce (working) code in an interview, while someone scrutinizes every keystroke that you make. What\u2019s worse is that as an interviewee, you\u2019re encouraged to communicate your thought process out loud to the interviewer.</p><p>I used to think that being able to think, code, and communicate simultaneously was an impossible feat, until I realized that most people are just not good at coding interviews when they first start out. Interviewing is a skill that you can get better at by studying, preparing, and practicing for it.</p><p>My recent job search has led me on a journey to improve my coding interview skills. Front End Engineers like to rant about how the current hiring process is broken because technical interviews can include skills not related to front-end development. For example, writing a maze solving algorithm and merging two sorted lists of numbers. As a Front End Engineer myself, I can empathize with them.</p><p>Front end is a specialized domain where engineers have to care about many issues related to browser compatibilities, the Document Object Model, JavaScript performance, CSS layouts, and so on. It is uncommon for front-end engineers to implement some of the complex algorithms tested in interviews.</p><blockquote><strong><strong>At companies like Facebook and Google, the people are software engineers first, domain experts second.</strong></strong></blockquote><p>Unfortunately, rules are set by the companies, not the candidates. There is a high emphasis on general computer science concepts like algorithms, design patterns, data structures; core skills that a good software engineer should possess. If you want the job, you have to play by the rules set by the game masters \u2014 improve your coding interview skills!</p><p>This post is structured into the following two sections. Feel free to skip ahead to the section that interests you.</p><ul><li>The breakdown of coding interviews, and how to prepare for them.</li><li>Helpful tips and hints for each algorithm topic (arrays, trees, dynamic programming, etc.), along with recommended LeetCode practice questions to review core concepts and to improve on those topics.</li></ul><p>The content for this post <a href=\"https://www.techinterviewhandbook.org/\">can be found here</a>. I'll make updates there when necessary.</p><p>If you are interested in Front End content, check out my <a href=\"https://www.frontendinterviewhandbook.com/\">front end interview handbook here</a>.</p><h2 id=\"picking-a-programming-language\">Picking a programming language</h2><p>Before anything else, you need to pick a programming language for your algorithmic coding interview. </p><p>Most companies will allow you to code in the language of your choice. The only exception I know is Google. They allow their candidates to pick from only Java, C++, Python, Go or JavaScript. </p><p>For the most part, I recommend using a language that you are extremely familiar with, rather than one that is new to you but that the company uses widely.</p><p>There are some languages that are more suitable than others for coding interviews. Then there are some that you absolutely want to avoid. </p><p>From my experience as an interviewer, most candidates pick Python or Java. Other languages commonly selected include JavaScript, Ruby, and C++. I would absolutely avoid lower-level languages like C or Go, simply because they lack standard library functions and data structures.</p><p>Personally, Python is my de facto choice for coding algorithms during interviews. It is succinct and has a huge library of functions and data structures. </p><p>One of the top reasons I recommend Python is that it uses consistent APIs that operate on different data structures, such as <code>len()</code>, <code>for ... in ...</code> and slicing notation on sequences (strings, lists, and tuples). Getting the last element in a sequence is <code>arr[-1]</code> , and reversing it is simply <code>arr[::-1]</code>. You can achieve a lot with minimal syntax in Python.</p><p>Java is a decent choice too. But because you will have to constantly declare types in your code, it means entering extra keystrokes. This will slow down the speed at which you code and type. This issue will be more apparent when you have to write on a whiteboard during on-site interviews.</p><p>The reasons for choosing or not choosing C++ are similar to Java. Ultimately, Python, Java, and C++ are decent choices. If you have been using Java for a while, and do not have time to become familiar with another language, I recommend sticking to Java instead of picking up Python from scratch. This helps you to avoid having to use one language for work and another one for interviews. Most of the time, the bottleneck is in the thinking and not the writing.</p><p>One exception to the convention of allowing the candidate to \u201cpick any programming language they want\u201d is when the interview is for a domain-specific position, such as front-end, iOS, or Android engineer roles. You need to be familiar with coding algorithms in JavaScript, Objective-C, Swift, and Java, respectively.</p><p>If you need to use a data structure that the language does not support, such as a queue or heap in JavaScript, ask the interviewer if you can assume that you have a data structure that implements certain methods with specified time complexities. If the implementation of that data structure is not crucial to solving the problem, the interviewer will usually allow it. </p><p>In reality, being aware of existing data structures and selecting the appropriate ones to tackle the problem at hand is more important than knowing the intricate implementation details.</p><h2 id=\"review-your-cs101\">Review your CS101</h2><p>If you have been out of college for some time, it is highly advisable to review the CS fundamentals. I prefer to review it as I practice. I scan through my notes from college and revise the various algorithms as I work on the algorithm problems from LeetCode and Cracking the Coding Interview.</p><p>If you are interested in how data structures are implemented, check out <a href=\"https://github.com/yangshun/lago\" rel=\"noopener\">Lago</a>, a GitHub repository containing Data Structures and Algorithms examples in JavaScript.</p><figure><a href=\"https://github.com/yangshun/lago\"><div><p>GitHub - yangshun/lago: \ud83d\udcd5 Data Structures and Algorithms library in TypeScript</p><p>\ud83d\udcd5 Data Structures and Algorithms library in TypeScript - GitHub - yangshun/lago: \ud83d\udcd5 Data Structures and Algorithms library in TypeScript</p><p><img alt=\"favicon\" height=\"32\" loading=\"lazy\" src=\"https://github.githubassets.com/favicons/favicon.svg\" width=\"32\"/><span>yangshun</span><span>GitHub</span></p></div><p><img alt=\"lago\" height=\"600\" loading=\"lazy\" src=\"https://opengraph.githubassets.com/bd8206ced9a5c65be817a9871a9a0e7623d39b385db67499f2ac7eac9adf86b1/yangshun/lago\" width=\"1200\"/></p></a></figure><h2 id=\"mastery-through-practice\">Mastery through practice</h2><p>Next, gain familiarity and mastery of the algorithms and data structures in your chosen programming language.</p><p>Practice and solve algorithm questions in your chosen language. While Cracking the Coding Interview is a good resource, I prefer solving problems by typing code, letting it run, and getting instant feedback. </p><p>There are various Online Judges, such as <a href=\"https://leetcode.com/\" rel=\"noopener\">LeetCode</a>, <a href=\"https://www.hackerrank.com/\" rel=\"noopener\">HackerRank</a>, and <a href=\"http://codeforces.com/\" rel=\"noopener\">CodeForces</a> for you to practice questions online and to get used to the language. From my experience, LeetCode questions are most similar to the questions asked in interviews. HackerRank and CodeForces questions are more similar to questions in competitive programming. </p><p>If you practice enough LeetCode questions, there is a good chance that you will either see or complete one of your actual interview questions (or some variant of it).</p><p>Learn and understand the time and space complexities of the common operations in your chosen language. For Python, this <a href=\"https://wiki.python.org/moin/TimeComplexity\" rel=\"noopener\">page</a> will come in handy. Also, learn about the underlying sorting algorithm being used in the language\u2019s <code>sort()</code> function and its time and space complexities (in Python it\u2019s Timsort, which is a hybrid). </p><p>After completing a question on LeetCode, I usually add the time and space complexities of the written code as comments above the function body. I use the comments to remind myself to communicate the analysis of the algorithm after I have completed the implementation.</p><p>Read up on the recommended coding style for your language and stick to it. If you choose Python, refer to the <a href=\"https://pep8.org/\" rel=\"noopener\">PEP 8 Style Guide</a>. If you choose Java, refer to <a href=\"https://google.github.io/styleguide/javaguide.html\" rel=\"noopener\">Google\u2019s Java Style Guide</a>.</p><p>Learn about and be familiar with the common pitfalls and caveats of the language. If you point them out during the interview and avoid falling into them, you will earn bonus points and impress the interviewer, regardless of whether the interviewer is familiar with the language or not.</p><p>Gain a broad exposure to questions from various topics. In the second half of the article, I mention algorithm topics and the useful questions for each topic to practice. Do around 100 to 200 LeetCode questions, and you should be good.</p><p>If you prefer courses where the learning is more structured, here are a few recommendations. <strong>In no way is taking online courses a must in order to pass interviews.</strong></p><ul><li><a href=\"https://algo.monster/\">AlgoMonster</a> aims to help you ace the technical interview <strong>in the shortest time possible</strong>. By Google engineers, AlgoMonster uses a data-driven approach to teach you the most useful key question patterns and has contents to help you quickly revise basic data structures and algorithms. Best of all, AlgoMonster is not subscription-based - pay a one-time fee and get <strong>lifetime access</strong>.</li><li><a href=\"https://www.educative.io/courses/grokking-the-coding-interview\">Grokking the Coding Interview: Patterns for Coding Questions</a> by Educative expands on the recommended practice questions in this article but approaches the practicing from a questions pattern perspective, which is an approach I also agree with for learning and have personally used to get better at coding interviews. The course allows you to practice selected questions in Java, Python, C++, JavaScript and also provides sample solutions in those languages. Learn and understand patterns, not memorize answers.</li></ul><p>And of course, practice, practice, and more practice!</p><h2 id=\"phases-of-a-coding-interview\">Phases of a coding interview</h2><p>Congratulations, you are ready to put your skills to practice! In a coding interview, you will be given a technical question by the interviewer. You will write the code in a real-time, collaborative editor (phone screen) or on a whiteboard (on-site), and have 30 to 45 minutes to solve the problem. This is where the real fun begins!</p><p>Your interviewer will be looking to see that you meet the requirements of the role. It is up to you to show them that you have the skills. Initially, it may feel weird to talk while you code, as most programmers do not make a habit of explaining out loud their thoughts while they are typing code.</p><p>However, it is hard for the interviewer to know what you are thinking by just looking at your code. If you communicate your approach to the interviewer even before you start to code, you can validate your approach with them. This way, the two of you can agree on an acceptable approach.</p><h2 id=\"preparing-for-a-remote-interview\">Preparing for a remote interview</h2><p>For phone screens and remote interviews, have a paper and pen or pencil to jot down any notes or diagrams. If you are given a question about trees and graphs, it usually helps if you draw examples of the data structure.</p><p>Use earphones. Make sure you are in a quiet environment. You do not want to be holding a phone in one hand and typing with the other. Try to avoid using speakers. If the feedback is bad, communication is made harder. Having to repeat yourself will just result in the loss of valuable time.</p><h2 id=\"what-to-do-when-you-get-the-question\">What to do when you get the question</h2><p>Many candidates start coding as soon as they hear the question. That is usually a big mistake. First, take a moment and repeat the question back to the interviewer to make sure that you understand the question. If you misunderstand the question, then the interviewer can clarify.</p><p>Always seek clarification about the question upon hearing it, even if you think it is clear. You might discover that you have missed something. It also lets the interviewer know that you are attentive to details.</p><p>Consider asking the following questions.</p><ul><li>How big is the size of the input?</li><li>How big is the range of values?</li><li>What kind of values are there? Are there negative numbers? Floating points? Will there be empty inputs?</li><li>Are there duplicates within the input?</li><li>What are some extreme cases of the input?</li><li>How is the input stored? If you are given a dictionary of words, is it a list of strings or a trie?</li></ul><p>After you have sufficiently clarified the scope and intention of the problem, explain your high-level approach to the interviewer, even if it is a naive solution. If you are stuck, consider various approaches and explain out loud why it may or may not work. Sometimes your interviewer might drop hints and lead you toward the right path.</p><p>Start with a brute-force approach. Communicate it to the interviewer. Explain the time and space complexities and clarify why it is bad. It is unlikely that the brute-force approach will be the one that you will be coding. At this point, the interviewer will usually pop the dreaded, \u201cCan we do better?\u201d question. This means they are looking for a more optimal approach.</p><p>This is usually the hardest part of the interview. In general, look for repeated work and try to optimize them by potentially caching the calculated result somewhere. Reference it later, rather than computing it all over again. I provide some tips on tackling topic-specific questions in detail below.</p><p>Only start coding after you and your interviewer have agreed on an approach and you have been given the green light.</p><h2 id=\"starting-to-code\">Starting to code</h2><p>Use a good style to write your code. Reading code written by others is usually not an enjoyable task. Reading horribly formatted code written by others is even worse. Your goal is to make your interviewer understand your code so that they can quickly evaluate if your code does what it is suppose to and if it solves a given problem. </p><p>Use clear variable names and avoid names that are single letters, unless they are for iteration. However, if you are coding on a whiteboard, avoid using verbose variable names. This reduces the amount of writing you will have to do.</p><p>Always explain to the interviewer what you are writing or typing. This is not about reading, verbatim, to the interviewer the code you are producing. Talk about the section of the code you are currently implementing at a higher level. Explain why it is written as such, and what it is trying to achieve.</p><p>When you copy and paste in code, consider whether it is necessary. Sometimes it is, sometimes it is not. If you find yourself copying and pasting a large chunk of code spanning multiple lines, it is probably an indicator that you can restructure the code by extracting those lines into a function. If it is just a single line you copied, usually it is fine. </p><p>However, remember to change the respective variables in your copied line of code where relevant. Copying and pasting errors are a common source of bugs, even in day-to-day coding!</p><h2 id=\"after-coding\">After coding</h2><p>After you have finished coding, do not immediately announce to the interviewer that you are done. In most cases, your code is usually not perfect. It may contain bugs or syntax errors. What you need to do is review your code.</p><p>First, look through your code from start to finish. Look at it as if it were written by someone else, and you are seeing it for the first time and trying to spot bugs in it. That\u2019s exactly what your interviewer will be doing. Review and fix any issues you may find.</p><p>Next, come up with small test cases and step through the code (not your algorithm) with those sample input. </p><p>Interviewers like it when you read their minds. What they usually do after you have finished coding is get you to write tests. It is a huge plus if you write tests for your code even before they prompt you to do so. You should be emulating a debugger when stepping through your code. Jot down or tell them the values of certain variables as you walk the interviewer through the lines of code.</p><p>If there are large duplicated chunks of code in your solution, restructure the code to show the interviewer that you value quality coding. Also, look out for places where you can do <a href=\"https://en.wikipedia.org/wiki/Short-circuit_evaluation\" rel=\"noopener\">short-circuit evaluation</a>.</p><p>Lastly, give the time and space complexities of your code, and explain why it is such. You can annotate chunks of your code with their various time and space complexities to demonstrate your understanding of the code. You can even provide the APIs of your chosen programming language. Explain any trade-offs in your current approach versus alternative approaches, possibly in terms of time and space.</p><p>If your interviewer is happy with the solution, the interview usually ends here. It is also common that the interviewer asks you extension questions, such as how you would handle the problem if the whole input is too large to fit into memory, or if the input arrives as a stream. This is a common follow-up question at Google, where they care a lot about scale. </p><p>The answer is usually a divide-and-conquer approach \u2014 perform distributed processing of the data and only read certain chunks of the input from disk into memory, write the output back to disk and combine them later.</p><h2 id=\"practice-with-mock-interviews\">Practice with mock interviews</h2><p>The steps mentioned above can be rehearsed over and over again until you have fully internalized them and they become second nature to you. A good way to practice is by partnering with a friend and taking turns to interview each other.</p><p>A great resource for preparing for coding interviews is <a href=\"https://iio.sh/r/DMCa\" rel=\"noopener\">interviewing.io</a>. This platform provides free and anonymous practice interviews with Google and Facebook engineers, which can lead to real jobs and internships. </p><p>By virtue of being anonymous during the interview, the inclusive interview process is unbiased and low risk. At the end of the interview, both the interviewer and interviewee can provide feedback to each other for the purpose of helping one another improve.</p><p>Doing well in mock interviews will unlock the jobs page for candidates, and allow them to book interviews (also anonymously) with top companies like Uber, Lyft, Quora, Asana, and more. For those who are new to coding interviews, a demo interview can be viewed on <a href=\"https://start.interviewing.io/interview/9hV9r4HEONf9/replay\" rel=\"noopener\">this site</a>. Note that this site requires users to sign in.</p><p>I have used interviewing.io, both as an interviewer and an interviewee. The experience was great. <a href=\"https://www.freecodecamp.org/news/coding-interviews-for-dummies-5e048933b82b/undefined\" rel=\"noopener\">Aline Lerner</a>, the CEO and co-founder of interviewing.io, and her team are passionate about revolutionizing the process for coding interviews and helping candidates improve their interview skills. </p><p>She has also published a number of coding interview-related articles on the <a href=\"http://blog.interviewing.io/\" rel=\"noopener\">interviewing.io blog</a>. I recommend signing up as early as possible with interviewing.io, even though it's in beta, to increase the likelihood of receiving an invite.</p><figure><img alt=\"image-58\" height=\"495\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2022/02/image-58.png\" srcset=\"https://www.freecodecamp.org/news/content/images/size/w600/2022/02/image-58.png 600w, https://www.freecodecamp.org/news/content/images/2022/02/image-58.png 800w\" width=\"800\"/></figure><p>Another platform that allows you to practice coding interviews is <a href=\"https://pramp.com/\" rel=\"noopener\">Pramp</a>. Where interviewing.io matches potential job seekers with seasoned coding interviewers, Pramp takes a different approach. Pramp pairs you up with another peer who is also a job seeker. The two of you take turns assuming the roles of interviewer and interviewee. Pramp also prepares questions, and provides solutions and prompts to guide the interviewee.</p><h2 id=\"go-forth-and-conquer\">Go forth and conquer</h2><p>After doing a fair amount of questions on LeetCode and having enough practice doing mock interviews, go forth and put your new-found interviewing skills to the test. </p><p>Apply to your favorite companies or, better still, get referrals from your friends working for those companies. Referrals tend to get noticed earlier and have a faster response rate than applying without a referral. Good luck!</p><h2 id=\"practical-tips-for-coding-questions\">Practical tips for coding questions</h2><p>This section dives deep into practical tips for specific topics of algorithms and data structures, which appear frequently in coding questions. Many algorithm questions involve techniques that can be applied to questions of a similar nature.</p><p>The more techniques you have in your arsenal, the greater your chances of passing the interview. For each topic, there is also a list of recommended questions, which is valuable for mastering the core concepts. Some of the questions are only available with a paid subscription to LeetCode, which in my opinion is absolutely worth the money if it lands you a job.</p><h2 id=\"general-tips\">General tips</h2><p>Always validate input first. Check for inputs that are invalid, empty, negative, or different. Never assume you are given the valid parameters. Alternatively, clarify with the interviewer whether you can assume valid input (usually yes), which can save you time from writing code that does input validation.</p><p>Are there any time and space complexities requirements or constraints?</p><p>Check for off-by-one errors.</p><p>In languages where there are no automatic type coercion, check that concatenation of values are of the same type: <code>int</code>,<code>str</code>, and <code>list</code>.</p><p>After you finish your code, use a few example inputs to test your solution.</p><p>Is the algorithm supposed to run multiple times, perhaps on a web server? If yes, the input can likely be pre-processed to improve the efficiency in each API call.</p><p>Use a mix of functional and imperative programming paradigms:</p><ul><li>Write pure functions as often as possible.</li><li>Use pure functions because they are easier to reason with and can help reduce bugs in your implementation.</li><li>Avoid mutating the parameters passed into your function, especially if they are passed by reference, unless you are sure of what you are doing.</li><li>Achieve a balance between accuracy and efficiency. Use the right amount of functional and imperative code where appropriate. Functional programming is usually expensive in terms of space complexity because of non-mutation and the repeated allocation of new objects. On the other hand, imperative code is faster because you operate on existing objects.</li><li>Avoid relying on mutating global variables. Global variables introduce state.</li><li>Make sure that you do not accidentally mutate global variables, especially if you have to rely on them.</li></ul><p>Generally, to improve the speed of a program, we can choose to either use an appropriate data structure or algorithm, or to use more memory. It\u2019s a classic space and time trade off.</p><p>Data structures are your weapons. Choosing the right weapon for the right battle is the key to victory. Know the strengths of each data structure and the time complexity for its various operations.</p><p>Data structures can be augmented to achieve efficient time complexity across different operations. For example, a HashMap can be used together with a doubly-linked list to achieve O(1) time complexity for both the <code>get</code> and <code>put</code> operation in an <a href=\"https://leetcode.com/problems/lru-cache/\" rel=\"noopener\">LRU cache</a>.</p><p>HashMaps are probably the most commonly used data structure for algorithm questions. If you are stuck on a question, your last resort can be to enumerate through the possible data structures (thankfully there aren\u2019t that many) and consider whether each of them can be applied to the problem. This has worked for me at times.</p><p>If you are cutting corners in your code, state that out loud to your interviewer, and explain to them what you would do outside of an interview setting (no time constraints). For example, explain that you would write a regex to parse a string rather than using <code>split</code> , which does not cover all cases.</p><h2 id=\"sequence\">Sequence</h2><h4 id=\"notes\"><strong>Notes</strong></h4><p>Arrays and strings are considered sequences (a string is a sequence of characters). There are tips for dealing with both arrays and strings, which will be covered here.</p><p>Are there duplicate values in the sequence? Would they affect the answer?</p><p>Check for sequence out of bounds.</p><p>Be mindful about slicing or concatenating sequences in your code. Typically, slicing and concatenating sequences require O(n) time. Use start and end indices to demarcate a subarray or substring where possible.</p><p>Sometimes you traverse the sequence from the right side rather than from the left.</p><p>Master the <a href=\"https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems\" rel=\"noopener\">sliding window technique</a> that applies to many substring or subarray problems.</p><p>When you are given two sequences to process, it is common to have one index per sequence to traverse. For example, we use the same approach to merge two sorted arrays.</p><h4 id=\"corner-cases\"><strong>Corner Cases</strong></h4><ul><li>Empty sequence</li><li>Sequence with 1 or 2 elements</li><li>Sequence with repeated elements</li></ul><h2 id=\"array\">Array</h2><h4 id=\"notes-1\"><strong>Notes</strong></h4><p>Is the array sorted or partially sorted? If it is either, some form of binary search should be possible. This usually means that the interviewer is looking for a solution that is faster than O(n).</p><p>Can you sort the array? Sometimes sorting the array first may significantly simplify the problem. Make sure that the order of array elements do not need to be preserved before attempting to sort it.</p><p>For questions where summation or multiplication of a subarray is involved, pre-computation using hashing or a prefix, suffix sum, or product might be useful.</p><p>If you are given a sequence and the interviewer asks for O(1) space, it might be possible to use the array itself as a hash table. For example, if the array has values only from 1 to N, where N is the length of the array, negate the value at that index (minus one) to indicate the presence of that number.</p><h4 id=\"practice-questions\"><strong>Practice Questions</strong></h4><ul><li><a href=\"https://leetcode.com/problems/two-sum/\" rel=\"noopener\">Two Sum</a></li><li><a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\" rel=\"noopener\">Best Time to Buy and Sell Stock</a></li><li><a href=\"https://leetcode.com/problems/contains-duplicate/\" rel=\"noopener\">Contains Duplicate</a></li><li><a href=\"https://leetcode.com/problems/product-of-array-except-self/\" rel=\"noopener\">Product of Array Except Self</a></li><li><a href=\"https://leetcode.com/problems/maximum-subarray/\" rel=\"noopener\">Maximum Subarray</a></li><li><a href=\"https://leetcode.com/problems/maximum-product-subarray/\" rel=\"noopener\">Maximum Product Subarray</a></li><li><a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\" rel=\"noopener\">Find Minimum in Rotated Sorted Array</a></li><li><a href=\"https://leetcode.com/problems/search-in-rotated-sorted-array/\" rel=\"noopener\">Search in Rotated Sorted Array</a></li><li><a href=\"https://leetcode.com/problems/3sum/\" rel=\"noopener\">3Sum</a></li><li><a href=\"https://leetcode.com/problems/container-with-most-water/\" rel=\"noopener\">Container With Most Water</a></li></ul><h2 id=\"binary\">Binary</h2><h4 id=\"study-links\"><strong>Study Links</strong></h4><ul><li><a href=\"https://medium.com/basecs/bits-bytes-building-with-binary-13cb4289aafa\" rel=\"noopener\">Bits, Bytes, Building With Binary</a></li></ul><h4 id=\"notes-2\"><strong>Notes</strong></h4><p>Questions involving binary representations and bitwise operations are asked sometimes. You must know how to convert a number from decimal form into binary form, and vice versa, in your chosen programming language.</p><p>Some helpful utility snippets:</p><ul><li>Test kth bit is set: <code>num &amp; (1 &lt;&lt; k) != 0</code></li><li>Set kth bit: <code>num |= (1 &lt;&lt; k)</code></li><li>Turn off kth bit: <code>num &amp;= ~(1 &lt;&lt; k)</code></li><li>Toggle the kth bit: <code>num ^= (1 &lt;&lt; k)</code></li><li>To check if a number is a power of 2: <code>num &amp; num - 1 == 0</code>.</li></ul><h4 id=\"corner-cases-1\"><strong>Corner Cases</strong></h4><ul><li>Check for overflow/underflow</li><li>Negative numbers</li></ul><h4 id=\"practice-questions-1\"><strong>Practice Questions</strong></h4><ul><li><a href=\"https://leetcode.com/problems/sum-of-two-integers/\" rel=\"noopener\">Sum of Two Integers</a></li><li><a href=\"https://leetcode.com/problems/number-of-1-bits/\" rel=\"noopener\">Number of 1 Bits</a></li><li><a href=\"https://leetcode.com/problems/counting-bits/\" rel=\"noopener\">Counting Bits</a></li><li><a href=\"https://leetcode.com/problems/missing-number/\" rel=\"noopener\">Missing Number</a></li><li><a href=\"https://leetcode.com/problems/reverse-bits/\" rel=\"noopener\">Reverse Bits</a></li></ul><h2 id=\"dynamic-programming\">Dynamic Programming</h2><h4 id=\"study-links-1\"><strong>Study Links</strong></h4><ul><li><a href=\"https://medium.freecodecamp.org/demystifying-dynamic-programming-3efafb8d4296\" rel=\"noopener\">Demystifying Dynamic Programming</a></li></ul><h4 id=\"notes-3\"><strong>Notes</strong></h4><p>Dynamic Programming (DP) is usually used to solve optimization problems. <a href=\"https://www.freecodecamp.org/news/coding-interviews-for-dummies-5e048933b82b/undefined\" rel=\"noopener\">Alaina Kafkes</a> has written an <a href=\"https://medium.freecodecamp.org/demystifying-dynamic-programming-3efafb8d4296\" rel=\"noopener\">awesome post</a> on tackling DP problems. You should read it.</p><p>The only way to get better at DP is with practice. It takes lots of practice to recognize that a problem can be solved by DP.</p><p>To optimize space, sometimes you do not have to store the entire DP table in memory. The last two values or the last two rows of the matrix will suffice.</p><h4 id=\"practice-questions-2\"><strong>Practice Questions</strong></h4><ul><li><a href=\"http://www.geeksforgeeks.org/knapsack-problem/\" rel=\"noopener\">0/1 Knapsack</a></li><li><a href=\"https://leetcode.com/problems/climbing-stairs/\" rel=\"noopener\">Climbing Stairs</a></li><li><a href=\"https://leetcode.com/problems/coin-change/\" rel=\"noopener\">Coin Change</a></li><li><a href=\"https://leetcode.com/problems/longest-increasing-subsequence/\" rel=\"noopener\">Longest Increasing Subsequence</a></li><li><a href=\"https://github.com/yangshun/tech-interview-handbook/blob/master/algorithms\" rel=\"noopener\">Longest Common Subsequence</a></li><li><a href=\"https://leetcode.com/problems/word-break/\" rel=\"noopener\">Word Break Problem</a></li><li><a href=\"https://leetcode.com/problems/combination-sum-iv/\" rel=\"noopener\">Combination Sum</a></li><li><a href=\"https://leetcode.com/problems/house-robber/\" rel=\"noopener\">House Robber</a> and <a href=\"https://leetcode.com/problems/house-robber-ii/\" rel=\"noopener\">House Robber II</a></li><li><a href=\"https://leetcode.com/problems/decode-ways/\" rel=\"noopener\">Decode Ways</a></li><li><a href=\"https://leetcode.com/problems/unique-paths/\" rel=\"noopener\">Unique Paths</a></li><li><a href=\"https://leetcode.com/problems/jump-game/\" rel=\"noopener\">Jump Game</a></li></ul><h2 id=\"geometry\">Geometry</h2><h4 id=\"notes-4\"><strong><strong><strong>Notes</strong></strong></strong></h4><p>When comparing Euclidean distance between two pairs of points, using dx\u00b2 + dy\u00b2 is sufficient. It is unnecessary to square root the value.</p><p>To find out if two circles overlap, check that the distance between the two centers of the circles is less than the sum of their radii.</p><h3 id=\"graph\"><strong>Graph</strong></h3><h4 id=\"study-links-2\"><strong>Study Links</strong></h4><ul><li><a href=\"https://medium.com/basecs/from-theory-to-practice-representing-graphs-cfd782c5be38\" rel=\"noopener\">From Theory To Practice: Representing Graphs</a></li><li><a href=\"https://medium.com/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13\" rel=\"noopener\">Deep Dive Through A Graph: DFS Traversal</a></li><li><a href=\"https://medium.com/basecs/going-broad-in-a-graph-bfs-traversal-959bd1a09255\" rel=\"noopener\">Going Broad In A Graph: BFS Traversal</a></li></ul><h4 id=\"notes-5\"><strong>Notes</strong></h4><p>Be familiar with the various graph representations and graph search algorithms, and with their time and space complexities.</p><p>You can be given a list of edges and tasked to build your own graph from the edges to perform a traversal on. The common graph representations are</p><ul><li>Adjacency matrix</li><li>Adjacency list</li><li>HashMap of HashMaps</li></ul><p>Some inputs look like they are trees, but they are actually graphs. Clarify this with your interviewer. In that case, you will have to handle cycles and keep a set of visited nodes when traversing.</p><h4 id=\"graph-search-algorithms\"><strong><strong><strong>Graph search algorithms</strong></strong></strong></h4><ul><li>Common: Breadth first search (BFS), Depth first search (DFS)</li><li>Uncommon: Topological sort, Dijkstra\u2019s algorithm</li><li>Rare: Bellman-Ford algorithm, Floyd-Warshall algorithm, Prim\u2019s algorithm, and Kruskal\u2019s algorithm</li></ul><p>In coding interviews, graphs are commonly represented as 2-D matrices, where cells are the nodes and each cell can traverse to its adjacent cells (up, down, left, and right). Hence it is important to be familiar with traversing a 2-D matrix. </p><p>When recursively traversing the matrix, always ensure that your next position is within the boundary of the matrix. More tips for doing DFS on a matrix can be found <a href=\"https://discuss.leetcode.com/topic/66065/python-dfs-bests-85-tips-for-all-dfs-in-matrix-question/\" rel=\"noopener\">here</a>. A simple template for doing DFS on a matrix appears something like this:</p><pre tabindex=\"0\"><code>def traverse(matrix):\n  rows, cols = len(matrix), len(matrix[0])\n  visited = set()\n  directions = ((0, 1), (0, -1), (1, 0), (-1, 0))\n  def dfs(i, j):\n    if (i, j) in visited:\n      return\n    visited.add((i, j))\n    # Traverse neighbors\n    for direction in directions:\n      next_i, next_j = i + direction[0], j + direction[1]\n      if 0 &lt;= next_i &lt; rows and 0 &lt;= next_j &lt; cols: # Check boundary\n        # Add any other checking here ^\n        dfs(next_i, next_j)\n  for i in range(rows):\n    for j in range(cols):\n      dfs(i, j)</code></pre><h4 id=\"corner-cases-2\"><strong><strong><strong>Corner Cases</strong></strong></strong></h4><ul><li>Empty graph</li><li>Graph with one or two nodes</li><li>Disjoint graphs</li><li>Graph with cycles</li></ul><h4 id=\"practice-questions-3\"><strong>Practice Questions</strong></h4><ul><li><a href=\"https://leetcode.com/problems/clone-graph/\" rel=\"noopener\">Clone Graph</a></li><li><a href=\"https://leetcode.com/problems/course-schedule/\" rel=\"noopener\">Course Schedule</a></li><li><a href=\"https://leetcode.com/problems/alien-dictionary/\" rel=\"noopener\">Alien Dictionary</a></li><li><a href=\"https://leetcode.com/problems/pacific-atlantic-water-flow/\" rel=\"noopener\">Pacific Atlantic Water Flow</a></li><li><a href=\"https://leetcode.com/problems/number-of-islands/\" rel=\"noopener\">Number of Islands</a></li><li><a href=\"https://leetcode.com/problems/graph-valid-tree/\" rel=\"noopener\">Graph Valid Tree</a></li><li><a href=\"https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/\" rel=\"noopener\">Number of Connected Components in an Undirected Graph</a></li><li><a href=\"https://leetcode.com/problems/longest-consecutive-sequence/\" rel=\"noopener\">Longest Consecutive Sequence</a></li></ul><h2 id=\"interval\">Interval</h2><h4 id=\"notes-6\"><strong>Notes</strong></h4><p>Interval questions are questions that give an array of two-element arrays (an interval). The two values represent a start and an end value. Interval questions are considered to be part of the array family, but they involve some common techniques. Hence, they have their own special section.</p><p>An example of an interval array: <code>[[1, 2], [4, 7]]</code>.</p><p>Interval questions can be tricky for those who do not have experience with them. This is because of the sheer number of cases to consider when interval arrays overlap.</p><p>Clarify with the interviewer whether <code>[1, 2]</code> and <code>[2, 3]</code> are considered overlapping intervals, because it affects how you will write your equality checks.</p><p>A common routine for interval questions is to sort the array of intervals by the start value of each interval.</p><p>Be familiar with writing code to check if two intervals overlap and to merge two overlapping intervals:</p><pre tabindex=\"0\"><code>def is_overlap(a, b):\n  return a[0] &lt; b[1] and b[0] &lt; a[1]\n  \ndef merge_overlapping_intervals(a, b):\n  return [min(a[0], b[0]), max(a[1], b[1])]</code></pre><h4 id=\"corner-cases-3\"><strong><strong><strong>Corner Cases</strong></strong></strong></h4><ul><li>Single interval</li><li>Non-overlapping intervals</li><li>An interval totally consumed within another interval</li><li>Duplicate intervals</li></ul><h4 id=\"practice-questions-4\"><strong>Practice Questions</strong></h4><ul><li><a href=\"https://leetcode.com/problems/insert-interval/\" rel=\"noopener\">Insert Interval</a></li><li><a href=\"https://leetcode.com/problems/merge-intervals/\" rel=\"noopener\">Merge Intervals</a></li><li><a href=\"https://leetcode.com/problems/meeting-rooms/\" rel=\"noopener\">Meeting Rooms</a> and <a href=\"https://leetcode.com/problems/meeting-rooms-ii/\" rel=\"noopener\">Meeting Rooms II</a></li><li><a href=\"https://leetcode.com/problems/non-overlapping-intervals/\" rel=\"noopener\">Non-overlapping Intervals</a></li></ul><h2 id=\"linked-list\">Linked List</h2><h4 id=\"notes-7\"><strong>Notes</strong></h4><p>Like arrays, linked lists are used to represent sequential data. The benefit of linked lists is that insertion and deletion of code from anywhere in the list is O(1), whereas in arrays, the elements have to be shifted.</p><p>Adding a dummy node at the head and /or tail might help to handle many edge cases where operations have to be performed at the head or the tail. The presence of dummy nodes ensures that operations will never have be executed on the head or the tail. Dummy nodes remove the headache of writing conditional checks to deal with null pointers. Be sure to remove them at the end of the operation.</p><p>Sometimes linked lists problem can be solved without additional storage. Try to borrow ideas from the for reverse a linked list problem.</p><p>For deletion in linked lists, you can either modify the node values or change the node pointers. You might need to keep a reference to the previous element.</p><p>For partitioning linked lists, create two separate linked lists and join them back together.</p><p>Linked lists problems share similarities with array problems. Think about how you would solve an array problem and apply it to a linked list.</p><p>Two pointer approaches are also common for linked lists:</p><ul><li>Getting the kth<strong><strong> </strong></strong>from the last node: Have two pointers, where one is <em><em>k</em></em> nodes ahead of the other. When the node ahead reaches the end, the other node is <em><em>k</em></em> nodes behind.</li><li>Detecting cycles: Have two pointers, where one pointer increments twice as much as the other. If the two pointers meet, it means that there is a cycle.</li><li>Getting the middle node: Have two pointers. One pointer increments twice as much as the other. When the faster node reaches the end of the list, the slower node will be at the middle.</li></ul><p>Be familiar with the following routines because many linked list questions make use of one or more of these routines in their solution.</p><ul><li>Count the number of nodes in the linked list</li><li>Reverse a linked list in place</li><li>Find the middle node of the linked list using fast or slow pointers</li><li>Merge two lists together</li></ul><h4 id=\"corner-cases-4\"><strong>Corner Cases</strong></h4><ul><li>Single node</li><li>Two nodes</li><li>Linked list has cycle. Clarify with the interviewer whether there can be a cycle in the list. Usually the answer is no.</li></ul><h4 id=\"practice-questions-5\"><strong>Practice Questions</strong></h4><ul><li><a href=\"https://leetcode.com/problems/reverse-linked-list/\" rel=\"noopener\">Reverse a Linked List</a></li><li><a href=\"https://leetcode.com/problems/linked-list-cycle/\" rel=\"noopener\">Detect Cycle in a Linked List</a></li><li><a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\" rel=\"noopener\">Merge Two Sorted Lists</a></li><li><a href=\"https://leetcode.com/problems/merge-k-sorted-lists/\" rel=\"noopener\">Merge K Sorted Lists</a></li><li><a href=\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/\" rel=\"noopener\">Remove Nth Node From End Of List</a></li><li><a href=\"https://leetcode.com/problems/reorder-list/\" rel=\"noopener\">Reorder List</a></li></ul><h2 id=\"math\">Math</h2><h4 id=\"notes-8\"><strong>Notes</strong></h4><p>If the code involves division or modulo, remember to check for division or modulo by 0 case.</p><p>When a question involves \u201ca multiple of a number\u201d, modulo might be useful.</p><p>Check for and handle overflow and underflow if you are using a typed language like Java and C++. At the very least, mention that overflow or underflow is possible and ask whether you need to handle it.</p><p>Consider negative numbers and floating point numbers. This may sound obvious, but when you are under pressure in an interview, many obvious points go unnoticed.</p><p>If the question asks to implement an operator such as power, squareroot, or division, and it is to be faster than O(n), binary search is usually the approach.</p><h4 id=\"some-common-formulas\"><strong><strong><strong>Some common formulas</strong></strong></strong></h4><ul><li>Sum of 1 to N = (n+1) * n/2</li><li>Sum of GP = 2\u2070 + 2\u00b9 + 2\u00b2 + 2\u00b3 + \u2026 2^n = 2^(n+1)-1</li><li>Permutations of N = N! / (N-K)!</li><li>Combinations of N = N! / (K! * (N-K)!)</li></ul><h4 id=\"corner-cases-5\"><strong>Corner Cases</strong></h4><ul><li>Division by 0</li><li>Integer overflow and underflow</li></ul><h4 id=\"practice-questions-6\"><strong>Practice Questions</strong></h4><ul><li><a href=\"https://leetcode.com/problems/powx-n/\" rel=\"noopener\">Pow(x, n)</a></li><li><a href=\"https://leetcode.com/problems/sqrtx/\" rel=\"noopener\">Sqrt(x)</a></li><li><a href=\"https://leetcode.com/problems/integer-to-english-words/\" rel=\"noopener\">Integer to English Words</a></li></ul><h2 id=\"matrix\">Matrix</h2><h4 id=\"notes-9\"><strong>Notes</strong></h4><p>A matrix is a 2-dimensional array. Questions involving matrices are usually related to dynamic programming or graph traversal.</p><p>For questions involving traversal or dynamic programming, make a copy of the matrix with the same dimensions that are initialized to empty values. Use these values to store the visited state or dynamic programming table. Be familiar with this routine:</p><pre tabindex=\"0\"><code>rows, cols = len(matrix), len(matrix[0])\ncopy = [[0 for _ in range(cols)] for _ in range(rows)</code></pre><ul><li>Many grid-based games can be modeled as a matrix. For example, Tic-Tac-Toe, Sudoku, Crossword, Connect 4, and Battleship. It is not uncommon to be asked to verify the winning condition of the game. For games like Tic-Tac-Toe, Connect 4, and Crosswords, verification has to be done vertically and horizontally. One trick is to write code to verify the matrix for the horizontal cells. Then transpose the matrix, reusing the logic used for horizontal verification to verify originally vertical cells (which are now horizontal).</li><li>Transposing a matrix in Python is simply:</li></ul><pre tabindex=\"0\"><code>transposed_matrix = zip(*matrix)</code></pre><h4 id=\"corner-cases-6\"><strong>Corner Cases</strong></h4><ul><li>Empty matrix. Check that none of the arrays are 0 length.</li><li>1 x 1 matrix.</li><li>Matrix with only one row or column.</li></ul><h4 id=\"practice-questions-7\"><strong>Practice Questions</strong></h4><ul><li><a href=\"https://leetcode.com/problems/set-matrix-zeroes/\" rel=\"noopener\">Set Matrix Zeroes</a></li><li><a href=\"https://leetcode.com/problems/spiral-matrix/\" rel=\"noopener\">Spiral Matrix</a></li><li><a href=\"https://leetcode.com/problems/rotate-image/\" rel=\"noopener\">Rotate Image</a></li><li><a href=\"https://leetcode.com/problems/word-search/\" rel=\"noopener\">Word Search</a></li></ul><h2 id=\"recursion\">Recursion</h2><h4 id=\"notes-10\"><strong>Notes</strong></h4><p>Recursion is useful for permutation, because it generates all combinations and tree-based questions. You should know how to generate all permutations of a sequence as well as how to handle duplicates.</p><p>Remember to always define a base case so that your recursion will end.</p><p>Recursion implicitly uses a stack. Hence all recursive approaches can be rewritten iteratively using a stack. </p><p>Beware of cases where the recursion level goes too deep and causes a stack overflow (the default limit in Python is 1000). You may get bonus points for pointing this out to the interviewer. </p><p>Recursion will never be O(1) space complexity because a stack is involved, unless there is <a href=\"https://stackoverflow.com/questions/310974/what-is-tail-call-optimization\" rel=\"noopener\">tail call optimization</a> (TCO). Find out if your chosen language supports TCO.</p><h4 id=\"practice-questions-8\"><strong>Practice Questions</strong></h4><ul><li><a href=\"https://leetcode.com/problems/subsets/\" rel=\"noopener\">Subsets</a> and <a href=\"https://leetcode.com/problems/subsets-ii/\" rel=\"noopener\">Subsets II</a></li><li><a href=\"https://leetcode.com/problems/strobogrammatic-number-ii/\" rel=\"noopener\">Strobogrammatic Number II</a></li></ul><h2 id=\"string\">String</h2><h4 id=\"notes-11\"><strong>Notes</strong></h4><p>Please read the above tips on <a href=\"https://github.com/yangshun/tech-interview-handbook/tree/master/algorithms#sequence\" rel=\"noopener\">sequence</a>. They apply to strings too.</p><p>Ask about input character set and case sensitivity. Usually the characters are limited to lowercase Latin characters, for example a to z.</p><p>When you need to compare strings where the order isn\u2019t important (like anagram), you may consider using a HashMap as a counter. If your language has a built-in <code>Counter</code> class like Python, ask to use that instead.</p><p>If you need to keep a counter of characters, a common mistake is to say that the space complexity required for the counter is O(n). The space required for a counter is O(1) not O(n). This is because the upper bound is the range of characters, which is usually a fixed constant of 26. The input set is just lowercase Latin characters.</p><p>Common data structures for looking up strings efficiently are</p><ul><li><a href=\"https://www.wikiwand.com/en/Trie\" rel=\"noopener\">Trie/Prefix Tree</a></li><li><a href=\"https://www.wikiwand.com/en/Suffix_tree\" rel=\"noopener\">Suffix Tree</a></li></ul><p>Common string algorithms are</p><ul><li><a href=\"https://www.wikiwand.com/en/Rabin%E2%80%93Karp_algorithm\" rel=\"noopener\">Rabin Karp</a>, which conducts efficient searches of substrings, using a rolling hash</li><li><a href=\"https://www.wikiwand.com/en/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm\" rel=\"noopener\">KMP</a>, which conducts efficient searches of substrings</li></ul><h4 id=\"non-repeating-characters\"><strong>Non-repeating characters</strong></h4><p>Use a 26-bit bitmask to indicate which lower case Latin characters are inside the string.</p><pre tabindex=\"0\"><code>mask = 0\nfor c in set(word):\n  mask |= (1 &lt;&lt; (ord(c) - ord('a')))</code></pre><p>To determine if two strings have common characters, perform <code>&amp;</code> on the two bitmasks. If the result is non-zero, <code>mask_a &amp; mask_b &gt; 0</code> , then the two strings have common characters.</p><h4 id=\"anagram\"><strong>Anagram</strong></h4><p>An anagram is word switch or word play. It is the result of re-arranging the letters of a word or phrase to produce a new word or phrase, while using all the original letters only once. In interviews, usually we are only bothered with words without spaces in them.</p><p>To determine if two strings are anagrams, there are a few plausible approaches:</p><ul><li>Sorting both strings should produce the same resulting string. This takes O(nlgn) time and O(lgn) space.</li><li>If we map each character to a prime number and we multiply each mapped number together, anagrams should have the same multiple (prime factor decomposition). This takes O(n) time and O(1) space.</li><li>Frequency counting of characters will help to determine if two strings are anagrams. This also takes O(n) time and O(1) space.</li></ul><h4 id=\"palindrome\"><strong>Palindrome</strong></h4><p>A <strong><strong>palindrome</strong></strong> is a word, phrase, <a href=\"https://en.wikipedia.org/wiki/Palindromic_number\" rel=\"noopener\">number</a>, or other sequence of <a href=\"https://en.wikipedia.org/wiki/Character_(symbol)\" rel=\"noopener\">characters</a> that reads the same backward and forward, such as <em><em>madam</em></em> or <em><em>racecar</em></em>.</p><p>Here are ways to determine if a string is a palindrome:</p><ul><li>Reverse the string and it should be equal to itself.</li><li>Have two pointers at the start and end of the string. Move the pointers inward till they meet. At any point in time, the characters at both pointers should match.</li></ul><p>The order of characters within the string matters, so HashMaps are usually not helpful.</p><p>When a question is about counting the number of palindromes, a common trick is to have two pointers that move outward, away from the middle. Note that palindromes can be even or odd length. For each middle pivot position, you need to check it twice: Once that includes the character and once without the character.</p><ul><li>For substrings, you can terminate early once there is no match.</li><li>For subsequences, use dynamic programming as there are overlapping subproblems. Check out <a href=\"https://leetcode.com/problems/longest-palindromic-subsequence/\" rel=\"noopener\">this question</a>.</li></ul><h4 id=\"corner-cases-7\"><strong>Corner Cases</strong></h4><ul><li>Empty string</li><li>Single-character string</li><li>Strings with only one distinct character</li></ul><h4 id=\"practice-questions-9\"><strong>Practice Questions</strong></h4><ul><li><a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\" rel=\"noopener\">Longest Substring Without Repeating Characters</a></li><li><a href=\"https://leetcode.com/problems/longest-repeating-character-replacement/\" rel=\"noopener\">Longest Repeating Character Replacement</a></li><li><a href=\"https://leetcode.com/problems/minimum-window-substring/description/\" rel=\"noopener\">Minimum Window Substring</a></li><li><a href=\"https://leetcode.com/problems/encode-and-decode-strings/\" rel=\"noopener\">Encode and Decode Strings</a></li><li><a href=\"https://leetcode.com/problems/valid-anagram\" rel=\"noopener\">Valid Anagram</a></li><li><a href=\"https://leetcode.com/problems/group-anagrams/\" rel=\"noopener\">Group Anagrams</a></li><li><a href=\"https://leetcode.com/problems/valid-parentheses\" rel=\"noopener\">Valid Parentheses</a></li><li><a href=\"https://leetcode.com/problems/valid-palindrome/\" rel=\"noopener\">Valid Palindrome</a></li><li><a href=\"https://leetcode.com/problems/longest-palindromic-substring/\" rel=\"noopener\">Longest Palindromic Substring</a></li><li><a href=\"https://leetcode.com/problems/palindromic-substrings/\" rel=\"noopener\">Palindromic Substrings</a></li></ul><h2 id=\"tree\">Tree</h2><h4 id=\"study-links-3\"><strong>Study Links</strong></h4><ul><li><a href=\"https://medium.com/basecs/leaf-it-up-to-binary-trees-11001aaf746d\" rel=\"noopener\">Leaf It Up To Binary Trees</a></li></ul><h4 id=\"notes-12\"><strong>Notes</strong></h4><p>A tree is an undirected and connected acyclic graph.</p><p>Recursion is a common approach for trees. When you notice that the subtree problem can be used to solve the entire problem, try using recursion.</p><p>When using recursion, always remember to check for the base case, usually where the node is <code>null</code>.</p><p>When you are asked to traverse a tree by level, use depth first search.</p><p>Sometimes it is possible that your recursive function needs to return two values.</p><p>If the question involves summation of nodes along the way, be sure to check whether nodes can be negative.</p><p>You should be very familiar with writing pre-order, in-order, and post-order traversal recursively. As an extension, challenge yourself by writing them iteratively. Sometimes interviewers ask candidates for the iterative approach, especially if the candidate finishes writing the recursive approach too quickly.</p><h2 id=\"binary-tree\">Binary tree</h2><p>In-order traversal of a binary tree is insufficient to uniquely serialize a tree. Pre-order or post-order traversal is also required.</p><h2 id=\"binary-search-tree-bst-\">Binary search tree (BST)</h2><p>In-order traversal of a BST will give you all elements in order.</p><p>Be very familiar with the properties of a BST. Validate that a binary tree is a BST. This comes up more often than expected.</p><p>When a question involves a BST, the interviewer is usually looking for a solution which runs faster than O(n).</p><h4 id=\"corner-cases-8\"><strong>Corner Cases</strong></h4><ul><li>Empty tree</li><li>Single node</li><li>Two nodes</li><li>Very skewed tree (like a linked list)</li></ul><h4 id=\"practice-questions-10\"><strong>Practice Questions</strong></h4><ul><li><a href=\"https://leetcode.com/problems/maximum-depth-of-binary-tree/\" rel=\"noopener\">Maximum Depth of Binary Tree</a></li><li><a href=\"https://leetcode.com/problems/same-tree/\" rel=\"noopener\">Same Tree</a></li><li><a href=\"https://leetcode.com/problems/invert-binary-tree/\" rel=\"noopener\">Invert or Flip Binary Tree</a></li><li><a href=\"https://leetcode.com/problems/binary-tree-maximum-path-sum/\" rel=\"noopener\">Binary Tree Maximum Path Sum</a></li><li><a href=\"https://leetcode.com/problems/binary-tree-level-order-traversal/\" rel=\"noopener\">Binary Tree Level Order Traversal</a></li><li><a href=\"https://leetcode.com/problems/serialize-and-deserialize-binary-tree/\" rel=\"noopener\">Serialize and Deserialize Binary Tree</a></li><li><a href=\"https://leetcode.com/problems/subtree-of-another-tree/\" rel=\"noopener\">Subtree of Another Tree</a></li><li><a href=\"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\" rel=\"noopener\">Construct Binary Tree from Preorder and Inorder Traversal</a></li><li><a href=\"https://leetcode.com/problems/validate-binary-search-tree/\" rel=\"noopener\">Validate Binary Search Tree</a></li><li><a href=\"https://leetcode.com/problems/kth-smallest-element-in-a-bst/\" rel=\"noopener\">Kth Smallest Element in a BST</a></li><li><a href=\"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\" rel=\"noopener\">Lowest Common Ancestor of BST</a></li></ul><h2 id=\"tries\">Tries</h2><h4 id=\"study-links-4\"><strong>Study Links</strong></h4><ul><li><a href=\"https://medium.com/basecs/trying-to-understand-tries-3ec6bede0014\" rel=\"noopener\">Trying to Understand Tries</a></li><li><a href=\"https://leetcode.com/articles/implement-trie-prefix-tree/\" rel=\"noopener\">Implement Trie (Prefix Tree)</a></li></ul><h4 id=\"notes-13\"><strong>Notes</strong></h4><p>Tries are special trees (prefix trees) that make searching and storing strings more efficient. Tries have many practical applications, such as conducting searches and providing autocomplete. It is helpful to know these common applications so that you can easily identify when a problem can be efficiently solved using a trie.</p><p>Sometimes preprocessing a dictionary of words (given in a list) into a trie, will improve the efficiency of searching for a word of length <em><em>k,</em></em> among <em><em>n</em></em> words. Searching becomes O(k) instead of O(n).</p><p>Be familiar with implementing, from scratch, a <code>Trie</code> class and its <code>add</code>, <code>remove</code> , and <code>search</code> methods.</p><h4 id=\"practice-questions-11\"><strong>Practice Questions</strong></h4><ul><li><a href=\"https://leetcode.com/problems/implement-trie-prefix-tree\" rel=\"noopener\">Implement Trie (Prefix Tree)</a></li><li><a href=\"https://leetcode.com/problems/add-and-search-word-data-structure-design\" rel=\"noopener\">Add and Search Word</a></li><li><a href=\"https://leetcode.com/problems/word-search-ii/\" rel=\"noopener\">Word Search II</a></li></ul><h2 id=\"heap\">Heap</h2><h4 id=\"study-links-5\"><strong>Study Links</strong></h4><ul><li><a href=\"https://medium.com/basecs/learning-to-love-heaps-cef2b273a238\" rel=\"noopener\">Learning to Love Heaps</a></li></ul><h4 id=\"notes-14\"><strong>Notes</strong></h4><p>If you see a top or lowest <em><em>k</em></em> mentioned in the question, it is usually a sign that a heap can be used to solve the problem, such as in <a href=\"https://leetcode.com/problems/top-k-frequent-elements/\" rel=\"noopener\">Top K Frequent Elements</a>.</p><p>If you require the top <em><em>k </em></em>elements, use a Min Heap of size <em><em>k</em></em>. Iterate through each element, pushing it into the heap. Whenever the heap size exceeds <em><em>k</em></em>, remove the minimum element. That will guarantee that you have the <em><em>k </em></em>largest elements.</p><h4 id=\"practice-questions-12\"><strong>Practice Questions</strong></h4><ul><li><a href=\"https://leetcode.com/problems/merge-k-sorted-lists/\" rel=\"noopener\">Merge K Sorted Lists</a></li><li><a href=\"https://leetcode.com/problems/top-k-frequent-elements/\" rel=\"noopener\">Top K Frequent Elements</a></li><li><a href=\"https://leetcode.com/problems/find-median-from-data-stream/\" rel=\"noopener\">Find Median from Data Stream</a></li></ul><h2 id=\"conclusion\">Conclusion</h2><p>Coding interviews are tough. But fortunately, you can get better at them by studying and practicing for them, and doing mock interviews.</p><p>To recap, to do well in coding interviews:</p><ol><li>Decide on a programming language</li><li>Study CS fundamentals</li><li>Practice solving algorithm questions</li><li>Internalize the <a href=\"https://github.com/yangshun/tech-interview-handbook/blob/master/preparing/cheatsheet.md\" rel=\"noopener\">Do\u2019s and Don\u2019ts of interviews</a></li><li>Practice by doing mock technical interviews</li><li>Interview successfully to get the job</li></ol><p>By following these steps, you will improve your coding interview skills, and be one step closer (or probably more) to landing your dream job.</p><p>All the best!</p><p>The content for this post <a href=\"https://www.techinterviewhandbook.org/\">can be found here</a>. Future updates will be posted there. Pull requests for suggestions and corrections are welcome.</p><p>If you enjoyed this article, share it with your friends!</p><p>You can also follow me on <a href=\"https://github.com/yangshun\" rel=\"noopener\">GitHub</a> and <a href=\"https://twitter.com/yangshunz\" rel=\"noopener\">Twitter</a>.</p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nBack in 2017, I went through some coding interviews and got offers from several large tech companies. So at that point, I decided to share what I'd learned in this article.And I've just updated it for 2022 so it'll be super useful and relevant if you're job hunting now.Despite scoring decent grades in both my CS101 Algorithm class and my Data Structures class in university, I shudder at the thought of going through a coding interview that focuses on algorithms.Hence I spent the last three months figuring out how to improve my coding interview skills and eventually received offers from big tech companies like Google, Facebook, Airbnb, Lyft, Dropbox and more. In this post, I\u2019ll be sharing the insights and tips I gained along the way. Experienced candidates can also expect System Design questions, but that is out of the scope of this post.Many of the algorithmic concepts tested in coding interviews are not what I usually use at work, where I am a Front End Engineer (web). Naturally, I have forgotten quite a bit about these algorithms and data structures, which I learned mostly during my freshmen and sophomore years of college.It\u2019s stressful to have to produce (working) code in an interview, while someone scrutinizes every keystroke that you make. What\u2019s worse is that as an interviewee, you\u2019re encouraged to communicate your thought process out loud to the interviewer.I used to think that being able to think, code, and communicate simultaneously was an impossible feat, until I realized that most people are just not good at coding interviews when they first start out. Interviewing is a skill that you can get better at by studying, preparing, and practicing for it.My recent job search has led me on a journey to improve my coding interview skills. Front End Engineers like to rant about how the current hiring process is broken because technical interviews can include skills not related to front-end development. For example, writing a maze solving algorithm and merging two sorted lists of numbers. As a Front End Engineer myself, I can empathize with them.Front end is a specialized domain where engineers have to care about many issues related to browser compatibilities, the Document Object Model, JavaScript performance, CSS layouts, and so on. It is uncommon for front-end engineers to implement some of the complex algorithms tested in interviews.At companies like Facebook and Google, the people are software engineers first, domain experts second.Unfortunately, rules are set by the companies, not the candidates. There is a high emphasis on general computer science concepts like algorithms, design patterns, data structures; core skills that a good software engineer should possess. If you want the job, you have to play by the rules set by the game masters \u2014 improve your coding interview skills!This post is structured into the following two sections. Feel free to skip ahead to the section that interests you.The breakdown of coding interviews, and how to prepare for them.Helpful tips and hints for each algorithm topic (arrays, trees, dynamic programming, etc.), along with recommended LeetCode practice questions to review core concepts and to improve on those topics.The content for this post can be found here. I'll make updates there when necessary.If you are interested in Front End content, check out my front end interview handbook here.Picking a programming languageBefore anything else, you need to pick a programming language for your algorithmic coding interview. Most companies will allow you to code in the language of your choice. The only exception I know is Google. They allow their candidates to pick from only Java, C++, Python, Go or JavaScript. For the most part, I recommend using a language that you are extremely familiar with, rather than one that is new to you but that the company uses widely.There are some languages that are more suitable than others for coding interviews. Then there are some that you absolutely want to avoid. From my experience as an interviewer, most candidates pick Python or Java. Other languages commonly selected include JavaScript, Ruby, and C++. I would absolutely avoid lower-level languages like C or Go, simply because they lack standard library functions and data structures.Personally, Python is my de facto choice for coding algorithms during interviews. It is succinct and has a huge library of functions and data structures. One of the top reasons I recommend Python is that it uses consistent APIs that operate on different data structures, such as len(), for ... in ... and slicing notation on sequences (strings, lists, and tuples). Getting the last element in a sequence is arr[-1] , and reversing it is simply arr[::-1]. You can achieve a lot with minimal syntax in Python.Java is a decent choice too. But because you will have to constantly declare types in your code, it means entering extra keystrokes. This will slow down the speed at which you code and type. This issue will be more apparent when you have to write on a whiteboard during on-site interviews.The reasons for choosing or not choosing C++ are similar to Java. Ultimately, Python, Java, and C++ are decent choices. If you have been using Java for a while, and do not have time to become familiar with another language, I recommend sticking to Java instead of picking up Python from scratch. This helps you to avoid having to use one language for work and another one for interviews. Most of the time, the bottleneck is in the thinking and not the writing.One exception to the convention of allowing the candidate to \u201cpick any programming language they want\u201d is when the interview is for a domain-specific position, such as front-end, iOS, or Android engineer roles. You need to be familiar with coding algorithms in JavaScript, Objective-C, Swift, and Java, respectively.If you need to use a data structure that the language does not support, such as a queue or heap in JavaScript, ask the interviewer if you can assume that you have a data structure that implements certain methods with specified time complexities. If the implementation of that data structure is not crucial to solving the problem, the interviewer will usually allow it. In reality, being aware of existing data structures and selecting the appropriate ones to tackle the problem at hand is more important than knowing the intricate implementation details.Review your CS101If you have been out of college for some time, it is highly advisable to review the CS fundamentals. I prefer to review it as I practice. I scan through my notes from college and revise the various algorithms as I work on the algorithm problems from LeetCode and Cracking the Coding Interview.If you are interested in how data structures are implemented, check out Lago, a GitHub repository containing Data Structures and Algorithms examples in JavaScript.GitHub - yangshun/lago: \ud83d\udcd5 Data Structures and Algorithms library in TypeScript\ud83d\udcd5 Data Structures and Algorithms library in TypeScript - GitHub - yangshun/lago: \ud83d\udcd5 Data Structures and Algorithms library in TypeScriptyangshunGitHubMastery through practiceNext, gain familiarity and mastery of the algorithms and data structures in your chosen programming language.Practice and solve algorithm questions in your chosen language. While Cracking the Coding Interview is a good resource, I prefer solving problems by typing code, letting it run, and getting instant feedback. There are various Online Judges, such as LeetCode, HackerRank, and CodeForces for you to practice questions online and to get used to the language. From my experience, LeetCode questions are most similar to the questions asked in interviews. HackerRank and CodeForces questions are more similar to questions in competitive programming. If you practice enough LeetCode questions, there is a good chance that you will either see or complete one of your actual interview questions (or some variant of it).Learn and understand the time and space complexities of the common operations in your chosen language. For Python, this page will come in handy. Also, learn about the underlying sorting algorithm being used in the language\u2019s sort() function and its time and space complexities (in Python it\u2019s Timsort, which is a hybrid). After completing a question on LeetCode, I usually add the time and space complexities of the written code as comments above the function body. I use the comments to remind myself to communicate the analysis of the algorithm after I have completed the implementation.Read up on the recommended coding style for your language and stick to it. If you choose Python, refer to the PEP 8 Style Guide. If you choose Java, refer to Google\u2019s Java Style Guide.Learn about and be familiar with the common pitfalls and caveats of the language. If you point them out during the interview and avoid falling into them, you will earn bonus points and impress the interviewer, regardless of whether the interviewer is familiar with the language or not.Gain a broad exposure to questions from various topics. In the second half of the article, I mention algorithm topics and the useful questions for each topic to practice. Do around 100 to 200 LeetCode questions, and you should be good.If you prefer courses where the learning is more structured, here are a few recommendations. In no way is taking online courses a must in order to pass interviews.AlgoMonster aims to help you ace the technical interview in the shortest time possible. By Google engineers, AlgoMonster uses a data-driven approach to teach you the most useful key question patterns and has contents to help you quickly revise basic data structures and algorithms. Best of all, AlgoMonster is not subscription-based - pay a one-time fee and get lifetime access.Grokking the Coding Interview: Patterns for Coding Questions by Educative expands on the recommended practice questions in this article but approaches the practicing from a questions pattern perspective, which is an approach I also agree with for learning and have personally used to get better at coding interviews. The course allows you to practice selected questions in Java, Python, C++, JavaScript and also provides sample solutions in those languages. Learn and understand patterns, not memorize answers.And of course, practice, practice, and more practice!Phases of a coding interviewCongratulations, you are ready to put your skills to practice! In a coding interview, you will be given a technical question by the interviewer. You will write the code in a real-time, collaborative editor (phone screen) or on a whiteboard (on-site), and have 30 to 45 minutes to solve the problem. This is where the real fun begins!Your interviewer will be looking to see that you meet the requirements of the role. It is up to you to show them that you have the skills. Initially, it may feel weird to talk while you code, as most programmers do not make a habit of explaining out loud their thoughts while they are typing code.However, it is hard for the interviewer to know what you are thinking by just looking at your code. If you communicate your approach to the interviewer even before you start to code, you can validate your approach with them. This way, the two of you can agree on an acceptable approach.Preparing for a remote interviewFor phone screens and remote interviews, have a paper and pen or pencil to jot down any notes or diagrams. If you are given a question about trees and graphs, it usually helps if you draw examples of the data structure.Use earphones. Make sure you are in a quiet environment. You do not want to be holding a phone in one hand and typing with the other. Try to avoid using speakers. If the feedback is bad, communication is made harder. Having to repeat yourself will just result in the loss of valuable time.What to do when you get the questionMany candidates start coding as soon as they hear the question. That is usually a big mistake. First, take a moment and repeat the question back to the interviewer to make sure that you understand the question. If you misunderstand the question, then the interviewer can clarify.Always seek clarification about the question upon hearing it, even if you think it is clear. You might discover that you have missed something. It also lets the interviewer know that you are attentive to details.Consider asking the following questions.How big is the size of the input?How big is the range of values?What kind of values are there? Are there negative numbers? Floating points? Will there be empty inputs?Are there duplicates within the input?What are some extreme cases of the input?How is the input stored? If you are given a dictionary of words, is it a list of strings or a trie?After you have sufficiently clarified the scope and intention of the problem, explain your high-level approach to the interviewer, even if it is a naive solution. If you are stuck, consider various approaches and explain out loud why it may or may not work. Sometimes your interviewer might drop hints and lead you toward the right path.Start with a brute-force approach. Communicate it to the interviewer. Explain the time and space complexities and clarify why it is bad. It is unlikely that the brute-force approach will be the one that you will be coding. At this point, the interviewer will usually pop the dreaded, \u201cCan we do better?\u201d question. This means they are looking for a more optimal approach.This is usually the hardest part of the interview. In general, look for repeated work and try to optimize them by potentially caching the calculated result somewhere. Reference it later, rather than computing it all over again. I provide some tips on tackling topic-specific questions in detail below.Only start coding after you and your interviewer have agreed on an approach and you have been given the green light.Starting to codeUse a good style to write your code. Reading code written by others is usually not an enjoyable task. Reading horribly formatted code written by others is even worse. Your goal is to make your interviewer understand your code so that they can quickly evaluate if your code does what it is suppose to and if it solves a given problem. Use clear variable names and avoid names that are single letters, unless they are for iteration. However, if you are coding on a whiteboard, avoid using verbose variable names. This reduces the amount of writing you will have to do.Always explain to the interviewer what you are writing or typing. This is not about reading, verbatim, to the interviewer the code you are producing. Talk about the section of the code you are currently implementing at a higher level. Explain why it is written as such, and what it is trying to achieve.When you copy and paste in code, consider whether it is necessary. Sometimes it is, sometimes it is not. If you find yourself copying and pasting a large chunk of code spanning multiple lines, it is probably an indicator that you can restructure the code by extracting those lines into a function. If it is just a single line you copied, usually it is fine. However, remember to change the respective variables in your copied line of code where relevant. Copying and pasting errors are a common source of bugs, even in day-to-day coding!After codingAfter you have finished coding, do not immediately announce to the interviewer that you are done. In most cases, your code is usually not perfect. It may contain bugs or syntax errors. What you need to do is review your code.First, look through your code from start to finish. Look at it as if it were written by someone else, and you are seeing it for the first time and trying to spot bugs in it. That\u2019s exactly what your interviewer will be doing. Review and fix any issues you may find.Next, come up with small test cases and step through the code (not your algorithm) with those sample input. Interviewers like it when you read their minds. What they usually do after you have finished coding is get you to write tests. It is a huge plus if you write tests for your code even before they prompt you to do so. You should be emulating a debugger when stepping through your code. Jot down or tell them the values of certain variables as you walk the interviewer through the lines of code.If there are large duplicated chunks of code in your solution, restructure the code to show the interviewer that you value quality coding. Also, look out for places where you can do short-circuit evaluation.Lastly, give the time and space complexities of your code, and explain why it is such. You can annotate chunks of your code with their various time and space complexities to demonstrate your understanding of the code. You can even provide the APIs of your chosen programming language. Explain any trade-offs in your current approach versus alternative approaches, possibly in terms of time and space.If your interviewer is happy with the solution, the interview usually ends here. It is also common that the interviewer asks you extension questions, such as how you would handle the problem if the whole input is too large to fit into memory, or if the input arrives as a stream. This is a common follow-up question at Google, where they care a lot about scale. The answer is usually a divide-and-conquer approach \u2014 perform distributed processing of the data and only read certain chunks of the input from disk into memory, write the output back to disk and combine them later.Practice with mock interviewsThe steps mentioned above can be rehearsed over and over again until you have fully internalized them and they become second nature to you. A good way to practice is by partnering with a friend and taking turns to interview each other.A great resource for preparing for coding interviews is interviewing.io. This platform provides free and anonymous practice interviews with Google and Facebook engineers, which can lead to real jobs and internships. By virtue of being anonymous during the interview, the inclusive interview process is unbiased and low risk. At the end of the interview, both the interviewer and interviewee can provide feedback to each other for the purpose of helping one another improve.Doing well in mock interviews will unlock the jobs page for candidates, and allow them to book interviews (also anonymously) with top companies like Uber, Lyft, Quora, Asana, and more. For those who are new to coding interviews, a demo interview can be viewed on this site. Note that this site requires users to sign in.I have used interviewing.io, both as an interviewer and an interviewee. The experience was great. Aline Lerner, the CEO and co-founder of interviewing.io, and her team are passionate about revolutionizing the process for coding interviews and helping candidates improve their interview skills. She has also published a number of coding interview-related articles on the interviewing.io blog. I recommend signing up as early as possible with interviewing.io, even though it's in beta, to increase the likelihood of receiving an invite.Another platform that allows you to practice coding interviews is Pramp. Where interviewing.io matches potential job seekers with seasoned coding interviewers, Pramp takes a different approach. Pramp pairs you up with another peer who is also a job seeker. The two of you take turns assuming the roles of interviewer and interviewee. Pramp also prepares questions, and provides solutions and prompts to guide the interviewee.Go forth and conquerAfter doing a fair amount of questions on LeetCode and having enough practice doing mock interviews, go forth and put your new-found interviewing skills to the test. Apply to your favorite companies or, better still, get referrals from your friends working for those companies. Referrals tend to get noticed earlier and have a faster response rate than applying without a referral. Good luck!Practical tips for coding questionsThis section dives deep into practical tips for specific topics of algorithms and data structures, which appear frequently in coding questions. Many algorithm questions involve techniques that can be applied to questions of a similar nature.The more techniques you have in your arsenal, the greater your chances of passing the interview. For each topic, there is also a list of recommended questions, which is valuable for mastering the core concepts. Some of the questions are only available with a paid subscription to LeetCode, which in my opinion is absolutely worth the money if it lands you a job.General tipsAlways validate input first. Check for inputs that are invalid, empty, negative, or different. Never assume you are given the valid parameters. Alternatively, clarify with the interviewer whether you can assume valid input (usually yes), which can save you time from writing code that does input validation.Are there any time and space complexities requirements or constraints?Check for off-by-one errors.In languages where there are no automatic type coercion, check that concatenation of values are of the same type: int,str, and list.After you finish your code, use a few example inputs to test your solution.Is the algorithm supposed to run multiple times, perhaps on a web server? If yes, the input can likely be pre-processed to improve the efficiency in each API call.Use a mix of functional and imperative programming paradigms:Write pure functions as often as possible.Use pure functions because they are easier to reason with and can help reduce bugs in your implementation.Avoid mutating the parameters passed into your function, especially if they are passed by reference, unless you are sure of what you are doing.Achieve a balance between accuracy and efficiency. Use the right amount of functional and imperative code where appropriate. Functional programming is usually expensive in terms of space complexity because of non-mutation and the repeated allocation of new objects. On the other hand, imperative code is faster because you operate on existing objects.Avoid relying on mutating global variables. Global variables introduce state.Make sure that you do not accidentally mutate global variables, especially if you have to rely on them.Generally, to improve the speed of a program, we can choose to either use an appropriate data structure or algorithm, or to use more memory. It\u2019s a classic space and time trade off.Data structures are your weapons. Choosing the right weapon for the right battle is the key to victory. Know the strengths of each data structure and the time complexity for its various operations.Data structures can be augmented to achieve efficient time complexity across different operations. For example, a HashMap can be used together with a doubly-linked list to achieve O(1) time complexity for both the get and put operation in an LRU cache.HashMaps are probably the most commonly used data structure for algorithm questions. If you are stuck on a question, your last resort can be to enumerate through the possible data structures (thankfully there aren\u2019t that many) and consider whether each of them can be applied to the problem. This has worked for me at times.If you are cutting corners in your code, state that out loud to your interviewer, and explain to them what you would do outside of an interview setting (no time constraints). For example, explain that you would write a regex to parse a string rather than using split , which does not cover all cases.SequenceNotesArrays and strings are considered sequences (a string is a sequence of characters). There are tips for dealing with both arrays and strings, which will be covered here.Are there duplicate values in the sequence? Would they affect the answer?Check for sequence out of bounds.Be mindful about slicing or concatenating sequences in your code. Typically, slicing and concatenating sequences require O(n) time. Use start and end indices to demarcate a subarray or substring where possible.Sometimes you traverse the sequence from the right side rather than from the left.Master the sliding window technique that applies to many substring or subarray problems.When you are given two sequences to process, it is common to have one index per sequence to traverse. For example, we use the same approach to merge two sorted arrays.Corner CasesEmpty sequenceSequence with 1 or 2 elementsSequence with repeated elementsArrayNotesIs the array sorted or partially sorted? If it is either, some form of binary search should be possible. This usually means that the interviewer is looking for a solution that is faster than O(n).Can you sort the array? Sometimes sorting the array first may significantly simplify the problem. Make sure that the order of array elements do not need to be preserved before attempting to sort it.For questions where summation or multiplication of a subarray is involved, pre-computation using hashing or a prefix, suffix sum, or product might be useful.If you are given a sequence and the interviewer asks for O(1) space, it might be possible to use the array itself as a hash table. For example, if the array has values only from 1 to N, where N is the length of the array, negate the value at that index (minus one) to indicate the presence of that number.Practice QuestionsTwo SumBest Time to Buy and Sell StockContains DuplicateProduct of Array Except SelfMaximum SubarrayMaximum Product SubarrayFind Minimum in Rotated Sorted ArraySearch in Rotated Sorted Array3SumContainer With Most WaterBinaryStudy LinksBits, Bytes, Building With BinaryNotesQuestions involving binary representations and bitwise operations are asked sometimes. You must know how to convert a number from decimal form into binary form, and vice versa, in your chosen programming language.Some helpful utility snippets:Test kth bit is set: num & (1 << k) != 0Set kth bit: num |= (1 << k)Turn off kth bit: num &= ~(1 << k)Toggle the kth bit: num ^= (1 << k)To check if a number is a power of 2: num & num - 1 == 0.Corner CasesCheck for overflow/underflowNegative numbersPractice QuestionsSum of Two IntegersNumber of 1 BitsCounting BitsMissing NumberReverse BitsDynamic ProgrammingStudy LinksDemystifying Dynamic ProgrammingNotesDynamic Programming (DP) is usually used to solve optimization problems. Alaina Kafkes has written an awesome post on tackling DP problems. You should read it.The only way to get better at DP is with practice. It takes lots of practice to recognize that a problem can be solved by DP.To optimize space, sometimes you do not have to store the entire DP table in memory. The last two values or the last two rows of the matrix will suffice.Practice Questions0/1 KnapsackClimbing StairsCoin ChangeLongest Increasing SubsequenceLongest Common SubsequenceWord Break ProblemCombination SumHouse Robber and House Robber IIDecode WaysUnique PathsJump GameGeometryNotesWhen comparing Euclidean distance between two pairs of points, using dx\u00b2 + dy\u00b2 is sufficient. It is unnecessary to square root the value.To find out if two circles overlap, check that the distance between the two centers of the circles is less than the sum of their radii.GraphStudy LinksFrom Theory To Practice: Representing GraphsDeep Dive Through A Graph: DFS TraversalGoing Broad In A Graph: BFS TraversalNotesBe familiar with the various graph representations and graph search algorithms, and with their time and space complexities.You can be given a list of edges and tasked to build your own graph from the edges to perform a traversal on. The common graph representations areAdjacency matrixAdjacency listHashMap of HashMapsSome inputs look like they are trees, but they are actually graphs. Clarify this with your interviewer. In that case, you will have to handle cycles and keep a set of visited nodes when traversing.Graph search algorithmsCommon: Breadth first search (BFS), Depth first search (DFS)Uncommon: Topological sort, Dijkstra\u2019s algorithmRare: Bellman-Ford algorithm, Floyd-Warshall algorithm, Prim\u2019s algorithm, and Kruskal\u2019s algorithmIn coding interviews, graphs are commonly represented as 2-D matrices, where cells are the nodes and each cell can traverse to its adjacent cells (up, down, left, and right). Hence it is important to be familiar with traversing a 2-D matrix. When recursively traversing the matrix, always ensure that your next position is within the boundary of the matrix. More tips for doing DFS on a matrix can be found here. A simple template for doing DFS on a matrix appears something like this:def traverse(matrix):\n  rows, cols = len(matrix), len(matrix[0])\n  visited = set()\n  directions = ((0, 1), (0, -1), (1, 0), (-1, 0))\n  def dfs(i, j):\n    if (i, j) in visited:\n      return\n    visited.add((i, j))\n    # Traverse neighbors\n    for direction in directions:\n      next_i, next_j = i + direction[0], j + direction[1]\n      if 0 <= next_i < rows and 0 <= next_j < cols: # Check boundary\n        # Add any other checking here ^\n        dfs(next_i, next_j)\n  for i in range(rows):\n    for j in range(cols):\n      dfs(i, j)Corner CasesEmpty graphGraph with one or two nodesDisjoint graphsGraph with cyclesPractice QuestionsClone GraphCourse ScheduleAlien DictionaryPacific Atlantic Water FlowNumber of IslandsGraph Valid TreeNumber of Connected Components in an Undirected GraphLongest Consecutive SequenceIntervalNotesInterval questions are questions that give an array of two-element arrays (an interval). The two values represent a start and an end value. Interval questions are considered to be part of the array family, but they involve some common techniques. Hence, they have their own special section.An example of an interval array: [[1, 2], [4, 7]].Interval questions can be tricky for those who do not have experience with them. This is because of the sheer number of cases to consider when interval arrays overlap.Clarify with the interviewer whether [1, 2] and [2, 3] are considered overlapping intervals, because it affects how you will write your equality checks.A common routine for interval questions is to sort the array of intervals by the start value of each interval.Be familiar with writing code to check if two intervals overlap and to merge two overlapping intervals:def is_overlap(a, b):\n  return a[0] < b[1] and b[0] < a[1]\n  \ndef merge_overlapping_intervals(a, b):\n  return [min(a[0], b[0]), max(a[1], b[1])]Corner CasesSingle intervalNon-overlapping intervalsAn interval totally consumed within another intervalDuplicate intervalsPractice QuestionsInsert IntervalMerge IntervalsMeeting Rooms and Meeting Rooms IINon-overlapping IntervalsLinked ListNotesLike arrays, linked lists are used to represent sequential data. The benefit of linked lists is that insertion and deletion of code from anywhere in the list is O(1), whereas in arrays, the elements have to be shifted.Adding a dummy node at the head and /or tail might help to handle many edge cases where operations have to be performed at the head or the tail. The presence of dummy nodes ensures that operations will never have be executed on the head or the tail. Dummy nodes remove the headache of writing conditional checks to deal with null pointers. Be sure to remove them at the end of the operation.Sometimes linked lists problem can be solved without additional storage. Try to borrow ideas from the for reverse a linked list problem.For deletion in linked lists, you can either modify the node values or change the node pointers. You might need to keep a reference to the previous element.For partitioning linked lists, create two separate linked lists and join them back together.Linked lists problems share similarities with array problems. Think about how you would solve an array problem and apply it to a linked list.Two pointer approaches are also common for linked lists:Getting the kth from the last node: Have two pointers, where one is k nodes ahead of the other. When the node ahead reaches the end, the other node is k nodes behind.Detecting cycles: Have two pointers, where one pointer increments twice as much as the other. If the two pointers meet, it means that there is a cycle.Getting the middle node: Have two pointers. One pointer increments twice as much as the other. When the faster node reaches the end of the list, the slower node will be at the middle.Be familiar with the following routines because many linked list questions make use of one or more of these routines in their solution.Count the number of nodes in the linked listReverse a linked list in placeFind the middle node of the linked list using fast or slow pointersMerge two lists togetherCorner CasesSingle nodeTwo nodesLinked list has cycle. Clarify with the interviewer whether there can be a cycle in the list. Usually the answer is no.Practice QuestionsReverse a Linked ListDetect Cycle in a Linked ListMerge Two Sorted ListsMerge K Sorted ListsRemove Nth Node From End Of ListReorder ListMathNotesIf the code involves division or modulo, remember to check for division or modulo by 0 case.When a question involves \u201ca multiple of a number\u201d, modulo might be useful.Check for and handle overflow and underflow if you are using a typed language like Java and C++. At the very least, mention that overflow or underflow is possible and ask whether you need to handle it.Consider negative numbers and floating point numbers. This may sound obvious, but when you are under pressure in an interview, many obvious points go unnoticed.If the question asks to implement an operator such as power, squareroot, or division, and it is to be faster than O(n), binary search is usually the approach.Some common formulasSum of 1 to N = (n+1) * n/2Sum of GP = 2\u2070 + 2\u00b9 + 2\u00b2 + 2\u00b3 + \u2026 2^n = 2^(n+1)-1Permutations of N = N! / (N-K)!Combinations of N = N! / (K! * (N-K)!)Corner CasesDivision by 0Integer overflow and underflowPractice QuestionsPow(x, n)Sqrt(x)Integer to English WordsMatrixNotesA matrix is a 2-dimensional array. Questions involving matrices are usually related to dynamic programming or graph traversal.For questions involving traversal or dynamic programming, make a copy of the matrix with the same dimensions that are initialized to empty values. Use these values to store the visited state or dynamic programming table. Be familiar with this routine:rows, cols = len(matrix), len(matrix[0])\ncopy = [[0 for _ in range(cols)] for _ in range(rows)Many grid-based games can be modeled as a matrix. For example, Tic-Tac-Toe, Sudoku, Crossword, Connect 4, and Battleship. It is not uncommon to be asked to verify the winning condition of the game. For games like Tic-Tac-Toe, Connect 4, and Crosswords, verification has to be done vertically and horizontally. One trick is to write code to verify the matrix for the horizontal cells. Then transpose the matrix, reusing the logic used for horizontal verification to verify originally vertical cells (which are now horizontal).Transposing a matrix in Python is simply:transposed_matrix = zip(*matrix)Corner CasesEmpty matrix. Check that none of the arrays are 0 length.1 x 1 matrix.Matrix with only one row or column.Practice QuestionsSet Matrix ZeroesSpiral MatrixRotate ImageWord SearchRecursionNotesRecursion is useful for permutation, because it generates all combinations and tree-based questions. You should know how to generate all permutations of a sequence as well as how to handle duplicates.Remember to always define a base case so that your recursion will end.Recursion implicitly uses a stack. Hence all recursive approaches can be rewritten iteratively using a stack. Beware of cases where the recursion level goes too deep and causes a stack overflow (the default limit in Python is 1000). You may get bonus points for pointing this out to the interviewer. Recursion will never be O(1) space complexity because a stack is involved, unless there is tail call optimization (TCO). Find out if your chosen language supports TCO.Practice QuestionsSubsets and Subsets IIStrobogrammatic Number IIStringNotesPlease read the above tips on sequence. They apply to strings too.Ask about input character set and case sensitivity. Usually the characters are limited to lowercase Latin characters, for example a to z.When you need to compare strings where the order isn\u2019t important (like anagram), you may consider using a HashMap as a counter. If your language has a built-in Counter class like Python, ask to use that instead.If you need to keep a counter of characters, a common mistake is to say that the space complexity required for the counter is O(n). The space required for a counter is O(1) not O(n). This is because the upper bound is the range of characters, which is usually a fixed constant of 26. The input set is just lowercase Latin characters.Common data structures for looking up strings efficiently areTrie/Prefix TreeSuffix TreeCommon string algorithms areRabin Karp, which conducts efficient searches of substrings, using a rolling hashKMP, which conducts efficient searches of substringsNon-repeating charactersUse a 26-bit bitmask to indicate which lower case Latin characters are inside the string.mask = 0\nfor c in set(word):\n  mask |= (1 << (ord(c) - ord('a')))To determine if two strings have common characters, perform & on the two bitmasks. If the result is non-zero, mask_a & mask_b > 0 , then the two strings have common characters.AnagramAn anagram is word switch or word play. It is the result of re-arranging the letters of a word or phrase to produce a new word or phrase, while using all the original letters only once. In interviews, usually we are only bothered with words without spaces in them.To determine if two strings are anagrams, there are a few plausible approaches:Sorting both strings should produce the same resulting string. This takes O(nlgn) time and O(lgn) space.If we map each character to a prime number and we multiply each mapped number together, anagrams should have the same multiple (prime factor decomposition). This takes O(n) time and O(1) space.Frequency counting of characters will help to determine if two strings are anagrams. This also takes O(n) time and O(1) space.PalindromeA palindrome is a word, phrase, number, or other sequence of characters that reads the same backward and forward, such as madam or racecar.Here are ways to determine if a string is a palindrome:Reverse the string and it should be equal to itself.Have two pointers at the start and end of the string. Move the pointers inward till they meet. At any point in time, the characters at both pointers should match.The order of characters within the string matters, so HashMaps are usually not helpful.When a question is about counting the number of palindromes, a common trick is to have two pointers that move outward, away from the middle. Note that palindromes can be even or odd length. For each middle pivot position, you need to check it twice: Once that includes the character and once without the character.For substrings, you can terminate early once there is no match.For subsequences, use dynamic programming as there are overlapping subproblems. Check out this question.Corner CasesEmpty stringSingle-character stringStrings with only one distinct characterPractice QuestionsLongest Substring Without Repeating CharactersLongest Repeating Character ReplacementMinimum Window SubstringEncode and Decode StringsValid AnagramGroup AnagramsValid ParenthesesValid PalindromeLongest Palindromic SubstringPalindromic SubstringsTreeStudy LinksLeaf It Up To Binary TreesNotesA tree is an undirected and connected acyclic graph.Recursion is a common approach for trees. When you notice that the subtree problem can be used to solve the entire problem, try using recursion.When using recursion, always remember to check for the base case, usually where the node is null.When you are asked to traverse a tree by level, use depth first search.Sometimes it is possible that your recursive function needs to return two values.If the question involves summation of nodes along the way, be sure to check whether nodes can be negative.You should be very familiar with writing pre-order, in-order, and post-order traversal recursively. As an extension, challenge yourself by writing them iteratively. Sometimes interviewers ask candidates for the iterative approach, especially if the candidate finishes writing the recursive approach too quickly.Binary treeIn-order traversal of a binary tree is insufficient to uniquely serialize a tree. Pre-order or post-order traversal is also required.Binary search tree (BST)In-order traversal of a BST will give you all elements in order.Be very familiar with the properties of a BST. Validate that a binary tree is a BST. This comes up more often than expected.When a question involves a BST, the interviewer is usually looking for a solution which runs faster than O(n).Corner CasesEmpty treeSingle nodeTwo nodesVery skewed tree (like a linked list)Practice QuestionsMaximum Depth of Binary TreeSame TreeInvert or Flip Binary TreeBinary Tree Maximum Path SumBinary Tree Level Order TraversalSerialize and Deserialize Binary TreeSubtree of Another TreeConstruct Binary Tree from Preorder and Inorder TraversalValidate Binary Search TreeKth Smallest Element in a BSTLowest Common Ancestor of BSTTriesStudy LinksTrying to Understand TriesImplement Trie (Prefix Tree)NotesTries are special trees (prefix trees) that make searching and storing strings more efficient. Tries have many practical applications, such as conducting searches and providing autocomplete. It is helpful to know these common applications so that you can easily identify when a problem can be efficiently solved using a trie.Sometimes preprocessing a dictionary of words (given in a list) into a trie, will improve the efficiency of searching for a word of length k, among n words. Searching becomes O(k) instead of O(n).Be familiar with implementing, from scratch, a Trie class and its add, remove , and search methods.Practice QuestionsImplement Trie (Prefix Tree)Add and Search WordWord Search IIHeapStudy LinksLearning to Love HeapsNotesIf you see a top or lowest k mentioned in the question, it is usually a sign that a heap can be used to solve the problem, such as in Top K Frequent Elements.If you require the top k elements, use a Min Heap of size k. Iterate through each element, pushing it into the heap. Whenever the heap size exceeds k, remove the minimum element. That will guarantee that you have the k largest elements.Practice QuestionsMerge K Sorted ListsTop K Frequent ElementsFind Median from Data StreamConclusionCoding interviews are tough. But fortunately, you can get better at them by studying and practicing for them, and doing mock interviews.To recap, to do well in coding interviews:Decide on a programming languageStudy CS fundamentalsPractice solving algorithm questionsInternalize the Do\u2019s and Don\u2019ts of interviewsPractice by doing mock technical interviewsInterview successfully to get the jobBy following these steps, you will improve your coding interview skills, and be one step closer (or probably more) to landing your dream job.All the best!The content for this post can be found here. Future updates will be posted there. Pull requests for suggestions and corrections are welcome.If you enjoyed this article, share it with your friends!You can also follow me on GitHub and Twitter.\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 43982, "excerpt": "Back in 2017, I went through some coding interviews and got offers from several\nlarge tech companies. So at that point, I decided to share what I'd learned in\nthis article.\n\nAnd I've just updated it for 2022 so it'll be super useful and relevant if\nyou're job hunting now.\n\nDespite scoring decent grades in both my CS101 Algorithm class and my Data\nStructures class in university, I shudder at the thought of going through a\ncoding interview that focuses on algorithms.\n\nHence I spent the last three", "siteName": "freeCodeCamp.org", "publishedTime": "2022-02-16T13:07:00.000Z", "id": "8cd31f9116e4cd7929bc8d9286da7141a028e1db", "url": "https://www.freecodecamp.org/news/coding-interviews-for-dummies-5e048933b82b/", "domain": "freecodecamp.org", "date": "2023-12-27T18:05:35.919782", "resultUri": "http://localhost:3000/result/8cd31f9116e4cd7929bc8d9286da7141a028e1db", "query": {"url": ["https://www.freecodecamp.org/news/coding-interviews-for-dummies-5e048933b82b/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "How to Rock the Coding Interview \u2013 Tips That Helped Me Land Job Offers from Google, Airbnb, and Dropbox", "description": "Back in 2017, I went through some coding interviews and got offers from several large tech companies. So at that point, I decided to share what I'd learned in this article. And I've just updated it for 2022 so it'll be super useful and relevant if you're job hunting now.", "url": "https://www.freecodecamp.org/news/coding-interviews-for-dummies-5e048933b82b/", "image": "https://cdn-media-1.freecodecamp.org/images/1*Qf9fEs5XdOEQiWX3R6R6ww.jpeg", "image:width": "800", "image:height": "492"}, "twitter": {"card": "summary_large_image", "title": "How to Rock the Coding Interview \u2013 Tips That Helped Me Land Job Offers from Google, Airbnb, and Dropbox", "description": "Back in 2017, I went through some coding interviews and got offers from several large tech companies. So at that point, I decided to share what I'd learned in this article. And I've just updated it for 2022 so it'll be super useful and relevant if you're job hunting now.", "url": "https://www.freecodecamp.org/news/coding-interviews-for-dummies-5e048933b82b/", "image": "https://cdn-media-1.freecodecamp.org/images/1*Qf9fEs5XdOEQiWX3R6R6ww.jpeg", "label1": "Written by", "data1": "Yangshun Tay", "label2": "Filed under", "data2": "Web Development, Technology, Self Improvement, Startup, Programming", "site": "@freecodecamp", "creator": "@yangshunz"}}}