{"title": "An intro to Algorithms: Dynamic Programming", "byline": "freeCodeCamp.org", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>An intro to Algorithms: Dynamic Programming</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>by Meet Zaveri</p><p>Suppose you are doing some calculation using an appropriate series of input. There is some computation done at every instance to derive some result. You don\u2019t know that you had encountered the <strong>same output </strong>when you had supplied the <strong>same input</strong>. So it\u2019s like you are doing re-computation of a result that was previously achieved by specific input for its respective output.</p><p>But what\u2019s the problem here? Thing is that your precious time is wasted. You can easily solve the problem here by keeping records that map previously computed results. Such as using the appropriate data structure. For example, you could store input as key and output as a value (part of mapping).</p><blockquote>Those who cannot remember the past are condemned to repeat it. ~Dynamic Programming</blockquote><p>Now by analyzing the problem, store its input if it\u2019s new (or not in the data structure) with its respective output. Else check that input key and get the resultant output from its value. That way when you do some computation and check if that input existed in that data structure, you can directly get the result. Thus we can relate this approach to dynamic programming techniques.</p><h3 id=\"diving-into-dynamic-programming\">Diving into dynamic programming</h3><p>In a nutshell, we can say that dynamic programming is used primarily for optimizing problems, where we wish to find the \u201cbest\u201d way of doing something.</p><p>A certain scenario is like there are re-occurring subproblems which in turn have their own smaller subproblems. Instead of trying to solve those re-appearing subproblems, again and again, dynamic programming suggests solving each of the smaller subproblems only once. Then you record the results in a table from which a solution to the original problem can be obtained.</p><p>For instance, the <a href=\"http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fib.html\" rel=\"noopener\">Fibonacci numbers</a> <code>0,1,1,2,3,5,8,13,\u2026</code> have a simple description where each term is related to the two terms before it. If <code>F(n)</code> is the <code>n</code>th term of this series then we have <code>F(n) = F(n-1) + F(n-2)</code>. This is called a <strong>recursive formula</strong> or a <strong>recurrence relation.</strong> It needs earlier terms to have been computed in order to compute a later term.</p><figure><img alt=\"2MrMcNofQOnzWkh-hkALV4udgyak1WqE7D1w\" height=\"600\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/2MrMcNofQOnzWkh-hkALV4udgyak1WqE7D1w\" width=\"800\"/></figure><p>The majority of Dynamic Programming problems can be categorized into two types:</p><ol><li><strong>Optimization problems.</strong></li><li><strong>Combinatorial problems.</strong></li></ol><p>The optimization problems expect you to select a feasible solution so that the value of the required function is minimized or maximized. Combinatorial problems expect you to figure out the number of ways to do something or the probability of some event happening.</p><h3 id=\"an-approach-to-solve-top-down-vs-bottom-up\">An approach to solve: top-down vs bottom-up</h3><p>There are the following two main different ways to solve the problem:</p><p><strong>Top-down: </strong>You start from the top, solving the problem by breaking it down. If you see that the problem has been solved already, then just return the saved answer. This is referred to as <strong><em>Memoization.</em></strong></p><p><strong>Bottom-up: </strong>You directly start solving the smaller subproblems making your way to the top to derive the final solution of that one big problem. In this process, it is guaranteed that the subproblems are solved before solving the problem. This can be called <strong><em>Tabulation</em></strong> (<strong>table-filling algorithm</strong>).</p><p>In reference to iteration vs recursion, bottom-up uses iteration and the top-down uses recursion.</p><figure><img alt=\"bcZt7dF4Z8GUcRAicU7eETW98YOikSzsJqKa\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/bcZt7dF4Z8GUcRAicU7eETW98YOikSzsJqKa\" width=\"600\"/><figcaption>The visualization displayed in the image is not correct acc. to theoretical knowledge, but I have displayed in an understandable manner</figcaption></figure><p>Here there is a comparison between a naive approach vs a DP approach. You can see the difference by the time complexity of both.</p><h3 id=\"memoization-don-t-forget\">Memoization: Don\u2019t forget</h3><p><a href=\"http://jeffe.cs.illinois.edu/\" rel=\"noopener\">Jeff Erickson</a> describes in his notes, for Fibonacci numbers:</p><blockquote>The obvious reason for the recursive algorithm\u2019s lack of speed is that it computes the same Fibonacci numbers over and over and over.</blockquote><figure><img alt=\"y9J0-FSzmI3RgyCX1FOkgFOfoy0gnKZtTObP\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/y9J0-FSzmI3RgyCX1FOkgFOfoy0gnKZtTObP\" width=\"600\"/><figcaption>From Jeff Erickson\u2019s notes CC: <a href=\"http://jeffe.cs.illinois.edu/\" rel=\"noopener\" target=\"_blank\" title=\"\">http://jeffe.cs.illinois.edu/</a></figcaption></figure><p>We can speed up our recursive algorithm considerably just by writing down the results of our recursive calls. Then we can look them up again if we need them later.</p><p><strong>Memoization</strong> refers to the technique of caching and reusing previously computed results.</p><p>If you use memoization to solve the problem, you do it by maintaining a map of already solved subproblems (as we earlier talked about the <strong>mapping</strong> of key and value). You do it \u201c<strong>top-down</strong>\u201d in the sense that you solve the \u201ctop\u201d problem first (which typically recurses down to solve the sub-problems).</p><p><strong>Pseudocode for memoization</strong>:</p><figure><img alt=\"Zc2XojBYGYnFvIdKnjs-vh5uy-TETK5h2guX\" height=\"388\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/Zc2XojBYGYnFvIdKnjs-vh5uy-TETK5h2guX\" width=\"800\"/></figure><p>So using recursion, we perform this with extra overhead memory (i.e. here lookup) to store results. If there is a value stored in the lookup, we return it directly or we add it to lookup for that specific index.</p><p>Remember that there is a tradeoff of extra overhead with respect to the tabulation method.</p><p>However, if you want more visualizations for memoization, then I suggest looking into <a href=\"https://www.youtube.com/watch?v=Taa9JDeakyU\" rel=\"noopener\">this video</a>.</p><figure><img alt=\"pw42NcPn9a9mVCLeKSQI-y75vTGTcQifI8Pt\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/pw42NcPn9a9mVCLeKSQI-y75vTGTcQifI8Pt\" width=\"600\"/><figcaption>In a top-down manner.</figcaption></figure><h3 id=\"tabulation-filling-up-in-tabular-form\">Tabulation: Filling up in tabular form</h3><p>But once we see how the array (memoized solution) is filled, we can replace the recursion with a simple loop that intentionally fills the array in order, instead of relying on the complicated recursion to do it for us \u2018accidentally\u2019.</p><figure><img alt=\"N61EAtUcJ04sfTINdBEzulljU56WqnSGPelV\" height=\"155\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/N61EAtUcJ04sfTINdBEzulljU56WqnSGPelV\" width=\"323\"/><figcaption>From Jeff Erickson\u2019s notes CC: <a href=\"http://jeffe.cs.illinois.edu/\" rel=\"noopener\" target=\"_blank\" title=\"\">http://jeffe.cs.illinois.edu/</a></figcaption></figure><p>Tabulation does it in <strong>\u201cbottom-up\u201d </strong>fashion. It\u2019s more straight forward, it does compute all values. It requires less overhead as it does not have to maintain mapping and stores data in tabular form for each value. It may also compute unnecessary values. This can be used if all you want is to compute all values for your problem.</p><p><strong>Pseudocode for tabulation:</strong></p><figure><img alt=\"sluFNyPCslPYri9s1Jip7-xyYdvKJcOWlnhJ\" height=\"512\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/sluFNyPCslPYri9s1Jip7-xyYdvKJcOWlnhJ\" width=\"800\"/><figcaption>Pseudocode with Fibonacci tree</figcaption></figure><p>As you can see pseudocode (right side) in an image, it does iteration (i.e. loops over till the end of an array). It simply starts with fib(0),fib(1),fib(2),\u2026 So with the tabulation approach, we can eliminate the need for recursion and simply return the result with looping over elements.</p><h3 id=\"looking-back-in-history\">Looking back in history</h3><p>Richard bellman was the man behind this concept. He came up with this when he was working for RAND Corporation in the mid-1950s. The reason he chose this name \u201cdynamic programming\u201d was to hide the mathematics work he did for this research. He was afraid his bosses would oppose or dislike any kind of mathematical research.</p><p>Okay, so the word \u2018programming\u2019 is just a reference to clarify that this was an old-fashioned way of planning or scheduling, typically by filling in a table (in a dynamic manner rather than in a linear way) over the time rather than all at once.</p><h4 id=\"wrapping-up\">Wrapping up</h4><p>That\u2019s it. This is part 2 of the algorithm series I started last year. In my <a href=\"https://codeburst.io/algorithms-i-searching-and-sorting-algorithms-56497dbaef20\" rel=\"noopener\">previous post</a>, we discussed about what are searching and sorting algorithms. Apologies that I couldn\u2019t deliver this in a shorter time. But I am willing to make things faster in the coming months.</p><p>Hope you liked it and I\u2019ll be soon looking to add a third one in the series soon. Happy coding!</p><p><a href=\"https://www.hackerearth.com/practice/algorithms/dynamic-programming\" rel=\"noopener\"><strong>Introduction to Dynamic Programming 1 Tutorials &amp; Notes | Algorithms | HackerEarth</strong></a><br/><a href=\"https://www.hackerearth.com/practice/algorithms/dynamic-programming\" rel=\"noopener\"><em>The image above says a lot about Dynamic Programming. So, is repeating the things for which you already have the\u2026</em>www.hackerearth.com</a><a href=\"https://www.topcoder.com/community/competitive-programming/tutorials/dynamic-programming-from-novice-to-advanced/\" rel=\"noopener\"><strong>Community \u2014 Competitive Programming \u2014 Competitive Programming Tutorials \u2014 Dynamic Programming: From\u2026</strong></a><br/><a href=\"https://www.topcoder.com/community/competitive-programming/tutorials/dynamic-programming-from-novice-to-advanced/\" rel=\"noopener\"><em>Community \u2014 Competitive Programming \u2014 Competitive Programming Tutorials \u2014 Dynamic Programming: From Novice to Advanced</em>www.topcoder.com</a></p><p>Special props to Jeff Erickson and his notes for algorithm \u2014 <a href=\"http://jeffe.cs.illinois.edu/\" rel=\"noopener\">http://jeffe.cs.illinois.edu/</a></p><figure><img alt=\"3MSAzv4xVUKSIIQEkTfiAK2lq8mzGKmmOBzB\" height=\"400\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/3MSAzv4xVUKSIIQEkTfiAK2lq8mzGKmmOBzB\" width=\"600\"/></figure>\n</section>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nby Meet ZaveriSuppose you are doing some calculation using an appropriate series of input. There is some computation done at every instance to derive some result. You don\u2019t know that you had encountered the same output when you had supplied the same input. So it\u2019s like you are doing re-computation of a result that was previously achieved by specific input for its respective output.But what\u2019s the problem here? Thing is that your precious time is wasted. You can easily solve the problem here by keeping records that map previously computed results. Such as using the appropriate data structure. For example, you could store input as key and output as a value (part of mapping).Those who cannot remember the past are condemned to repeat it. ~Dynamic ProgrammingNow by analyzing the problem, store its input if it\u2019s new (or not in the data structure) with its respective output. Else check that input key and get the resultant output from its value. That way when you do some computation and check if that input existed in that data structure, you can directly get the result. Thus we can relate this approach to dynamic programming techniques.Diving into dynamic programmingIn a nutshell, we can say that dynamic programming is used primarily for optimizing problems, where we wish to find the \u201cbest\u201d way of doing something.A certain scenario is like there are re-occurring subproblems which in turn have their own smaller subproblems. Instead of trying to solve those re-appearing subproblems, again and again, dynamic programming suggests solving each of the smaller subproblems only once. Then you record the results in a table from which a solution to the original problem can be obtained.For instance, the Fibonacci numbers 0,1,1,2,3,5,8,13,\u2026 have a simple description where each term is related to the two terms before it. If F(n) is the nth term of this series then we have F(n) = F(n-1) + F(n-2). This is called a recursive formula or a recurrence relation. It needs earlier terms to have been computed in order to compute a later term.The majority of Dynamic Programming problems can be categorized into two types:Optimization problems.Combinatorial problems.The optimization problems expect you to select a feasible solution so that the value of the required function is minimized or maximized. Combinatorial problems expect you to figure out the number of ways to do something or the probability of some event happening.An approach to solve: top-down vs bottom-upThere are the following two main different ways to solve the problem:Top-down: You start from the top, solving the problem by breaking it down. If you see that the problem has been solved already, then just return the saved answer. This is referred to as Memoization.Bottom-up: You directly start solving the smaller subproblems making your way to the top to derive the final solution of that one big problem. In this process, it is guaranteed that the subproblems are solved before solving the problem. This can be called Tabulation (table-filling algorithm).In reference to iteration vs recursion, bottom-up uses iteration and the top-down uses recursion.The visualization displayed in the image is not correct acc. to theoretical knowledge, but I have displayed in an understandable mannerHere there is a comparison between a naive approach vs a DP approach. You can see the difference by the time complexity of both.Memoization: Don\u2019t forgetJeff Erickson describes in his notes, for Fibonacci numbers:The obvious reason for the recursive algorithm\u2019s lack of speed is that it computes the same Fibonacci numbers over and over and over.From Jeff Erickson\u2019s notes CC: http://jeffe.cs.illinois.edu/We can speed up our recursive algorithm considerably just by writing down the results of our recursive calls. Then we can look them up again if we need them later.Memoization refers to the technique of caching and reusing previously computed results.If you use memoization to solve the problem, you do it by maintaining a map of already solved subproblems (as we earlier talked about the mapping of key and value). You do it \u201ctop-down\u201d in the sense that you solve the \u201ctop\u201d problem first (which typically recurses down to solve the sub-problems).Pseudocode for memoization:So using recursion, we perform this with extra overhead memory (i.e. here lookup) to store results. If there is a value stored in the lookup, we return it directly or we add it to lookup for that specific index.Remember that there is a tradeoff of extra overhead with respect to the tabulation method.However, if you want more visualizations for memoization, then I suggest looking into this video.In a top-down manner.Tabulation: Filling up in tabular formBut once we see how the array (memoized solution) is filled, we can replace the recursion with a simple loop that intentionally fills the array in order, instead of relying on the complicated recursion to do it for us \u2018accidentally\u2019.From Jeff Erickson\u2019s notes CC: http://jeffe.cs.illinois.edu/Tabulation does it in \u201cbottom-up\u201d fashion. It\u2019s more straight forward, it does compute all values. It requires less overhead as it does not have to maintain mapping and stores data in tabular form for each value. It may also compute unnecessary values. This can be used if all you want is to compute all values for your problem.Pseudocode for tabulation:Pseudocode with Fibonacci treeAs you can see pseudocode (right side) in an image, it does iteration (i.e. loops over till the end of an array). It simply starts with fib(0),fib(1),fib(2),\u2026 So with the tabulation approach, we can eliminate the need for recursion and simply return the result with looping over elements.Looking back in historyRichard bellman was the man behind this concept. He came up with this when he was working for RAND Corporation in the mid-1950s. The reason he chose this name \u201cdynamic programming\u201d was to hide the mathematics work he did for this research. He was afraid his bosses would oppose or dislike any kind of mathematical research.Okay, so the word \u2018programming\u2019 is just a reference to clarify that this was an old-fashioned way of planning or scheduling, typically by filling in a table (in a dynamic manner rather than in a linear way) over the time rather than all at once.Wrapping upThat\u2019s it. This is part 2 of the algorithm series I started last year. In my previous post, we discussed about what are searching and sorting algorithms. Apologies that I couldn\u2019t deliver this in a shorter time. But I am willing to make things faster in the coming months.Hope you liked it and I\u2019ll be soon looking to add a third one in the series soon. Happy coding!Resources:Introduction to Dynamic Programming 1 Tutorials & Notes | Algorithms | HackerEarthThe image above says a lot about Dynamic Programming. So, is repeating the things for which you already have the\u2026www.hackerearth.comCommunity \u2014 Competitive Programming \u2014 Competitive Programming Tutorials \u2014 Dynamic Programming: From\u2026Community \u2014 Competitive Programming \u2014 Competitive Programming Tutorials \u2014 Dynamic Programming: From Novice to Advancedwww.topcoder.comhttps://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/Special props to Jeff Erickson and his notes for algorithm \u2014 http://jeffe.cs.illinois.edu/\n\n                        \n                    \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 7894, "excerpt": "by Meet Zaveri\n\nAn intro to Algorithms (Part II): Dynamic Programming\nPhoto by Helloquence\n[https://unsplash.com/photos/5fNmWej4tAA?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText] \non Unsplash\n[https://unsplash.com/search/photos/math?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText]\nSuppose you are doing some calculation using an appropriate series of input.\nThere is some computation done at every instance to derive some result. You\ndon\u2019t know that you had e", "siteName": "freeCodeCamp.org", "publishedTime": "2019-04-30T15:33:33.000Z", "id": "632f58d61291be805bc4311737583baf2db0ef56", "url": "https://www.freecodecamp.org/news/an-intro-to-algorithms-dynamic-programming-dd00873362bb/", "domain": "freecodecamp.org", "date": "2023-12-27T18:11:05.848108", "resultUri": "http://localhost:3000/result/632f58d61291be805bc4311737583baf2db0ef56", "query": {"url": ["https://www.freecodecamp.org/news/an-intro-to-algorithms-dynamic-programming-dd00873362bb/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "An intro to Algorithms: Dynamic Programming", "description": "by Meet Zaveri An intro to Algorithms (Part II): Dynamic Programming Photo by Helloquence [https://unsplash.com/photos/5fNmWej4tAA?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText]  on Unsplash [https://unsplash.com/search/photos/math?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText] Suppose you are doing some calculation using an appropriate series of input. There is some computation done at every instance to derive some result. You don\u2019t know that you had e", "url": "https://www.freecodecamp.org/news/an-intro-to-algorithms-dynamic-programming-dd00873362bb/", "image": "https://cdn-media-1.freecodecamp.org/images/1*aExd095nIEBdoJ_ANTVCbw.png", "image:width": "800", "image:height": "436"}, "twitter": {"card": "summary_large_image", "title": "An intro to Algorithms: Dynamic Programming", "description": "by Meet Zaveri An intro to Algorithms (Part II): Dynamic Programming Photo by Helloquence [https://unsplash.com/photos/5fNmWej4tAA?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText]  on Unsplash [https://unsplash.com/search/photos/math?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText] Suppose you are doing some calculation using an appropriate series of input. There is some computation done at every instance to derive some result. You don\u2019t know that you had e", "url": "https://www.freecodecamp.org/news/an-intro-to-algorithms-dynamic-programming-dd00873362bb/", "image": "https://cdn-media-1.freecodecamp.org/images/1*aExd095nIEBdoJ_ANTVCbw.png", "label1": "Written by", "data1": "freeCodeCamp.org", "label2": "Filed under", "data2": "Programming, Algorithms, Dynamic Programming, Coding, Tech", "site": "@freecodecamp"}}}