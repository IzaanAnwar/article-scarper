{"title": "The story of one mother & two sons: value type vs reference type in Swift", "byline": "Boudhayan Biswas", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>The story of one mother &amp; two sons: value type vs reference type in Swift</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>Swift is a mother?and it has two sons ?-</p><ul><li>Value Type ??\u200d\u2640\ufe0f</li><li>Reference Type ?\u200d\u2642\ufe0f</li></ul><p>But what are their characteristics??\u200d\u2642\ufe0f</p><p>Do they behave the same or opposite to each other? ?\u200d\u2642\ufe0f</p><p>Swift is a multi-paradigm programming language developed by Apple for iOS, macOS, watchOS, tvOS, Linux, and z/OS.?</p><p>Just like other object-oriented programming languages, Swift has classes as building blocks which can define methods, properties, initializers, and can conform to protocols, support inheritance &amp; polymorphism.?</p><p>But, wait wait wait\u2026???</p><p>Swift has structs also and it can define methods, properties, initializers and can conform to protocols with only one exception of inheritance.?</p><p>What? Now I am confused!!! ???</p><p>Now let\u2019s spice up your confusion: structs are not only the value types in Swift. Tuples and enums are also value types. Classes are also not the only one used as a reference type. Functions and closures are also reference types. But as a token of relief, we at least know the primary focus &amp; specialization of usage of these types.?</p><p>So up to this point, we are left with only one big confusion with the usage of structs and classes.?</p><p>So, let\u2019s go and clear the confusions going around.?\u200d\u2642\ufe0f</p><h3 id=\"storage-locations\">Storage Locations</h3><p>There are three types of storage available:</p><ul><li>Register ?</li><li>Stack \u2604\ufe0f</li><li>Heap ?</li></ul><p>The objects that have a shorter lifespan are stored inside registers or the stack and those that have a longer lifespan are stored inside the heap.?</p><p>A value type stores its contents in memory allocated in the stack, so we can say value types are allocated in the stack in Swift. ?</p><p>But there is a common misconception about value types, have you heard it??\u200d\u2642\ufe0f</p><p>The misconception is that most people think value types are always stored in the Stack.</p><p>\u274c\u274c Wait a minute\u200a\u2014\u200athis is not the case always. \u274c\u274c</p><p>Value types can be stored inside the stack when they are either temporary or local variables. But what if a value type is contained inside a reference type?</p><p>In this situation, it can be stored inside the heap memory. ?</p><p>Wow\u2026that\u2019s cool!!!?</p><p>So the value types can be stored inside the register, stack or heap depending on their lifespan, whether they are short lived or long lived. If it is a local variable it can live inside the stack and if it is a part of class then it can live inside heap memory also.\u2705</p><p>On the other hand, reference type stores its contents in memory allocated in the heap memory and the variable holds only a reference to that memory location where actual data has been stored. ??</p><p>How does it work for reference type??</p><p>So for reference type, it is quite a common situation when there can be several variables holding the reference to the same memory location.\u2694\ufe0f</p><p>When a value type instance is assigned to a variable or passed to a function, the instance is copied and assigned to that variable. But with the reference type, only the reference gets copied and the new variable holds the same reference to the same memory location. ?</p><h3 id=\"differences-in-terms-of-mutability\">Differences in terms of Mutability</h3><p>There can be two states for a variable:</p><ul><li>?\u200d\u2640 \ufe0fMutable ?\u200d\u2640</li><li>?\ufe0f\u200d\u2642\ufe0f Immutable ?\ufe0f\u200d\u2642\ufe0f</li></ul><p>If a value type instance is assigned to an immutable variable, then the instance also becomes immutable. As a result, we can not make any changes to that instance.?\u200d\u2642\ufe0f</p><p>If a value type instance is assigned to a mutable variable, then only it makes the instance mutable. ?\u200d\u2642\ufe0f</p><p>But things are totally different for reference types. The variable and the instance it is assigned to are totally different. If we declare an immutable variable holding a reference to a class, this means that the reference it is holding will never change. We can not the change the reference and it will always point to the same reference. ?</p><h3 id=\"structural-types\">Structural Types</h3><p>Values of structural types are compared for equality in terms of their attributes or elements. We can say a value type is equal to another if and only if all of the corresponding attributes are equal. ???</p><p>Umm\u2026too many strong words\u2026what do you mean???</p><p>Let\u2019s say, we have a <strong><strong><em>Person</em></strong></strong> value type which has attributes like <strong><strong><em>firstName</em></strong></strong> and <strong><strong><em>lastName.</em></strong></strong></p><pre><code>struct Person {\n   var firstName: String\n   var lastName: String\n}\n\nvar person1 = Person(firstName: \"foo\", lastName: \"bar\")\n\nvar person2 = Person(firstName: \"foo\", lastName: \"bar\")</code></pre><p>Here both <strong><strong><em>person1</em></strong></strong> &amp; <strong><strong><em>person2</em></strong></strong><em> </em>instances are holding the same value for <strong><strong><em>firstName</em> (\u201cfoo\u201d)</strong></strong> and <strong><strong><em>lastName (\u201cbar\u201d)</em></strong></strong><em>. </em>So as per our understanding, we can say that the two instances are equal to each other since their attributes (<strong><strong><em>firstName</em></strong></strong> &amp; <strong><strong><em>lastName</em></strong></strong>) are holding the same values.</p><p>But it\u2019s not only limited to this: in the future, any two person instances holding the same values for <strong><strong><em>firstName</em></strong></strong> &amp; <strong><strong><em>lastName</em></strong></strong> will be equal to each other.</p><p>So as per our understanding till this point, we can say that:</p><blockquote><em><strong><strong><em>Value Types do not have identity, so there can be no reference to them. Value types are faceless.?</em></strong></strong></em></blockquote><p>What? How can you say that????</p><pre><code>var myAge: Int = 21\nvar friendAge: Int = 21</code></pre><p>Both <strong><strong><em>myAge</em></strong></strong> &amp; <strong><strong><em>friendAge</em></strong></strong><em> </em>are integer type variable with value 21.</p><p><strong><strong><em>Can we distinguish one from the other? ?</em></strong></strong></p><p>No, because they are holding the same value.?</p><p>An integer variable with value 21 cannot be different from another integer variable which is also having the value 21. As simple as that.???</p><p>Not having an identity gives value types another advantage: if you think practically, then you can imagine if you do not have an identity then anyone with same characteristics can replace or substitute you. ???</p><p>The same we can think for us as humans also. If I don\u2019t have an identity then anyone with same characteristics can replace me???. It\u2019s good for us that we have an identity otherwise it would be a great risk to our existence.?</p><p>But for value types, they don\u2019t have an identity and it is an advantage to them. ?</p><h3 id=\"what-are-the-benefits-of-using-value-types\">What are the benefits of using Value Types?</h3><h4 id=\"no-race-conditions-and-deadlocks-\">? No Race Conditions and Deadlocks: ?</h4><p>For values types in a multi-threaded environment, it is impossible for one thread to mutate the state of the instance while it is being used by another thread. So we can say that there will be no race conditions or deadlocks.</p><h4 id=\"-no-retain-cycles-\">\u2694\ufe0f <strong>No Retain Cycles: \u2694\ufe0f</strong></h4><p>When there are two reference type instances that are holding strong references to each other and preventing each other from being deallocated from memory, it is called a retain cycle. Since value types don\u2019t work as a reference, so we can say there will be no retain cycles for value types.</p><h4 id=\"-automatic-reference-counting-\">?\u200d?\u200d?\u200d? Automatic Reference Counting: ?\u200d?\u200d?\u200d?</h4><p>For reference type, Swift uses automatic reference counting to keep track of all the live or active objects and deallocates the instance only when there are no more strong references to it. If we think a little bit, then we can say that it is kind of a heavy operation because Swift runtime needs to keep track of the objects always. But since value types are allocated in the stack, it does not need ARC. So it is cheaper and faster??.</p><p>But wait...How does it manage memory for Array, Dictionary and String??</p><p>Since we can not know what will be the actual size of an array, a dictionary, and a string at compile time, there is no scope for them to be allocated at compile time. Though they are value types internally, they can not be allocated in stack. They need to be allocated in heap memory, and to manage this, Swift comes up with <strong><strong><em>copy on write</em></strong></strong>.?</p><p>But what is this??</p><p>When we say one instance is a copy of another instance, this really means they are the same, that they contain the same values. But in Swift, for these above types (Array, Dictionary, String, etc), an actual copy has been made on heap only when an instance is mutated. This is called a performance optimization technique for value types.???</p><h3 id=\"conclusion\">Conclusion</h3><p>There is no hard rule which defines when to use value type and when to use reference type. Value types have some unique advantages over reference types and vice versa. They both are unique in their own way. It really depends on your requirements and what you are trying to achieve. You should know the semantics of your code because you only know your code best, so it\u2019s up to you to choose. You have the full freedom.</p><p>So rather than fighting over value type vs reference type, use them intelligently.</p><p><strong><strong><em>??? Cheers!!! Thank you for reading!! </em></strong></strong><em>???</em></p><p><strong><strong><em>\u2705\u2705\u2705You can find me on </em></strong></strong><a href=\"https://twitter.com/_boudhayan_\" rel=\"noopener\"><strong><strong><em>Twitter</em></strong></strong></a><strong><strong><em>.\u2705\u2705\u2705</em></strong></strong></p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nSwift is a mother?and it has two sons ?-Value Type ??\u200d\u2640\ufe0fReference Type ?\u200d\u2642\ufe0fBut what are their characteristics??\u200d\u2642\ufe0fDo they behave the same or opposite to each other? ?\u200d\u2642\ufe0fSwift is a multi-paradigm programming language developed by Apple for iOS, macOS, watchOS, tvOS, Linux, and z/OS.?Just like other object-oriented programming languages, Swift has classes as building blocks which can define methods, properties, initializers, and can conform to protocols, support inheritance & polymorphism.?But, wait wait wait\u2026???Swift has structs also and it can define methods, properties, initializers and can conform to protocols with only one exception of inheritance.?What? Now I am confused!!! ???Now let\u2019s spice up your confusion: structs are not only the value types in Swift. Tuples and enums are also value types. Classes are also not the only one used as a reference type. Functions and closures are also reference types. But as a token of relief, we at least know the primary focus & specialization of usage of these types.?So up to this point, we are left with only one big confusion with the usage of structs and classes.?So, let\u2019s go and clear the confusions going around.?\u200d\u2642\ufe0fStorage LocationsThere are three types of storage available:Register ?Stack \u2604\ufe0fHeap ?The objects that have a shorter lifespan are stored inside registers or the stack and those that have a longer lifespan are stored inside the heap.?A value type stores its contents in memory allocated in the stack, so we can say value types are allocated in the stack in Swift. ?But there is a common misconception about value types, have you heard it??\u200d\u2642\ufe0fThe misconception is that most people think value types are always stored in the Stack.\u274c\u274c Wait a minute\u200a\u2014\u200athis is not the case always. \u274c\u274cValue types can be stored inside the stack when they are either temporary or local variables. But what if a value type is contained inside a reference type?In this situation, it can be stored inside the heap memory. ?Wow\u2026that\u2019s cool!!!?So the value types can be stored inside the register, stack or heap depending on their lifespan, whether they are short lived or long lived. If it is a local variable it can live inside the stack and if it is a part of class then it can live inside heap memory also.\u2705On the other hand, reference type stores its contents in memory allocated in the heap memory and the variable holds only a reference to that memory location where actual data has been stored. ??How does it work for reference type??So for reference type, it is quite a common situation when there can be several variables holding the reference to the same memory location.\u2694\ufe0fWhen a value type instance is assigned to a variable or passed to a function, the instance is copied and assigned to that variable. But with the reference type, only the reference gets copied and the new variable holds the same reference to the same memory location. ?Differences in terms of MutabilityThere can be two states for a variable:?\u200d\u2640 \ufe0fMutable ?\u200d\u2640?\ufe0f\u200d\u2642\ufe0f Immutable ?\ufe0f\u200d\u2642\ufe0fIf a value type instance is assigned to an immutable variable, then the instance also becomes immutable. As a result, we can not make any changes to that instance.?\u200d\u2642\ufe0fIf a value type instance is assigned to a mutable variable, then only it makes the instance mutable. ?\u200d\u2642\ufe0fBut things are totally different for reference types. The variable and the instance it is assigned to are totally different. If we declare an immutable variable holding a reference to a class, this means that the reference it is holding will never change. We can not the change the reference and it will always point to the same reference. ?Structural TypesValues of structural types are compared for equality in terms of their attributes or elements. We can say a value type is equal to another if and only if all of the corresponding attributes are equal. ???Umm\u2026too many strong words\u2026what do you mean???Let\u2019s say, we have a Person value type which has attributes like firstName and lastName.struct Person {\n   var firstName: String\n   var lastName: String\n}\n\nvar person1 = Person(firstName: \"foo\", lastName: \"bar\")\n\nvar person2 = Person(firstName: \"foo\", lastName: \"bar\")Here both person1 & person2 instances are holding the same value for firstName (\u201cfoo\u201d) and lastName (\u201cbar\u201d). So as per our understanding, we can say that the two instances are equal to each other since their attributes (firstName & lastName) are holding the same values.But it\u2019s not only limited to this: in the future, any two person instances holding the same values for firstName & lastName will be equal to each other.So as per our understanding till this point, we can say that:Value Types do not have identity, so there can be no reference to them. Value types are faceless.?What? How can you say that????var myAge: Int = 21\nvar friendAge: Int = 21Both myAge & friendAge are integer type variable with value 21.Can we distinguish one from the other? ?No, because they are holding the same value.?An integer variable with value 21 cannot be different from another integer variable which is also having the value 21. As simple as that.???Not having an identity gives value types another advantage: if you think practically, then you can imagine if you do not have an identity then anyone with same characteristics can replace or substitute you. ???The same we can think for us as humans also. If I don\u2019t have an identity then anyone with same characteristics can replace me???. It\u2019s good for us that we have an identity otherwise it would be a great risk to our existence.?But for value types, they don\u2019t have an identity and it is an advantage to them. ?What are the benefits of using Value Types?? No Race Conditions and Deadlocks: ?For values types in a multi-threaded environment, it is impossible for one thread to mutate the state of the instance while it is being used by another thread. So we can say that there will be no race conditions or deadlocks.\u2694\ufe0f No Retain Cycles: \u2694\ufe0fWhen there are two reference type instances that are holding strong references to each other and preventing each other from being deallocated from memory, it is called a retain cycle. Since value types don\u2019t work as a reference, so we can say there will be no retain cycles for value types.?\u200d?\u200d?\u200d? Automatic Reference Counting: ?\u200d?\u200d?\u200d?For reference type, Swift uses automatic reference counting to keep track of all the live or active objects and deallocates the instance only when there are no more strong references to it. If we think a little bit, then we can say that it is kind of a heavy operation because Swift runtime needs to keep track of the objects always. But since value types are allocated in the stack, it does not need ARC. So it is cheaper and faster??.But wait...How does it manage memory for Array, Dictionary and String??Since we can not know what will be the actual size of an array, a dictionary, and a string at compile time, there is no scope for them to be allocated at compile time. Though they are value types internally, they can not be allocated in stack. They need to be allocated in heap memory, and to manage this, Swift comes up with copy on write.?But what is this??When we say one instance is a copy of another instance, this really means they are the same, that they contain the same values. But in Swift, for these above types (Array, Dictionary, String, etc), an actual copy has been made on heap only when an instance is mutated. This is called a performance optimization technique for value types.???ConclusionThere is no hard rule which defines when to use value type and when to use reference type. Value types have some unique advantages over reference types and vice versa. They both are unique in their own way. It really depends on your requirements and what you are trying to achieve. You should know the semantics of your code because you only know your code best, so it\u2019s up to you to choose. You have the full freedom.So rather than fighting over value type vs reference type, use them intelligently.??? Cheers!!! Thank you for reading!! ???\u2705\u2705\u2705You can find me on Twitter.\u2705\u2705\u2705\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 8755, "excerpt": "Swift is a mother?and it has two sons ?-\n\n * Value Type ??\u200d\u2640\ufe0f\n * Reference Type ?\u200d\u2642\ufe0f\n\nBut what are their characteristics??\u200d\u2642\ufe0f\n\nDo they behave the same or opposite to each other? ?\u200d\u2642\ufe0f\n\nSwift is a multi-paradigm programming language developed by Apple for iOS,\nmacOS, watchOS, tvOS, Linux, and z/OS.?\n\nJust like other object-oriented programming languages, Swift has classes as\nbuilding blocks which can define methods, properties, initializers, and can\nconform to protocols, support inheritance & poly", "siteName": "freeCodeCamp.org", "publishedTime": "2019-05-21T16:47:32.000Z", "id": "bd80cc5d305d3b7419ae6f29f3dddea7196efada", "url": "https://www.freecodecamp.org/news/the-story-of-one-mother-two-sons-value-type-vs-reference-type-in-swift-6e125af2d5d0/", "domain": "freecodecamp.org", "date": "2023-12-27T18:09:26.875545", "resultUri": "http://localhost:3000/result/bd80cc5d305d3b7419ae6f29f3dddea7196efada", "query": {"url": ["https://www.freecodecamp.org/news/the-story-of-one-mother-two-sons-value-type-vs-reference-type-in-swift-6e125af2d5d0/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "The story of one mother & two sons: value type vs reference type in Swift", "description": "Swift is a mother?and it has two sons ?-  * Value Type ??\u200d\u2640\ufe0f  * Reference Type ?\u200d\u2642\ufe0f But what are their characteristics??\u200d\u2642\ufe0f Do they behave the same or opposite to each other? ?\u200d\u2642\ufe0f Swift is a multi-paradigm programming language developed by Apple for iOS, macOS, watchOS, tvOS, Linux,", "url": "https://www.freecodecamp.org/news/the-story-of-one-mother-two-sons-value-type-vs-reference-type-in-swift-6e125af2d5d0/", "image": "https://cdn-media-1.freecodecamp.org/images/1*Ri49w8TcHeXrnmO5dD4_aQ.jpeg", "image:width": "800", "image:height": "459"}, "twitter": {"card": "summary_large_image", "title": "The story of one mother & two sons: value type vs reference type in Swift", "description": "Swift is a mother?and it has two sons ?-  * Value Type ??\u200d\u2640\ufe0f  * Reference Type ?\u200d\u2642\ufe0f But what are their characteristics??\u200d\u2642\ufe0f Do they behave the same or opposite to each other? ?\u200d\u2642\ufe0f Swift is a multi-paradigm programming language developed by Apple for iOS, macOS, watchOS, tvOS, Linux,", "url": "https://www.freecodecamp.org/news/the-story-of-one-mother-two-sons-value-type-vs-reference-type-in-swift-6e125af2d5d0/", "image": "https://cdn-media-1.freecodecamp.org/images/1*Ri49w8TcHeXrnmO5dD4_aQ.jpeg", "label1": "Written by", "data1": "Boudhayan Biswas", "label2": "Filed under", "data2": "Swift, iOS, Programming, Technology, Mobile", "site": "@freecodecamp", "creator": "@_boudhayan_"}}}