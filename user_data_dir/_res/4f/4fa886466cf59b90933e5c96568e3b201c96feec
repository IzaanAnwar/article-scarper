{"title": "A quick but complete guide to IndexedDB and storing data in browsers", "byline": "Flavio Copes", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>A quick but complete guide to IndexedDB and storing data in browsers</h1>\n<section>\n<section data-test-label=\"post-content\">\n<blockquote>Interested in learning JavaScript? Get my JavaScript ebook at <a href=\"https://jshandbook.com/\" rel=\"noopener\">jshandbook.com</a></blockquote><!--kg-card-begin: markdown--><h2 id=\"introductiontoindexeddb\">Introduction to IndexedDB</h2>\n<p>IndexedDB is one of the storage capabilities introduced into browsers over the years.<br/>\nIt's a key/value store (a noSQL database) considered to be <strong>the definitive solution for storing data in browsers</strong>.</p>\n<p>It's an asynchronous API, which means that performing costly operations won't block the UI thread providing a sloppy experience to users. It can store an indefinite amount of data, although once over a certain threshold the user is prompted to give the site higher limits.</p>\n<p>It's <a href=\"http://caniuse.com/#feat=indexeddb\">supported on all modern browsers</a>.</p>\n<p>It supports transactions, versioning and gives good performance.</p>\n<p>Inside the browser we can also use:</p>\n<ul>\n<li><a href=\"https://flaviocopes.com/cookies/\"><strong>Cookies</strong></a>: can host a very small amount of strings</li>\n<li><a href=\"https://flaviocopes.com/web-storage-api/\"><strong>Web Storage</strong></a> (or DOM Storage), a term that commonly identifies localStorage and  sessionStorage, two key/value stores. sessionStorage, does not retain data, which is cleared when the session ends, while localStorage keeps the data across sessions</li>\n</ul>\n<p>Local/session storage have the disadvantage of being capped at a small (and inconsistent) size, with browsers implementation offering from 2MB to 10MB of space per site.</p>\n<p>In the past we also had <strong>Web SQL</strong>, a wrapper around SQLite, but now this is <strong>deprecated</strong> and unsupported on some modern browsers, it's never been a recognized standard and so it should not be used, although 83% of users have this technology on their devices <a href=\"http://caniuse.com/#feat=sql-storage\">according to Can I Use</a>.</p>\n<p>While you can technically create multiple databases per site, you generally <strong>create one single database</strong>, and inside that database you can create <strong>multiple object stores</strong>.</p>\n<p>A database is <strong>private to a domain</strong>, so any other site cannot access another website IndexedDB stores.</p>\n<p>Each store usually contains a set of <em>things</em>, which can be</p>\n<ul>\n<li>strings</li>\n<li>numbers</li>\n<li>objects</li>\n<li>arrays</li>\n<li>dates</li>\n</ul>\n<blockquote>\n<p>For example you might have a store that contains posts, another that contains comments.</p>\n</blockquote>\n<p>A store contains a number of items which have a unique key, which represents the way by which an object can be identified.</p>\n<p>You can alter those stores using transactions, by performing add, edit and delete operations, and iterating over the items they contain.</p>\n<p>Since the advent of <a href=\"https://flaviocopes.com/javascript-promises\">Promises</a> in ES6, and the subsequent move of APIs to using promises, the IndexedDB API seems a bit <em>old school</em>.</p>\n<p>While there's nothing wrong in it, in all the examples that I'll explain I'll use the <a href=\"https://github.com/jakearchibald/idb\">IndexedDB Promised Library</a> by Jake Archibald, which is a tiny layer on top of the IndexedDB API to make it easier to use.</p>\n<blockquote>\n<p>This library is also used on all the examples on the Google Developers website regarding IndexedDB</p>\n</blockquote>\n<h2 id=\"createanindexeddbdatabase\">Create an IndexedDB Database</h2>\n<p>The simplest way is to use <em>unpkg</em>, by adding this to the page header:</p>\n<pre tabindex=\"0\"><code>&lt;script type=\"module\"&gt;\nimport { openDB, deleteDB } from 'https://unpkg.com/idb?module'\n&lt;/script&gt;\n</code></pre>\n<p>Before using the IndexedDB API, always make sure you check for support in the browser, even though it's widely available, you never know which browser the user is using:</p>\n<pre tabindex=\"0\"><code>(() =&gt; {\n  'use strict'\n\n  if (!('indexedDB' in window)) {\n    console.warn('IndexedDB not supported')\n    return\n  }\n\n  //...IndexedDB code\n})()\n</code></pre>\n<h3 id=\"howtocreateadatabase\">How to <strong>create a database</strong></h3>\n\n<pre tabindex=\"0\"><code>(async () =&gt; {\n  //...\n\n  const dbName = 'mydbname'\n  const storeName = 'store1'\n  const version = 1 //versions start at 1\n\n  const db = await openDB(dbName, version, {\n    upgrade(db, oldVersion, newVersion, transaction) {\n      const store = db.createObjectStore(storeName)\n    }\n  })\n})()\n</code></pre>\n<p>The first 2 parameters are the database name, and the verson. The third param, which is optional, is an object that contains a function <strong>called only if the version number is higher than the current installed database version</strong>. In the function body you can upgrade the structure (stores and indexes) of the db.</p>\n<h2 id=\"addingdataintoastore\">Adding data into a store</h2>\n<h3 id=\"addingdatawhenthestoreiscreatedinitializingit\">Adding data when the store is created, initializing it</h3>\n<p>You use the <code>put</code> method of the object store, but first we need a reference to it, which we can get from <code>db.createObjectStore()</code> when we create it.</p>\n<p>When using <code>put</code>, the value is the first argument, the key is the second. This is because if you specify <code>keyPath</code> when creating the object store, you don't need to enter the key name on every put() request, you can just write the value.</p>\n<p>This populates <code>store0</code> as soon as we create it:</p>\n<pre tabindex=\"0\"><code>(async () =&gt; {\n  //...\n  const dbName = 'mydbname'\n  const storeName = 'store0'\n  const version = 1\n\n  const db = await openDB(dbName, version,{\n    upgrade(db, oldVersion, newVersion, transaction) {\n      const store = db.createObjectStore(storeName)\n      store.put('Hello world!', 'Hello')\n    }\n  })\n})()\n</code></pre>\n<h3 id=\"addingdatawhenthestoreisalreadycreatedusingtransactions\">Adding data when the store is already created, using transactions</h3>\n<p>To add items later down the road, you need to create a read/write <strong>transaction</strong>, that ensures database integrity (if an operation fails, all the operations in the transaction are rolled back and the state goes back to a known state).</p>\n<p>For that, use a reference to the <code>dbPromise</code> object we got when calling <code>openDB</code>, and run:</p>\n<pre tabindex=\"0\"><code>(async () =&gt; {\n  //...\n  const dbName = 'mydbname'\n  const storeName = 'store0'\n  const version = 1\n\n  const db = await openDB(/* ... */)\n\n  const tx = db.transaction(storeName, 'readwrite')\n  const store = await tx.objectStore(storeName)\n\n  const val = 'hey!'\n  const key = 'Hello again'\n  const value = await store.put(val, key)\n  await tx.done\n})()\n</code></pre>\n<h2 id=\"gettingdatafromastore\">Getting data from a store</h2>\n<h3 id=\"gettingoneitemfromastoreget\">Getting one item from a store: <code>get()</code></h3>\n<pre tabindex=\"0\"><code>const key = 'Hello again'\nconst item = await db.transaction(storeName).objectStore(storeName).get(key)\n</code></pre>\n<h3 id=\"gettingalltheitemsfromastoregetall\">Getting all the items from a store: <code>getAll()</code></h3>\n<p>Get all the keys stored</p>\n<pre tabindex=\"0\"><code>const items = await db.transaction(storeName).objectStore(storeName).getAllKeys()\n</code></pre>\n<p>Get all the values stored</p>\n<pre tabindex=\"0\"><code>const items = await db.transaction(storeName).objectStore(storeName).getAll()\n</code></pre>\n<h2 id=\"deletingdatafromindexeddb\">Deleting data from IndexedDB</h2>\n<p>Deleting the database, an object store and data</p>\n<h3 id=\"deleteanentireindexeddbdatabase\">Delete an entire IndexedDB database</h3>\n<pre tabindex=\"0\"><code>const dbName = 'mydbname'\nawait deleteDB(dbName)\n</code></pre>\n<h3 id=\"todeletedatainanobjectstore\">To delete data in an object store</h3>\n<p>We use a transaction:</p>\n<pre tabindex=\"0\"><code>(async () =&gt; {\n  //...\n\n  const dbName = 'mydbname'\n  const storeName = 'store1'\n  const version = 1\n\n  const db = await openDB(dbName, version, {\n    upgrade(db, oldVersion, newVersion, transaction) {\n      const store = db.createObjectStore(storeName)\n    }\n  })\n\n  const tx = await db.transaction(storeName, 'readwrite')\n  const store = await tx.objectStore(storeName)\n\n  const key = 'Hello again'\n  await store.delete(key)\n  await tx.done\n})()\n</code></pre>\n<h2 id=\"migratefrompreviousversionofadatabase\">Migrate from previous version of a database</h2>\n<p>The third (optional) parameter of the <code>openDB()</code> function is an object that can contain an <code>upgrade</code> function <strong>called only if the version number is higher than the current installed database version</strong>. In that function body you can upgrade the structure (stores and indexes) of the db:</p>\n<pre tabindex=\"0\"><code>const name = 'mydbname'\nconst version = 1\nopenDB(name, version, {\n  upgrade(db, oldVersion, newVersion, transaction) {\n    console.log(oldVersion)\n  }\n})\n</code></pre>\n<p>In this callback, you can check from which version the user is updating, and perform some operations accordingly.</p>\n<p>You can perform a migration from a previous database version using this syntax</p>\n<pre tabindex=\"0\"><code>(async () =&gt; {\n  //...\n  const dbName = 'mydbname'\n  const storeName = 'store0'\n  const version = 1\n\n  const db = await openDB(dbName, version, {\n    upgrade(db, oldVersion, newVersion, transaction) {\n      switch (oldVersion) {\n        case 0: // no db created before\n          // a store introduced in version 1\n          db.createObjectStore('store1')\n        case 1:\n          // a new store in version 2\n          db.createObjectStore('store2', { keyPath: 'name' })\n      }\n      db.createObjectStore(storeName)\n    }\n  })\n})()\n</code></pre>\n<h2 id=\"uniquekeys\">Unique keys</h2>\n<p><code>createObjectStore()</code> as you can see in <code>case 1</code> accepts a second parameter that indicates the index key of the database. This is very useful when you store objects: <code>put()</code> calls don't need a second parameter, but can just take the value (an object) and the key will be mapped to the object property that has that name.</p>\n<p>The index gives you a way to retrieve a value later by that specific key, and it must be unique (every item must have a different key)</p>\n<p>A key can be set to auto increment, so you don't need to keep track of it on the client code:</p>\n<pre tabindex=\"0\"><code>db.createObjectStore('notes', { autoIncrement: true })\n</code></pre>\n<p>Use auto increment if your values do not contain a unique key already (for example, if you collect email addresses without an associated name).</p>\n<h3 id=\"checkifastoreexists\">Check if a store exists</h3>\n<p>You can check if an object store already exists by calling the <code>objectStoreNames()</code> method:</p>\n<pre tabindex=\"0\"><code>const storeName = 'store1'\n\nif (!db.objectStoreNames.contains(storeName)) {\n  db.createObjectStore(storeName)\n}\n</code></pre>\n<h2 id=\"deletingfromindexeddb\">Deleting from IndexedDB</h2>\n<p>Deleting the database, an object store and data</p>\n<h3 id=\"deleteadatabase\">Delete a database</h3>\n<pre tabindex=\"0\"><code>await deleteDB('mydb')\n</code></pre>\n<h3 id=\"deleteanobjectstore\">Delete an object store</h3>\n<p>An object store can only be deleted in the callback when opening a db, and that callback is only called if you specify a version higher than the one currently installed:</p>\n<pre tabindex=\"0\"><code>const db = await openDB('dogsdb', 2, {\n  upgrade(db, oldVersion, newVersion, transaction) {\n    switch (oldVersion) {\n      case 0: // no db created before\n        // a store introduced in version 1\n        db.createObjectStore('store1')\n      case 1:\n        // delete the old store in version 2, create a new one\n        db.deleteObjectStore('store1')\n        db.createObjectStore('store2')\n    }\n  }\n})\n</code></pre>\n<h3 id=\"todeletedatainanobjectstoreuseatransaction\">To delete data in an object store use a transaction</h3>\n<pre tabindex=\"0\"><code>const key = 232 //a random key\n\nconst db = await openDB(/*...*/)\nconst tx = await db.transaction('store', 'readwrite')\nconst store = await tx.objectStore('store')\nawait store.delete(key)\nawait tx.complete\n</code></pre>\n<h2 id=\"theresmore\">There's more!</h2>\n<p>These are just the basics. I didn't talk about cursors and more advanced stuff. There's more to IndexedDB but I hope this gives you a head start.</p>\n<!--kg-card-end: markdown--><blockquote>Interested in learning JavaScript? Get my JavaScript book at <a href=\"https://jshandbook.com/\" rel=\"noopener\">jshandbook.com</a></blockquote>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nInterested in learning JavaScript? Get my JavaScript ebook at jshandbook.comIntroduction to IndexedDB\nIndexedDB is one of the storage capabilities introduced into browsers over the years.\nIt's a key/value store (a noSQL database) considered to be the definitive solution for storing data in browsers.\nIt's an asynchronous API, which means that performing costly operations won't block the UI thread providing a sloppy experience to users. It can store an indefinite amount of data, although once over a certain threshold the user is prompted to give the site higher limits.\nIt's supported on all modern browsers.\nIt supports transactions, versioning and gives good performance.\nInside the browser we can also use:\n\nCookies: can host a very small amount of strings\nWeb Storage (or DOM Storage), a term that commonly identifies localStorage and  sessionStorage, two key/value stores. sessionStorage, does not retain data, which is cleared when the session ends, while localStorage keeps the data across sessions\n\nLocal/session storage have the disadvantage of being capped at a small (and inconsistent) size, with browsers implementation offering from 2MB to 10MB of space per site.\nIn the past we also had Web SQL, a wrapper around SQLite, but now this is deprecated and unsupported on some modern browsers, it's never been a recognized standard and so it should not be used, although 83% of users have this technology on their devices according to Can I Use.\nWhile you can technically create multiple databases per site, you generally create one single database, and inside that database you can create multiple object stores.\nA database is private to a domain, so any other site cannot access another website IndexedDB stores.\nEach store usually contains a set of things, which can be\n\nstrings\nnumbers\nobjects\narrays\ndates\n\n\nFor example you might have a store that contains posts, another that contains comments.\n\nA store contains a number of items which have a unique key, which represents the way by which an object can be identified.\nYou can alter those stores using transactions, by performing add, edit and delete operations, and iterating over the items they contain.\nSince the advent of Promises in ES6, and the subsequent move of APIs to using promises, the IndexedDB API seems a bit old school.\nWhile there's nothing wrong in it, in all the examples that I'll explain I'll use the IndexedDB Promised Library by Jake Archibald, which is a tiny layer on top of the IndexedDB API to make it easier to use.\n\nThis library is also used on all the examples on the Google Developers website regarding IndexedDB\n\nCreate an IndexedDB Database\nThe simplest way is to use unpkg, by adding this to the page header:\n<script type=\"module\">\nimport { openDB, deleteDB } from 'https://unpkg.com/idb?module'\n</script>\n\nBefore using the IndexedDB API, always make sure you check for support in the browser, even though it's widely available, you never know which browser the user is using:\n(() => {\n  'use strict'\n\n  if (!('indexedDB' in window)) {\n    console.warn('IndexedDB not supported')\n    return\n  }\n\n  //...IndexedDB code\n})()\n\nHow to create a database\nUsing openDB():\n(async () => {\n  //...\n\n  const dbName = 'mydbname'\n  const storeName = 'store1'\n  const version = 1 //versions start at 1\n\n  const db = await openDB(dbName, version, {\n    upgrade(db, oldVersion, newVersion, transaction) {\n      const store = db.createObjectStore(storeName)\n    }\n  })\n})()\n\nThe first 2 parameters are the database name, and the verson. The third param, which is optional, is an object that contains a function called only if the version number is higher than the current installed database version. In the function body you can upgrade the structure (stores and indexes) of the db.\nAdding data into a store\nAdding data when the store is created, initializing it\nYou use the put method of the object store, but first we need a reference to it, which we can get from db.createObjectStore() when we create it.\nWhen using put, the value is the first argument, the key is the second. This is because if you specify keyPath when creating the object store, you don't need to enter the key name on every put() request, you can just write the value.\nThis populates store0 as soon as we create it:\n(async () => {\n  //...\n  const dbName = 'mydbname'\n  const storeName = 'store0'\n  const version = 1\n\n  const db = await openDB(dbName, version,{\n    upgrade(db, oldVersion, newVersion, transaction) {\n      const store = db.createObjectStore(storeName)\n      store.put('Hello world!', 'Hello')\n    }\n  })\n})()\n\nAdding data when the store is already created, using transactions\nTo add items later down the road, you need to create a read/write transaction, that ensures database integrity (if an operation fails, all the operations in the transaction are rolled back and the state goes back to a known state).\nFor that, use a reference to the dbPromise object we got when calling openDB, and run:\n(async () => {\n  //...\n  const dbName = 'mydbname'\n  const storeName = 'store0'\n  const version = 1\n\n  const db = await openDB(/* ... */)\n\n  const tx = db.transaction(storeName, 'readwrite')\n  const store = await tx.objectStore(storeName)\n\n  const val = 'hey!'\n  const key = 'Hello again'\n  const value = await store.put(val, key)\n  await tx.done\n})()\n\nGetting data from a store\nGetting one item from a store: get()\nconst key = 'Hello again'\nconst item = await db.transaction(storeName).objectStore(storeName).get(key)\n\nGetting all the items from a store: getAll()\nGet all the keys stored\nconst items = await db.transaction(storeName).objectStore(storeName).getAllKeys()\n\nGet all the values stored\nconst items = await db.transaction(storeName).objectStore(storeName).getAll()\n\nDeleting data from IndexedDB\nDeleting the database, an object store and data\nDelete an entire IndexedDB database\nconst dbName = 'mydbname'\nawait deleteDB(dbName)\n\nTo delete data in an object store\nWe use a transaction:\n(async () => {\n  //...\n\n  const dbName = 'mydbname'\n  const storeName = 'store1'\n  const version = 1\n\n  const db = await openDB(dbName, version, {\n    upgrade(db, oldVersion, newVersion, transaction) {\n      const store = db.createObjectStore(storeName)\n    }\n  })\n\n  const tx = await db.transaction(storeName, 'readwrite')\n  const store = await tx.objectStore(storeName)\n\n  const key = 'Hello again'\n  await store.delete(key)\n  await tx.done\n})()\n\nMigrate from previous version of a database\nThe third (optional) parameter of the openDB() function is an object that can contain an upgrade function called only if the version number is higher than the current installed database version. In that function body you can upgrade the structure (stores and indexes) of the db:\nconst name = 'mydbname'\nconst version = 1\nopenDB(name, version, {\n  upgrade(db, oldVersion, newVersion, transaction) {\n    console.log(oldVersion)\n  }\n})\n\nIn this callback, you can check from which version the user is updating, and perform some operations accordingly.\nYou can perform a migration from a previous database version using this syntax\n(async () => {\n  //...\n  const dbName = 'mydbname'\n  const storeName = 'store0'\n  const version = 1\n\n  const db = await openDB(dbName, version, {\n    upgrade(db, oldVersion, newVersion, transaction) {\n      switch (oldVersion) {\n        case 0: // no db created before\n          // a store introduced in version 1\n          db.createObjectStore('store1')\n        case 1:\n          // a new store in version 2\n          db.createObjectStore('store2', { keyPath: 'name' })\n      }\n      db.createObjectStore(storeName)\n    }\n  })\n})()\n\nUnique keys\ncreateObjectStore() as you can see in case 1 accepts a second parameter that indicates the index key of the database. This is very useful when you store objects: put() calls don't need a second parameter, but can just take the value (an object) and the key will be mapped to the object property that has that name.\nThe index gives you a way to retrieve a value later by that specific key, and it must be unique (every item must have a different key)\nA key can be set to auto increment, so you don't need to keep track of it on the client code:\ndb.createObjectStore('notes', { autoIncrement: true })\n\nUse auto increment if your values do not contain a unique key already (for example, if you collect email addresses without an associated name).\nCheck if a store exists\nYou can check if an object store already exists by calling the objectStoreNames() method:\nconst storeName = 'store1'\n\nif (!db.objectStoreNames.contains(storeName)) {\n  db.createObjectStore(storeName)\n}\n\nDeleting from IndexedDB\nDeleting the database, an object store and data\nDelete a database\nawait deleteDB('mydb')\n\nDelete an object store\nAn object store can only be deleted in the callback when opening a db, and that callback is only called if you specify a version higher than the one currently installed:\nconst db = await openDB('dogsdb', 2, {\n  upgrade(db, oldVersion, newVersion, transaction) {\n    switch (oldVersion) {\n      case 0: // no db created before\n        // a store introduced in version 1\n        db.createObjectStore('store1')\n      case 1:\n        // delete the old store in version 2, create a new one\n        db.deleteObjectStore('store1')\n        db.createObjectStore('store2')\n    }\n  }\n})\n\nTo delete data in an object store use a transaction\nconst key = 232 //a random key\n\nconst db = await openDB(/*...*/)\nconst tx = await db.transaction('store', 'readwrite')\nconst store = await tx.objectStore('store')\nawait store.delete(key)\nawait tx.complete\n\nThere's more!\nThese are just the basics. I didn't talk about cursors and more advanced stuff. There's more to IndexedDB but I hope this gives you a head start.\nInterested in learning JavaScript? Get my JavaScript book at jshandbook.com\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 10498, "excerpt": "> Interested in learning JavaScript? Get my JavaScript ebook at jshandbook.com\n[https://jshandbook.com/]\nIntroduction to IndexedDB\nIndexedDB is one of the storage capabilities introduced into browsers over the\nyears.\nIt's a key/value store (a noSQL database) considered to be the definitive\nsolution for storing data in browsers.\n\nIt's an asynchronous API, which means that performing costly operations won't\nblock the UI thread providing a sloppy experience to users. It can store an\nindefinite amou", "siteName": "freeCodeCamp.org", "publishedTime": "2019-06-01T11:07:00.000Z", "id": "4fa886466cf59b90933e5c96568e3b201c96feec", "url": "https://www.freecodecamp.org/news/a-quick-but-complete-guide-to-indexeddb-25f030425501/", "domain": "freecodecamp.org", "date": "2023-12-27T18:09:14.372614", "resultUri": "http://localhost:3000/result/4fa886466cf59b90933e5c96568e3b201c96feec", "query": {"url": ["https://www.freecodecamp.org/news/a-quick-but-complete-guide-to-indexeddb-25f030425501/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "A quick but complete guide to IndexedDB and storing data in browsers", "description": "> Interested in learning JavaScript? Get my JavaScript ebook at jshandbook.com [https://jshandbook.com/] Introduction to IndexedDB IndexedDB is one of the storage capabilities introduced into browsers over the years. It's a key/value store (a noSQL database) considered to be the definitive solution for storing data in browsers. It's an asynchronous API,", "url": "https://www.freecodecamp.org/news/a-quick-but-complete-guide-to-indexeddb-25f030425501/", "image": "https://cdn-media-1.freecodecamp.org/images/1*p6r6gML9zfQ0MlNx7IWx_A.png", "image:width": "800", "image:height": "566"}, "twitter": {"card": "summary_large_image", "title": "A quick but complete guide to IndexedDB and storing data in browsers", "description": "> Interested in learning JavaScript? Get my JavaScript ebook at jshandbook.com [https://jshandbook.com/] Introduction to IndexedDB IndexedDB is one of the storage capabilities introduced into browsers over the years. It's a key/value store (a noSQL database) considered to be the definitive solution for storing data in browsers. It's an asynchronous API,", "url": "https://www.freecodecamp.org/news/a-quick-but-complete-guide-to-indexeddb-25f030425501/", "image": "https://cdn-media-1.freecodecamp.org/images/1*p6r6gML9zfQ0MlNx7IWx_A.png", "label1": "Written by", "data1": "Flavio Copes", "label2": "Filed under", "data2": "JavaScript, Tech, Programming, Coding, Technology", "site": "@freecodecamp"}}}