{"title": "How to convert from React-Redux classes to React Hooks, the easy way", "byline": "Mohammad Iqbal", "dir": null, "lang": "en", "content": "<article><h1>How to convert from React-Redux classes to React Hooks, the easy way</h1><div class=\"page\" id=\"readability-page-1\"><section data-test-label=\"post-content\">\n<p>Hello everyone! With the recent release of create-react-app v3 and React hooks, I decided to write a tutorial on how to refactor a class component to a functional hooks component.</p><p>In this tutorial, I will share how I did it. I refer to this as the \u201ceasy way\u201d since it doesn't require you to change your Redux code at all. The reducers and actions can be virtually left as is.</p><p>If you want a more basic intro to React Hooks integration check out my <a href=\"https://medium.freecodecamp.org/how-to-integrate-react-hooks-into-your-project-without-changing-your-redux-code-974e6f70f0b0\" rel=\"noopener\">previous tutorial</a>.</p><p>You can find the project code <a href=\"https://github.com/iqbal125/react_hooks_with_react_redux\" rel=\"noopener\">here</a>.</p><p>You can also follow me on twitter for more tutorials in the future: <a href=\"https://twitter.com/iqbal125sf\">here </a></p><p> This project uses both Redux and React hooks which will allow you to see the code and differences side by side. Open up the <code>hooks_container1.js</code> file and <code>container1.js</code> files in your text editor to see the differences. I tried my best to match the React class and React hook line for line making it easier to see the differences. However, it didn\u2019t work out perfectly since there are some major differences between React Hooks and React classes. I tried to keep the functionality of both components the same so it will be easier for you to pick out the differences in syntax.</p><h4 id=\"table-of-contents\"><strong>Table of Contents</strong></h4><ol><li>TLDR version</li><li>useReducer and Context</li><li>When to use local or global state and useState and useReducer</li><li>How Context Works</li><li>Directory Structure</li><li>The Context Object</li><li>Reducers and Actions</li><li>Reading and Updating state in React Redux vs. React Hooks</li><li>Merging the old state in React Hooks</li><li>Reading and Updating state with useReducer and Redux Reducers</li><li>Reading state and Dispatching Actions</li><li>Context with useState</li><li>Context with useReducer</li></ol><h3 id=\"the-easy-way-tl-dr\"><strong>The Easy Way \u2014 TL;DR</strong></h3><p><strong>Step 1: </strong>For your reducers, export both the initialState and the reducer. Do not <code>export default</code> the reducer.</p><p><strong>Step 2: </strong>Actions can be left as is from React-Redux</p><p><strong>Step 3:</strong> Import all your reducers and their initialState to the root App.js file. Import actions as normal.</p><p><strong>Step 4: </strong>Pass in each reducer and its initialState to a separate <code>useReducer() </code>hook in the App.js file.</p><p><strong>Step 5:</strong> Import the <code>React.createContext()</code> function to App.js after initializing it in its own file. Wrap all child components with <code>&lt;Context.Provider /&gt;</code></p><p><strong>Step 6:</strong> Next simply cut and paste the properties defined in your React-Redux <code>mapStateToProps()</code> and<code> mapDispatchToProps()</code> functions to the <code>value</code> prop of <code>&lt;Context.Provider /&gt;</code></p><p><strong>Step 7:</strong> Change the dispatch keyword in your properties from the <code>mapDispatchToProps()</code> function to the name of the dispatch actions function (2nd element in the array destructuring) in the <code>useReducer()</code> hook. Since each reducer will have its own useReducer hook, you will have to match the appropriate action dispatches with the right reducer.</p><p><strong>Step 8:</strong> Do the same thing for the <code>mapStateToProps()</code> function. Change the name of the property to match the useReducer hook. The state value for the <code>useReducer()</code> hook (1st element in the array destructuring) contains the entire initial state from the reducer. You will need to access each property of state with dot notation, and then pass it into a property in the \u201cvalue\u201d prop.</p><p><strong>Step 9:</strong> Finally to actually use the global Context state in a child component, you first import the original Context object to the child component. Then pass in the imported Context object to the <code>useContext()</code> hook. Save the result of the useContext hooks in a variable. Now you have access to all the properties that we defined in the <code>value</code> prop of the <code>&lt;Context.Provider /&gt;</code> in the root App.js file.</p><p>Accessing state values in a child component with context: <code>context.stateprop1</code></p><p>Dispatching actions in a child component with context: <code>() =&gt; context.action1()</code></p><p>Here is an example of a React Redux class container and a React Hooks functional component with similar functionality side by side.</p><pre tabindex=\"0\"><code> class Container1 extends Component {\n    constructor(props) {\n      super(props)\n\n      this.state = {\n        local_state_prop1: true,\n        local_state_prop2: 0,\n        cDM_value: ''\n      }\n    }\n\n ...\n \n    inc_local = () =&gt; {\n      this.setState({local_state_prop2: this.state.local_state_prop2 + 1})\n    }\n\n    dec_local = () =&gt; {\n      this.setState({local_state_prop2: this.state.local_state_prop2 - 1})\n    }\n \n  ...\n    &lt;button onClick={() =&gt; this.inc_local()}&gt; INC Local State  &lt;/button&gt;\n    &lt;button onClick={() =&gt; this.dec_local()}&gt; DEC Local State  &lt;/button&gt;\n    &lt;br /&gt;\n    &lt;br /&gt;\n      {this.state.local_state_prop2}\n    &lt;br /&gt;\n ...\n    </code></pre><pre tabindex=\"0\"><code>\nconst HooksContainer1 = () =&gt; {\n    const [value, setValue] = useState({local_state_prop1: true,\n                                        local_state_prop2: 0\n                                       })\n  \n...    \n    const incrementValue_uS = () =&gt; {\n      setValue({...value, local_state_prop2: value.local_state_prop2 + 1} )\n    }\n\n    const decrementValue_uS = () =&gt; {\n      setValue({...value, local_state_prop2: value.local_state_prop2 - 1} )\n    }\n    \n...\n\n      &lt;button onClick={() =&gt; incrementValue_uS()}&gt; Add Local Value uS &lt;/button&gt;\n      &lt;button onClick={() =&gt; decrementValue_uS()}&gt; Dec Local Value uS&lt;/button&gt;\n      &lt;br /&gt;\n      &lt;p&gt;Local useState Value: {value.local_state_prop2}&lt;/p&gt;\n      &lt;br /&gt;\n ...</code></pre><p>Before getting started, I\u2019d like to clarify a few things that confused me when I first started working with React Hooks.</p><h4 id=\"usereducer-and-context\"><strong>useReducer and Context</strong></h4><p>I was confused a little at first by useReducer. I thought by simply using useReducer, I would have automatically mimicked Redux functionality and have a global state. That isn\u2019t the case. It is Context that makes our state global. Context can be used with either useReducer and useState.</p><blockquote><strong>global state</strong>: meaning state persists from one component to another. If you changed state in one component and went to another component, the state would be saved if it is global. If the state is local and you went to another component the state would not be saved.</blockquote><h4 id=\"when-to-use-local-or-global-state-and-usestate-and-usereducer\"><strong>When to use local or global state and useState and useReducer</strong></h4><p>For teaching purposes, I will show you all four possible combinations of local and global state with useState and useReducer. In a real app, I would use the useReducer hook for complex global states, such as authentication and storing data from a server. I would use the useState hook for simpler local state, such as opening up and closing a modal.</p><h4 id=\"how-context-works\"><strong>How Context Works</strong></h4><figure><img alt=\"vKxyeIoOimtSIC3gy9nk7N-BdBtTHySC2t2J\" height=\"465\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/vKxyeIoOimtSIC3gy9nk7N-BdBtTHySC2t2J\" width=\"800\"/></figure><p>Context predates React hooks and is a way to pass down props to deeply nested child components. Without context, props would have to be passed down to every intermediary component to get to the intended child component.</p><p>Context solved this by allowing you to pass in a prop to the parent component. Then it would be available to all the child components automatically. You did not have to pass it down through middle man components. And this is essentially how we have a global state. By using the Context in the root component, our state is available to all child components. Since App.js is the root component, and every other component is the child component, the state we defined in App.js is available to all components.</p><p>It\u2019s important to keep in mind that all the state is contained, initialized and updated in the App.js file. You can call a function to change the state from a child component but it is ultimately updated in the App.js file.</p><h3 id=\"directory-structure-and-intro\"><strong>Directory Structure and Intro</strong></h3><p>Instead of focusing on how to build this app step by step, I will instead focus more on the differences between the React-Redux class and the React hooks.</p><p>Here are a couple of acronyms I use and their meaning</p><p><strong>uS</strong> = useState signifies when something is using the useState hook</p><p><strong>uR</strong> = useReducer signifies when something is using the useReducer hook</p><figure><img alt=\"730bBk8D8F5zEDgkhYE0X5XP6ZXCvrK7droc\" height=\"676\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/730bBk8D8F5zEDgkhYE0X5XP6ZXCvrK7droc\" width=\"354\"/></figure><p>Here is the directory structure. It is a very basic app that has:</p><ul><li>1 React-Redux class</li><li>1 React functional component that uses the useState, useReducer, and useContext hooks</li><li>Actions and action types</li><li>Reducers to use with React hooks</li><li>Reducers to use with React-Redux</li><li>a Context file</li><li>The root App.js file</li></ul><h4 id=\"the-context-object\"><strong>The Context Object</strong></h4><p>I like to have context in its own file since you have to import it to every child component that you use with the<code> useContext() </code>hook. We don\u2019t need to do anything else to setup the Context object, we just need this one function.</p><pre tabindex=\"0\"><code>\nimport React from 'react';\n\nconst Context = React.createContext()\n\nexport default Context;</code></pre><p>Also, notice we are not passing in any state to the Context object. You may see other tutorials that pass values to the <code>createContext()</code> function. This is pointless as we will override these values when we setup the <code>&lt;Context.Provider /&gt;</code> and pass in the state to the <code>value</code> prop.</p><h4 id=\"reducers-and-actions\"><strong>Reducers and Actions</strong></h4><p>Now I will show a reducer for use with React Hooks and one for use with regular React Redux.</p><p>Reducer for use with React Hooks:</p><pre tabindex=\"0\"><code>\nimport * as ACTION_TYPES from '../actions/action_types'\n\nexport const initialState = {\n  hooks_stateprop1: false,\n}\n\nexport const Reducer1 = (state = initialState, action) =&gt; {\n    switch(action.type) {\n      case ACTION_TYPES.SUCCESS:\n        return {\n          ...state,\n          hooks_stateprop1: true,\n        }\n      case ACTION_TYPES.FAILURE:\n        return {\n          ...state,\n          hooks_stateprop1: false,\n        }\n      default:\n        throw new Error();\n    }\n}</code></pre><p>Reducer for React Redux:</p><pre tabindex=\"0\"><code>import * as ACTION_TYPES from '../actions/action_types'\n\nconst initialState = {\n  stateprop1: false\n}\n\nconst Reducer1 = (state = initialState, action) =&gt; {\n    switch(action.type) {\n      case ACTION_TYPES.SUCCESS:\n        return {\n          ...state,\n          stateprop1: true\n        }\n      case ACTION_TYPES.FAILURE:\n        return {\n          ...state,\n          stateprop1: false\n        }\n      default:\n        return state\n    }\n}\n\nexport default Reducer1;</code></pre><p>Notice in the React Hooks reducer we are exporting both the intialState and reducer. We are not using <code>export default</code> at the bottom. In the React Redux reducer we <code>export default</code> the reducer.</p><p>Next, we have our actions and action types:</p><pre tabindex=\"0\"><code>export const SUCCESS = \"SUCCESS\"\n\nexport const FAILURE = \"FAILURE\"\n\n...</code></pre><pre tabindex=\"0\"><code>\nimport * as ACTION_TYPES from './action_types'\n\nexport const SUCCESS = {\n  type: ACTION_TYPES.SUCCESS\n}\n\nexport const FAILURE = {\n  type: ACTION_TYPES.FAILURE\n}\n\nexport const success = () =&gt; {\n  return {\n    type: ACTION_TYPES.SUCCESS\n  }\n}\n\nexport const failure = () =&gt; {\n  return {\n    type: ACTION_TYPES.FAILURE\n  }\n}\n...</code></pre><p>Actions and action creators require no changes from React Redux.</p><h4 id=\"reading-and-updating-state-in-react-redux-vs-react-hooks\"><strong>Reading and Updating state in React Redux vs React Hooks</strong></h4><p>With the preliminary information out of the way, we can now look at the <code>hooks_container1.js</code> and <code>container1.js</code> and see the differences between React Hooks and React Redux in the code.</p><p>Let\u2019s start off and look at local state for each and see how you would implement a simple counter.</p><pre tabindex=\"0\"><code>class Container1 extends Component {\n    constructor(props) {\n      super(props)\n\n      this.state = {\n        local_state_prop1: true,\n        local_state_prop2: 0,\n        cDM_value: ''\n      }\n    }\n\n ...\n \n    inc_local = () =&gt; {\n      this.setState({local_state_prop2: this.state.local_state_prop2 + 1})\n    }\n\n    dec_local = () =&gt; {\n      this.setState({local_state_prop2: this.state.local_state_prop2 - 1})\n    }\n \n  ...\n    &lt;button onClick={() =&gt; this.inc_local()}&gt; INC Local State  &lt;/button&gt;\n    &lt;button onClick={() =&gt; this.dec_local()}&gt; DEC Local State  &lt;/button&gt;\n    &lt;br /&gt;\n    &lt;br /&gt;\n      {this.state.local_state_prop2}\n    &lt;br /&gt;\n ...\n    \n </code></pre><p><strong>React Hooks</strong></p><pre tabindex=\"0\"><code>\n\nconst HooksContainer1 = () =&gt; {\n    const [value, setValue] = useState({local_state_prop1: true,\n                                        local_state_prop2: 0\n                                       })\n  \n...    \n    const incrementValue_uS = () =&gt; {\n      setValue({...value, local_state_prop2: value.local_state_prop2 + 1} )\n    }\n\n    const decrementValue_uS = () =&gt; {\n      setValue({...value, local_state_prop2: value.local_state_prop2 - 1} )\n    }\n    \n...\n\n      &lt;button onClick={() =&gt; incrementValue_uS()}&gt; Add Local Value uS &lt;/button&gt;\n      &lt;button onClick={() =&gt; decrementValue_uS()}&gt; Dec Local Value uS&lt;/button&gt;\n      &lt;br /&gt;\n      &lt;p&gt;Local useState Value: {value.local_state_prop2}&lt;/p&gt;\n      &lt;br /&gt;\n ...</code></pre><p>The first thing to note is that we are going from using a class component in React Redux to a functional component in React Hooks. Hence why we don't have the \u201cthis\u201d keyword anywhere in our React Hooks code. Since we are not in a class, we can reference the variable and function names directly.</p><p>In React Redux we initialize the state in the constructor and have a dedicated <code>setState()</code> function. Both \u201cstate\u201d and \u201csetState()\u201d are reserved names.</p><p>This is not so in React hooks. In React Hooks we create our own \u201cstate\u201d keyword and setState() function ourselves with the useState() Hook. In the example above, you can think of <code>value</code> as the equivalent to <code>this.state</code> in a class component. And similar to <code>this.state</code>, we use dot notation to access each individual property of state, so the syntax we will be:</p><pre><code> value.name_of_property</code></pre><p>When I first started learning Hooks, I used to confuse the <code>useState() </code>hook as the equivalent to <code>setState()</code> function in React Redux. This isn\u2019t the case. The React Redux <code>setState()</code> function is equivalent to the second element in the array destructuring. Which in the example above is <code>setValue()</code>. This <code>setValue()</code> function is how we update our state with hooks. <code>useState()</code> is then just a way we initialize the ability to read and update the state in a functional component. This previously was only available to class components.</p><h4 id=\"merging-the-old-state-in-react-hooks\"><strong>Merging the old state in React Hooks</strong></h4><p>Another important thing to notice in the React Hooks example is that I am using <code>\u2026value </code>before updating the state in the increment and decrement functions. This is the spread operator, that passes in the entire flattened previous state to the setState() function.</p><p>I did not need to pass in the previous state in the React Redux example. When we update a state property in React Redux the new state property is automatically merged with the old state properties</p><p>This <strong>does not</strong> happen in React Hooks. When you update the state in React Hooks, a new state is created. You see in the React Hooks example we have 2 state properties:<code> local_state_prop1</code> and <code>local_state_prop2</code>. If we update the state with only <code>local_state_prop2</code> and not pass in <code>\u2026value</code> then a new state will be created that has only <code>local_state_prop2</code>. Meaning our <code>local_state_prop1</code> will simply just be deleted.</p><p>So when converting state from React Redux to React Hooks, you will need to pass in the entire previous state with the spread operator when updating a single state property.</p><h4 id=\"reading-and-updating-state-with-usereducers-and-redux-reducers\"><strong>Reading and Updating state with useReducers and Redux Reducers</strong></h4><p>We can now compare reading and updating state with useReducer and Reducers.</p><p>We are using the same reducer as in the above example. A reducer with <code>SUCCESS</code> and <code>FAILURE</code> action types that changes <code>stateprop1</code> from true to false and vice versa.</p><p>useReducer Hook</p><pre tabindex=\"0\"><code>import * as Reducer1 from '../store/hooks_reducers/reducer1_hooks';\n\n...\nconst HooksContainer1 = () =&gt; {\n      const [stateLocal1, dispatchLocal1] = useReducer(Reducer1.Reducer1,\n                                                     Reducer1.initialState)\n    \n...\n\n    const action1 = () =&gt; {\n      //    dispatchLocal1({type: \"SUCCESS\"})\n      //  dispatchLocal1(ACTIONS.success())\n          dispatchLocal1(ACTIONS.SUCCESS)\n\n    }\n\n    const action2 = () =&gt; {\n      //   dispatchLocal1({type: \"FAILURE\"})\n      //   dispatchLocal1(ACTIONS.failure())\n           dispatchLocal1(ACTIONS.FAILURE)\n\n    }\n ...\n \n    &lt;button onClick={() =&gt; action1()}&gt;Dispatch Action 1  &lt;/button&gt;\n    &lt;button onClick={() =&gt; action2()}&gt;Dispatch Action 2 &lt;/button&gt;\n      &lt;br /&gt;\n      {stateLocal1.stateprop1\n        ? &lt;p&gt; stateprop1 is true &lt;/p&gt;\n        : &lt;p&gt; stateprop1 is false &lt;/p&gt;\n      }\n      &lt;br /&gt;\n...</code></pre><p>React Redux</p><pre tabindex=\"0\"><code>...\n\nfunction mapStateToProps(state) {\n  return {\n    stateprop1: state.reducer1.stateprop1,\n  }\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    // action_creator1: () =&gt; dispatch(ACTIONS.success()),\n    // action_creator2: () =&gt; dispatch(ACTIONS.failure()),\n    // action_type1: () =&gt; dispatch({type: \"SUCCESS\"}),\n    // action_type2: () =&gt; dispatch({type: \"FAILURE}),\n    action1: () =&gt; dispatch(ACTIONS.SUCCESS),\n    action2: () =&gt; dispatch(ACTIONS.FAILURE),\n  }\n}\n\n...\n\n  &lt;button onClick={() =&gt; this.props.action1()}&gt; Dispatch Action 1 &lt;/button&gt;\n  &lt;button onClick={() =&gt; this.props.action2()}&gt;Dispatch Action 2 &lt;/button&gt;\n  &lt;br /&gt;\n  {this.props.stateprop1\n    ? &lt;p&gt; stateprop1 is true &lt;/p&gt;\n    : &lt;p&gt; stateprop1 is false &lt;/p&gt;\n  }\n  &lt;br /&gt;\n...</code></pre><p>As mentioned in the intro, even though we are using <code>useReducer()</code> in the functional component, we are still only updating the local component state. I will show you how to mimic Redux functionality with Context and have a global state in the next section. It is important to keep in mind we are still only updating the local state here in our Hooks container even though we are using actions and reducers.</p><p>On the other hand, in our React Class component, we are updating the global state since we are using Redux.</p><p>So the first difference you will notice with useReducer is that we have to import our reducer and initial state and pass it into the useReducer hook, which is something we don't do with React Redux. In React Redux we just use the <code>connect()</code> function.</p><h4 id=\"reading-state-and-dispatching-actions\"><strong>Reading state and Dispatching Actions</strong></h4><p>Next, to dispatch actions in React Hooks, we use an arrow function then dispatch our actions in the body of the function. You can dispatch actions directly in the <code>onClick()</code> event but having the dispatch in a function will make your code more readable.</p><p>In React Redux we set properties in the <code>mapDispatchToProps()</code> function, then each property is an arrow function that dispatches actions.</p><p>You will notice that we pass in actions and actions creators in the exact same way to the dispatch function in both React Hooks and React Redux. There is literally no difference which is why we didn't need to change our actions at all. I have included all the ways of dispatching actions as a comment.</p><p>The only difference between React Hooks and React Redux is that the \u201cdispatch\u201d function name is reserved in React Redux. In React Hooks we create our own \u201cdispatch\u201d function name through the useReducer hook.</p><p>To call the dispatch function in React Redux we use the syntax <code>this.props</code> then the name of the property in <code>mapDispatchToProps()</code> function. In React Hooks we just call the dispatch function name directly.</p><p>To read the state in React Redux we do <code>this.props</code> and then the name of the property in the <code>mapStateToProps()</code> function. The name of the property holds the value for a specific property in a specific reducer. In React Hooks we just do the name of the state value. This is the first element in the array destructuring in the useReducer hook call. Then the name of the property we defined in the intialState in the reducer.</p><h4 id=\"context-with-usestate\"><strong>Context with useState</strong></h4><p>Now I will go over Context which is how we setup a global state. It is important to note that Context is not part of React Hooks. <code>useContext()</code> is a React Hook, but Context itself is not part of React Hooks. Context is simply a way to pass down props from a parent component to a deeply nested child component. See the \u201cHow Context Works\u201d section at the beginning of this tutorial for a full explanation.</p><p>Also, I will not be making comparisons between React Redux and Context because Context does not have an opposite in React Redux. I will show you how to implement a global state with Context using both the <code>useReducer()</code> and <code>useState()</code> hook.</p><p>We will first start off with the using the <code>useState()</code> hook to setup a global state.</p><p>We will begin setting up our global state in the root App.js file. We will first import the Context object we setup in the <code>context.js </code>file. We will also need to import our Hooks functional component.</p><pre tabindex=\"0\"><code>\nimport Context from '../utils/context';\nimport HooksContainer1 from './hooks/hooks_container1';\n...\n\nconst App = () =&gt; {\n    const [valueGlobal_uS, setValueGlobal_uS] = useState(0)\n    \n    const incrementValueGlobal_uS = () =&gt; {\n      setValueGlobal_uS(valueGlobal_uS + 1 )\n    }\n\n    const decrementValueGlobal_uS = () =&gt; {\n      setValueGlobal_uS(valueGlobal_uS - 1 )\n    }\n    \n...    \n    \n    &lt;div&gt;\n     &lt;Context.Provider\n          value={{\n            //global state with useState\n            valueGlobalState_uS: valueGlobal_uS,\n            addGlobalValue_uS: () =&gt; incrementValueGlobal_uS(),\n            decGlobalValue_uS: () =&gt; decrementValueGlobal_uS(),\n          }}&gt;\n        &lt;HooksContainer1 /&gt;\n      &lt;/Context.Provider&gt;\n     &lt;/div&gt;\n...</code></pre><p>We can just set up a simple counter for now. Our <code>useState()</code> hook is setup as usual. In our JSX we are wrapping our <code>&lt;HooksContainer1 /&gt;</code> with the <code>&lt;Context.Provider /&gt;</code> element. This is what allows us to pass state from App.js to child components. We also have 3 properties supplied to our <code>value</code> prop. 1 to hold the state value and 2 properties to change the state. Notice that we don't use the <code>useContext()</code> hook in App.js. The <code>useContext()</code> hook will actually be used in child components to read and update the state.</p><p>You can essentially think of the <code>value</code> prop as both the <code>mapStateToProps()</code> and <code>mapDispatchToProps()</code> functions combined into one because of the <code>value</code> prop holds properties that allow you to read and update the state that can be called and accessed by the child component which is exactly what the <code>mapStateToProps()</code> and <code>mapDispatchToProps()</code> functions do.</p><p>Now let's look at how we would use this Context object in a child component.</p><pre tabindex=\"0\"><code>\nimport Context from '../utils/context';\n\n...\nconst HooksContainer1 = () =&gt; {\n  \n...\n    const context = useContext(Context)\n\n\n    &lt;p&gt;Global useState Value: {context.valueGlobalState_uS}&lt;/p&gt;\n\n    &lt;button onClick={() =&gt; context.addGlobalValue_uS()}&gt; Add Global Value uS &lt;/button&gt;\n    &lt;button onClick={() =&gt; context.decGlobalValue_uS()}&gt; Dec Global Value uS &lt;/button&gt;\n\n...</code></pre><p>We first have to import our Context object at the top. This is the original Context object that we created with the <code>createContext()</code> function, not the <code>&lt;Context.Provider /&gt;</code> we just setup. Then we simply pass this Context object to the <code>useContext()</code> hook and save it in a variable. This context variable now has all the properties we just defined in the <code>value</code> prop of the <code>&lt;Context.Provider /&gt;</code>.</p><p>To access the properties of the <code>value</code> prop we can just use dot notation. For example, to access the state value here in our child component, we use the syntax <code>context.valueGlobalstate_uS</code>.</p><p>Note that <code>valueGlobalState</code> is the name of the <em>property </em>we defined in the App.js file in the value prop. <code>valueGlobalState</code> is the property that holds the value of the state which in App.js we defined as <code>valueGlobal_uS</code>. Similarly, to change the state we call the property name and not the name of the function we set in App.js.</p><p>I have intentionally kept the property and function names different so its easier to see how Context works in the child component.</p><p>This is it for using Context with useState. I will now demonstrate with useReducer.</p><h4 id=\"context-with-usereducer\"><strong>Context with useReducer</strong></h4><p>Using Context with useReducer is essentially how we achieve Redux functionality.</p><p>In order to avoid confusion, I will setup a new reducer and actions for this.</p><pre tabindex=\"0\"><code>\nexport const CONTEXT_INC = \"CONTEXT_INC\"\n\nexport const CONTEXT_DEC = \"CONTEXT_DEC\"</code></pre><pre tabindex=\"0\"><code>export const CONTEXT_INC = {\n  type: ACTION_TYPES.CONTEXT_INC\n}\n\nexport const CONTEXT_DEC = {\n  type: ACTION_TYPES.CONTEXT_DEC\n}</code></pre><pre tabindex=\"0\"><code>import * as ACTION_TYPES from '../actions/action_types'\n\nexport const initialState = {\n  context_prop1: 0,\n}\n\nexport const ContextReducer = (state = initialState, action) =&gt; {\n    switch(action.type) {\n      case ACTION_TYPES.CONTEXT_INC:\n        return {\n          ...state,\n          context_prop1: state.context_prop1 + 1\n        }\n      case ACTION_TYPES.CONTEXT_DEC:\n        return {\n          ...state,\n          context_prop1: state.context_prop1 - 1\n        }\n      default:\n        throw new Error();\n    }\n}</code></pre><p>So we have a simple reducer that functions as a counter. Now we can set up the useReducer hook in our App.js file and we will set this up in the exact same way that we set up useReducer in our Hooks container. We import the ContextReducer and its initial state and pass it into the useReducer Hook in App.js. Because we are now using Context we will not import our Context Reducer to the child components. The state will be changed here in our App.js file and will simply be passed down as props.</p><pre tabindex=\"0\"><code>import * as ACTIONS from './store/actions/actions';\nimport * as ContextReducer from './store/reducers/context_reducer';\n\n...\n\nconst App = () =&gt; {\n\n...\n\n    const [contextState, contextDispatch] = useReducer(ContextReducer.ContextReducer,\n                                                       ContextReducer.initialState)\n                                                       \n    const dispatchContextInc = () =&gt; {\n      contextDispatch(ACTIONS.CONTEXT_INC)\n    }\n\n    const dispatchContextDec = () =&gt; {\n      contextDispatch(ACTIONS.CONTEXT_DEC)\n    }\n ...\n \n \n       &lt;div&gt;\n      &lt;Context.Provider\n          value={{\n            //global state with useState\n            valueGlobalState_uS: valueGlobal_uS,\n            addGlobalValue_uS: () =&gt; incrementValueGlobal_uS(),\n            decGlobalValue_uS: () =&gt; decrementValueGlobal_uS(),\n\n            //global state with useReducer\n            valueGlobalState_uR: contextState,\n            addGlobalValue_uR: () =&gt; dispatchContextInc(),\n            decGlobalValue_uR: () =&gt; dispatchContextDec()\n          }}&gt;\n              &lt;HooksContainer1 /&gt;\n          &lt;/Context.Provider&gt;\n        &lt;/div&gt;\n...</code></pre><p>We set up our properties in the <code>value</code> prop in the exact same way that we did when we used Context with the <code>useState()</code> hook. The actions are also dispatched in the exact same way as we\u2019ve seen before.</p><p>Now for our child component:</p><pre tabindex=\"0\"><code>...\n\nconst HooksContainer1 = () =&gt; {\n  \n const context = useContext(Context)\n \n...\n\n &lt;button onClick={() =&gt; context.addGlobalValue_uR()}&gt; Add Global Value uR &lt;/button&gt;\n &lt;button onClick={() =&gt; context.decGlobalValue_uR()}&gt; Dec Global Value uR &lt;/button&gt;\n\n &lt;p&gt;Global useReducer Value: {context.valueGlobalState_uR.context_prop1}&lt;/p&gt;</code></pre><p>As you can see, reading and updating state with <code>useReducer()</code> hook is very similar to the <code>useState()</code> example. We can even use the same context variable we used for <code>useState()</code>, we don't have to initialize another one. To update the state we simply call the property name we defined in the <code>value</code> prop of the provider. This updates the state in App.js. Because we are updating our state in App.js we don't have to import the ContextReducer here in our child component and pass it into the <code>useReducer()</code> hook.</p><p>Reading the state is a little bit different. Since <code>valueGlobalState_uR</code> contains our entire state, we have to specify a single property of state which in this case is <code>context_prop1</code>.</p><p>And this is it! After this you can read and update the state in any component in your app using this same pattern, allowing you to mimic Redux functionality essentially.</p><p>For a 100% Free Video version of this tutorial and more in-depth React Hooks content see my Udemy course or Youtube playlist:</p>\n</section><p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p></div></article>", "textContent": "\n                            \nHello everyone! With the recent release of create-react-app v3 and React hooks, I decided to write a tutorial on how to refactor a class component to a functional hooks component.In this tutorial, I will share how I did it. I refer to this as the \u201ceasy way\u201d since it doesn't require you to change your Redux code at all. The reducers and actions can be virtually left as is.If you want a more basic intro to React Hooks integration check out my previous tutorial.You can find the project code here.You can also follow me on twitter for more tutorials in the future: here  This project uses both Redux and React hooks which will allow you to see the code and differences side by side. Open up the hooks_container1.js file and container1.js files in your text editor to see the differences. I tried my best to match the React class and React hook line for line making it easier to see the differences. However, it didn\u2019t work out perfectly since there are some major differences between React Hooks and React classes. I tried to keep the functionality of both components the same so it will be easier for you to pick out the differences in syntax.Table of ContentsTLDR versionuseReducer and ContextWhen to use local or global state and useState and useReducerHow Context WorksDirectory StructureThe Context ObjectReducers and ActionsReading and Updating state in React Redux vs. React HooksMerging the old state in React HooksReading and Updating state with useReducer and Redux ReducersReading state and Dispatching ActionsContext with useStateContext with useReducerThe Easy Way \u2014 TL;DRStep 1: For your reducers, export both the initialState and the reducer. Do not export default the reducer.Step 2: Actions can be left as is from React-ReduxStep 3: Import all your reducers and their initialState to the root App.js file. Import actions as normal.Step 4: Pass in each reducer and its initialState to a separate useReducer() hook in the App.js file.Step 5: Import the React.createContext() function to App.js after initializing it in its own file. Wrap all child components with <Context.Provider />Step 6: Next simply cut and paste the properties defined in your React-Redux mapStateToProps() and mapDispatchToProps() functions to the value prop of <Context.Provider />Step 7: Change the dispatch keyword in your properties from the mapDispatchToProps() function to the name of the dispatch actions function (2nd element in the array destructuring) in the useReducer() hook. Since each reducer will have its own useReducer hook, you will have to match the appropriate action dispatches with the right reducer.Step 8: Do the same thing for the mapStateToProps() function. Change the name of the property to match the useReducer hook. The state value for the useReducer() hook (1st element in the array destructuring) contains the entire initial state from the reducer. You will need to access each property of state with dot notation, and then pass it into a property in the \u201cvalue\u201d prop.Step 9: Finally to actually use the global Context state in a child component, you first import the original Context object to the child component. Then pass in the imported Context object to the useContext() hook. Save the result of the useContext hooks in a variable. Now you have access to all the properties that we defined in the value prop of the <Context.Provider /> in the root App.js file.Accessing state values in a child component with context: context.stateprop1Dispatching actions in a child component with context: () => context.action1()Here is an example of a React Redux class container and a React Hooks functional component with similar functionality side by side. class Container1 extends Component {\n    constructor(props) {\n      super(props)\n\n      this.state = {\n        local_state_prop1: true,\n        local_state_prop2: 0,\n        cDM_value: ''\n      }\n    }\n\n ...\n \n    inc_local = () => {\n      this.setState({local_state_prop2: this.state.local_state_prop2 + 1})\n    }\n\n    dec_local = () => {\n      this.setState({local_state_prop2: this.state.local_state_prop2 - 1})\n    }\n \n  ...\n    <button onClick={() => this.inc_local()}> INC Local State  </button>\n    <button onClick={() => this.dec_local()}> DEC Local State  </button>\n    <br />\n    <br />\n      {this.state.local_state_prop2}\n    <br />\n ...\n    \nconst HooksContainer1 = () => {\n    const [value, setValue] = useState({local_state_prop1: true,\n                                        local_state_prop2: 0\n                                       })\n  \n...    \n    const incrementValue_uS = () => {\n      setValue({...value, local_state_prop2: value.local_state_prop2 + 1} )\n    }\n\n    const decrementValue_uS = () => {\n      setValue({...value, local_state_prop2: value.local_state_prop2 - 1} )\n    }\n    \n...\n\n      <button onClick={() => incrementValue_uS()}> Add Local Value uS </button>\n      <button onClick={() => decrementValue_uS()}> Dec Local Value uS</button>\n      <br />\n      <p>Local useState Value: {value.local_state_prop2}</p>\n      <br />\n ...Before getting started, I\u2019d like to clarify a few things that confused me when I first started working with React Hooks.useReducer and ContextI was confused a little at first by useReducer. I thought by simply using useReducer, I would have automatically mimicked Redux functionality and have a global state. That isn\u2019t the case. It is Context that makes our state global. Context can be used with either useReducer and useState.global state: meaning state persists from one component to another. If you changed state in one component and went to another component, the state would be saved if it is global. If the state is local and you went to another component the state would not be saved.When to use local or global state and useState and useReducerFor teaching purposes, I will show you all four possible combinations of local and global state with useState and useReducer. In a real app, I would use the useReducer hook for complex global states, such as authentication and storing data from a server. I would use the useState hook for simpler local state, such as opening up and closing a modal.How Context WorksContext predates React hooks and is a way to pass down props to deeply nested child components. Without context, props would have to be passed down to every intermediary component to get to the intended child component.Context solved this by allowing you to pass in a prop to the parent component. Then it would be available to all the child components automatically. You did not have to pass it down through middle man components. And this is essentially how we have a global state. By using the Context in the root component, our state is available to all child components. Since App.js is the root component, and every other component is the child component, the state we defined in App.js is available to all components.It\u2019s important to keep in mind that all the state is contained, initialized and updated in the App.js file. You can call a function to change the state from a child component but it is ultimately updated in the App.js file.Directory Structure and IntroInstead of focusing on how to build this app step by step, I will instead focus more on the differences between the React-Redux class and the React hooks.Here are a couple of acronyms I use and their meaninguS = useState signifies when something is using the useState hookuR = useReducer signifies when something is using the useReducer hookHere is the directory structure. It is a very basic app that has:1 React-Redux class1 React functional component that uses the useState, useReducer, and useContext hooksActions and action typesReducers to use with React hooksReducers to use with React-Reduxa Context fileThe root App.js fileThe Context ObjectI like to have context in its own file since you have to import it to every child component that you use with the useContext() hook. We don\u2019t need to do anything else to setup the Context object, we just need this one function.\nimport React from 'react';\n\nconst Context = React.createContext()\n\nexport default Context;Also, notice we are not passing in any state to the Context object. You may see other tutorials that pass values to the createContext() function. This is pointless as we will override these values when we setup the <Context.Provider /> and pass in the state to the value prop.Reducers and ActionsNow I will show a reducer for use with React Hooks and one for use with regular React Redux.Reducer for use with React Hooks:\nimport * as ACTION_TYPES from '../actions/action_types'\n\nexport const initialState = {\n  hooks_stateprop1: false,\n}\n\nexport const Reducer1 = (state = initialState, action) => {\n    switch(action.type) {\n      case ACTION_TYPES.SUCCESS:\n        return {\n          ...state,\n          hooks_stateprop1: true,\n        }\n      case ACTION_TYPES.FAILURE:\n        return {\n          ...state,\n          hooks_stateprop1: false,\n        }\n      default:\n        throw new Error();\n    }\n}Reducer for React Redux:import * as ACTION_TYPES from '../actions/action_types'\n\nconst initialState = {\n  stateprop1: false\n}\n\nconst Reducer1 = (state = initialState, action) => {\n    switch(action.type) {\n      case ACTION_TYPES.SUCCESS:\n        return {\n          ...state,\n          stateprop1: true\n        }\n      case ACTION_TYPES.FAILURE:\n        return {\n          ...state,\n          stateprop1: false\n        }\n      default:\n        return state\n    }\n}\n\nexport default Reducer1;Notice in the React Hooks reducer we are exporting both the intialState and reducer. We are not using export default at the bottom. In the React Redux reducer we export default the reducer.Next, we have our actions and action types:export const SUCCESS = \"SUCCESS\"\n\nexport const FAILURE = \"FAILURE\"\n\n...\nimport * as ACTION_TYPES from './action_types'\n\nexport const SUCCESS = {\n  type: ACTION_TYPES.SUCCESS\n}\n\nexport const FAILURE = {\n  type: ACTION_TYPES.FAILURE\n}\n\nexport const success = () => {\n  return {\n    type: ACTION_TYPES.SUCCESS\n  }\n}\n\nexport const failure = () => {\n  return {\n    type: ACTION_TYPES.FAILURE\n  }\n}\n...Actions and action creators require no changes from React Redux.Reading and Updating state in React Redux vs React HooksWith the preliminary information out of the way, we can now look at the hooks_container1.js and container1.js and see the differences between React Hooks and React Redux in the code.Let\u2019s start off and look at local state for each and see how you would implement a simple counter.React-Reduxclass Container1 extends Component {\n    constructor(props) {\n      super(props)\n\n      this.state = {\n        local_state_prop1: true,\n        local_state_prop2: 0,\n        cDM_value: ''\n      }\n    }\n\n ...\n \n    inc_local = () => {\n      this.setState({local_state_prop2: this.state.local_state_prop2 + 1})\n    }\n\n    dec_local = () => {\n      this.setState({local_state_prop2: this.state.local_state_prop2 - 1})\n    }\n \n  ...\n    <button onClick={() => this.inc_local()}> INC Local State  </button>\n    <button onClick={() => this.dec_local()}> DEC Local State  </button>\n    <br />\n    <br />\n      {this.state.local_state_prop2}\n    <br />\n ...\n    \n React Hooks\n\nconst HooksContainer1 = () => {\n    const [value, setValue] = useState({local_state_prop1: true,\n                                        local_state_prop2: 0\n                                       })\n  \n...    \n    const incrementValue_uS = () => {\n      setValue({...value, local_state_prop2: value.local_state_prop2 + 1} )\n    }\n\n    const decrementValue_uS = () => {\n      setValue({...value, local_state_prop2: value.local_state_prop2 - 1} )\n    }\n    \n...\n\n      <button onClick={() => incrementValue_uS()}> Add Local Value uS </button>\n      <button onClick={() => decrementValue_uS()}> Dec Local Value uS</button>\n      <br />\n      <p>Local useState Value: {value.local_state_prop2}</p>\n      <br />\n ...The first thing to note is that we are going from using a class component in React Redux to a functional component in React Hooks. Hence why we don't have the \u201cthis\u201d keyword anywhere in our React Hooks code. Since we are not in a class, we can reference the variable and function names directly.In React Redux we initialize the state in the constructor and have a dedicated setState() function. Both \u201cstate\u201d and \u201csetState()\u201d are reserved names.This is not so in React hooks. In React Hooks we create our own \u201cstate\u201d keyword and setState() function ourselves with the useState() Hook. In the example above, you can think of value as the equivalent to this.state in a class component. And similar to this.state, we use dot notation to access each individual property of state, so the syntax we will be: value.name_of_propertyWhen I first started learning Hooks, I used to confuse the useState() hook as the equivalent to setState() function in React Redux. This isn\u2019t the case. The React Redux setState() function is equivalent to the second element in the array destructuring. Which in the example above is setValue(). This setValue() function is how we update our state with hooks. useState() is then just a way we initialize the ability to read and update the state in a functional component. This previously was only available to class components.Merging the old state in React HooksAnother important thing to notice in the React Hooks example is that I am using \u2026value before updating the state in the increment and decrement functions. This is the spread operator, that passes in the entire flattened previous state to the setState() function.I did not need to pass in the previous state in the React Redux example. When we update a state property in React Redux the new state property is automatically merged with the old state propertiesThis does not happen in React Hooks. When you update the state in React Hooks, a new state is created. You see in the React Hooks example we have 2 state properties: local_state_prop1 and local_state_prop2. If we update the state with only local_state_prop2 and not pass in \u2026value then a new state will be created that has only local_state_prop2. Meaning our local_state_prop1 will simply just be deleted.So when converting state from React Redux to React Hooks, you will need to pass in the entire previous state with the spread operator when updating a single state property.Reading and Updating state with useReducers and Redux ReducersWe can now compare reading and updating state with useReducer and Reducers.We are using the same reducer as in the above example. A reducer with SUCCESS and FAILURE action types that changes stateprop1 from true to false and vice versa.useReducer Hookimport * as Reducer1 from '../store/hooks_reducers/reducer1_hooks';\n\n...\nconst HooksContainer1 = () => {\n      const [stateLocal1, dispatchLocal1] = useReducer(Reducer1.Reducer1,\n                                                     Reducer1.initialState)\n    \n...\n\n    const action1 = () => {\n      //    dispatchLocal1({type: \"SUCCESS\"})\n      //  dispatchLocal1(ACTIONS.success())\n          dispatchLocal1(ACTIONS.SUCCESS)\n\n    }\n\n    const action2 = () => {\n      //   dispatchLocal1({type: \"FAILURE\"})\n      //   dispatchLocal1(ACTIONS.failure())\n           dispatchLocal1(ACTIONS.FAILURE)\n\n    }\n ...\n \n    <button onClick={() => action1()}>Dispatch Action 1  </button>\n    <button onClick={() => action2()}>Dispatch Action 2 </button>\n      <br />\n      {stateLocal1.stateprop1\n        ? <p> stateprop1 is true </p>\n        : <p> stateprop1 is false </p>\n      }\n      <br />\n...React Redux...\n\nfunction mapStateToProps(state) {\n  return {\n    stateprop1: state.reducer1.stateprop1,\n  }\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    // action_creator1: () => dispatch(ACTIONS.success()),\n    // action_creator2: () => dispatch(ACTIONS.failure()),\n    // action_type1: () => dispatch({type: \"SUCCESS\"}),\n    // action_type2: () => dispatch({type: \"FAILURE}),\n    action1: () => dispatch(ACTIONS.SUCCESS),\n    action2: () => dispatch(ACTIONS.FAILURE),\n  }\n}\n\n...\n\n  <button onClick={() => this.props.action1()}> Dispatch Action 1 </button>\n  <button onClick={() => this.props.action2()}>Dispatch Action 2 </button>\n  <br />\n  {this.props.stateprop1\n    ? <p> stateprop1 is true </p>\n    : <p> stateprop1 is false </p>\n  }\n  <br />\n...As mentioned in the intro, even though we are using useReducer() in the functional component, we are still only updating the local component state. I will show you how to mimic Redux functionality with Context and have a global state in the next section. It is important to keep in mind we are still only updating the local state here in our Hooks container even though we are using actions and reducers.On the other hand, in our React Class component, we are updating the global state since we are using Redux.So the first difference you will notice with useReducer is that we have to import our reducer and initial state and pass it into the useReducer hook, which is something we don't do with React Redux. In React Redux we just use the connect() function.Reading state and Dispatching ActionsNext, to dispatch actions in React Hooks, we use an arrow function then dispatch our actions in the body of the function. You can dispatch actions directly in the onClick() event but having the dispatch in a function will make your code more readable.In React Redux we set properties in the mapDispatchToProps() function, then each property is an arrow function that dispatches actions.You will notice that we pass in actions and actions creators in the exact same way to the dispatch function in both React Hooks and React Redux. There is literally no difference which is why we didn't need to change our actions at all. I have included all the ways of dispatching actions as a comment.The only difference between React Hooks and React Redux is that the \u201cdispatch\u201d function name is reserved in React Redux. In React Hooks we create our own \u201cdispatch\u201d function name through the useReducer hook.To call the dispatch function in React Redux we use the syntax this.props then the name of the property in mapDispatchToProps() function. In React Hooks we just call the dispatch function name directly.To read the state in React Redux we do this.props and then the name of the property in the mapStateToProps() function. The name of the property holds the value for a specific property in a specific reducer. In React Hooks we just do the name of the state value. This is the first element in the array destructuring in the useReducer hook call. Then the name of the property we defined in the intialState in the reducer.Context with useStateNow I will go over Context which is how we setup a global state. It is important to note that Context is not part of React Hooks. useContext() is a React Hook, but Context itself is not part of React Hooks. Context is simply a way to pass down props from a parent component to a deeply nested child component. See the \u201cHow Context Works\u201d section at the beginning of this tutorial for a full explanation.Also, I will not be making comparisons between React Redux and Context because Context does not have an opposite in React Redux. I will show you how to implement a global state with Context using both the useReducer() and useState() hook.We will first start off with the using the useState() hook to setup a global state.We will begin setting up our global state in the root App.js file. We will first import the Context object we setup in the context.js file. We will also need to import our Hooks functional component.\nimport Context from '../utils/context';\nimport HooksContainer1 from './hooks/hooks_container1';\n...\n\nconst App = () => {\n    const [valueGlobal_uS, setValueGlobal_uS] = useState(0)\n    \n    const incrementValueGlobal_uS = () => {\n      setValueGlobal_uS(valueGlobal_uS + 1 )\n    }\n\n    const decrementValueGlobal_uS = () => {\n      setValueGlobal_uS(valueGlobal_uS - 1 )\n    }\n    \n...    \n    \n    <div>\n     <Context.Provider\n          value={{\n            //global state with useState\n            valueGlobalState_uS: valueGlobal_uS,\n            addGlobalValue_uS: () => incrementValueGlobal_uS(),\n            decGlobalValue_uS: () => decrementValueGlobal_uS(),\n          }}>\n        <HooksContainer1 />\n      </Context.Provider>\n     </div>\n...We can just set up a simple counter for now. Our useState() hook is setup as usual. In our JSX we are wrapping our <HooksContainer1 /> with the <Context.Provider /> element. This is what allows us to pass state from App.js to child components. We also have 3 properties supplied to our value prop. 1 to hold the state value and 2 properties to change the state. Notice that we don't use the useContext() hook in App.js. The useContext() hook will actually be used in child components to read and update the state.You can essentially think of the value prop as both the mapStateToProps() and mapDispatchToProps() functions combined into one because of the value prop holds properties that allow you to read and update the state that can be called and accessed by the child component which is exactly what the mapStateToProps() and mapDispatchToProps() functions do.Now let's look at how we would use this Context object in a child component.\nimport Context from '../utils/context';\n\n...\nconst HooksContainer1 = () => {\n  \n...\n    const context = useContext(Context)\n\n\n    <p>Global useState Value: {context.valueGlobalState_uS}</p>\n\n    <button onClick={() => context.addGlobalValue_uS()}> Add Global Value uS </button>\n    <button onClick={() => context.decGlobalValue_uS()}> Dec Global Value uS </button>\n\n...We first have to import our Context object at the top. This is the original Context object that we created with the createContext() function, not the <Context.Provider /> we just setup. Then we simply pass this Context object to the useContext() hook and save it in a variable. This context variable now has all the properties we just defined in the value prop of the <Context.Provider />.To access the properties of the value prop we can just use dot notation. For example, to access the state value here in our child component, we use the syntax context.valueGlobalstate_uS.Note that valueGlobalState is the name of the property we defined in the App.js file in the value prop. valueGlobalState is the property that holds the value of the state which in App.js we defined as valueGlobal_uS. Similarly, to change the state we call the property name and not the name of the function we set in App.js.I have intentionally kept the property and function names different so its easier to see how Context works in the child component.This is it for using Context with useState. I will now demonstrate with useReducer.Context with useReducerUsing Context with useReducer is essentially how we achieve Redux functionality.In order to avoid confusion, I will setup a new reducer and actions for this.\nexport const CONTEXT_INC = \"CONTEXT_INC\"\n\nexport const CONTEXT_DEC = \"CONTEXT_DEC\"export const CONTEXT_INC = {\n  type: ACTION_TYPES.CONTEXT_INC\n}\n\nexport const CONTEXT_DEC = {\n  type: ACTION_TYPES.CONTEXT_DEC\n}import * as ACTION_TYPES from '../actions/action_types'\n\nexport const initialState = {\n  context_prop1: 0,\n}\n\nexport const ContextReducer = (state = initialState, action) => {\n    switch(action.type) {\n      case ACTION_TYPES.CONTEXT_INC:\n        return {\n          ...state,\n          context_prop1: state.context_prop1 + 1\n        }\n      case ACTION_TYPES.CONTEXT_DEC:\n        return {\n          ...state,\n          context_prop1: state.context_prop1 - 1\n        }\n      default:\n        throw new Error();\n    }\n}So we have a simple reducer that functions as a counter. Now we can set up the useReducer hook in our App.js file and we will set this up in the exact same way that we set up useReducer in our Hooks container. We import the ContextReducer and its initial state and pass it into the useReducer Hook in App.js. Because we are now using Context we will not import our Context Reducer to the child components. The state will be changed here in our App.js file and will simply be passed down as props.import * as ACTIONS from './store/actions/actions';\nimport * as ContextReducer from './store/reducers/context_reducer';\n\n...\n\nconst App = () => {\n\n...\n\n    const [contextState, contextDispatch] = useReducer(ContextReducer.ContextReducer,\n                                                       ContextReducer.initialState)\n                                                       \n    const dispatchContextInc = () => {\n      contextDispatch(ACTIONS.CONTEXT_INC)\n    }\n\n    const dispatchContextDec = () => {\n      contextDispatch(ACTIONS.CONTEXT_DEC)\n    }\n ...\n \n \n       <div>\n      <Context.Provider\n          value={{\n            //global state with useState\n            valueGlobalState_uS: valueGlobal_uS,\n            addGlobalValue_uS: () => incrementValueGlobal_uS(),\n            decGlobalValue_uS: () => decrementValueGlobal_uS(),\n\n            //global state with useReducer\n            valueGlobalState_uR: contextState,\n            addGlobalValue_uR: () => dispatchContextInc(),\n            decGlobalValue_uR: () => dispatchContextDec()\n          }}>\n              <HooksContainer1 />\n          </Context.Provider>\n        </div>\n...We set up our properties in the value prop in the exact same way that we did when we used Context with the useState() hook. The actions are also dispatched in the exact same way as we\u2019ve seen before.Now for our child component:...\n\nconst HooksContainer1 = () => {\n  \n const context = useContext(Context)\n \n...\n\n <button onClick={() => context.addGlobalValue_uR()}> Add Global Value uR </button>\n <button onClick={() => context.decGlobalValue_uR()}> Dec Global Value uR </button>\n\n <p>Global useReducer Value: {context.valueGlobalState_uR.context_prop1}</p>As you can see, reading and updating state with useReducer() hook is very similar to the useState() example. We can even use the same context variable we used for useState(), we don't have to initialize another one. To update the state we simply call the property name we defined in the value prop of the provider. This updates the state in App.js. Because we are updating our state in App.js we don't have to import the ContextReducer here in our child component and pass it into the useReducer() hook.Reading the state is a little bit different. Since valueGlobalState_uR contains our entire state, we have to specify a single property of state which in this case is context_prop1.And this is it! After this you can read and update the state in any component in your app using this same pattern, allowing you to mimic Redux functionality essentially.For a 100% Free Video version of this tutorial and more in-depth React Hooks content see my Udemy course or Youtube playlist:https://www.udemy.com/react-hooks-with-react-redux-migrationhttps://www.youtube.com/watch?v=l8ODM-KoDpA&list=PLMc67XEAt-ywplHhDpoj5vakceZNr8S0B\n\n                        \n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    ", "length": 27152, "excerpt": "Hello everyone! With the recent release of create-react-app v3 and React hooks,\nI decided to write a tutorial on how to refactor a class component to a\nfunctional hooks component.\n\nIn this tutorial, I will share how I did it. I refer to this as the \u201ceasy way\u201d\nsince it doesn't require you to change your Redux code at all. The reducers and\nactions can be virtually left as is.\n\nIf you want a more basic intro to React Hooks integration check out my previous\ntutorial\n[https://medium.freecodecamp.org/", "siteName": "freeCodeCamp.org", "publishedTime": "2019-05-15T15:47:20.000Z", "id": "4476f0d4570bd222a1d4f7734980ab29f1cfff2c", "url": "https://www.freecodecamp.org/news/how-to-convert-from-react-redux-classes-to-react-hooks-the-easy-way-eca2233e0e7a/", "domain": "freecodecamp.org", "date": "2023-12-27T18:09:51.278268", "resultUri": "http://localhost:3000/result/4476f0d4570bd222a1d4f7734980ab29f1cfff2c", "query": {"url": ["https://www.freecodecamp.org/news/how-to-convert-from-react-redux-classes-to-react-hooks-the-easy-way-eca2233e0e7a/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "How to convert from React-Redux classes to React Hooks, the easy way", "description": "Hello everyone! With the recent release of create-react-app v3 and React hooks, I decided to write a tutorial on how to refactor a class component to a functional hooks component. In this tutorial, I will share how I did it. I refer to this as the \u201ceasy way\u201d since it", "url": "https://www.freecodecamp.org/news/how-to-convert-from-react-redux-classes-to-react-hooks-the-easy-way-eca2233e0e7a/", "image": "https://cdn-media-2.freecodecamp.org/w1280/5f9ca26b740569d1a4ca5488.jpg", "image:width": "1280", "image:height": "853"}, "twitter": {"card": "summary_large_image", "title": "How to convert from React-Redux classes to React Hooks, the easy way", "description": "Hello everyone! With the recent release of create-react-app v3 and React hooks, I decided to write a tutorial on how to refactor a class component to a functional hooks component. In this tutorial, I will share how I did it. I refer to this as the \u201ceasy way\u201d since it", "url": "https://www.freecodecamp.org/news/how-to-convert-from-react-redux-classes-to-react-hooks-the-easy-way-eca2233e0e7a/", "image": "https://cdn-media-2.freecodecamp.org/w1280/5f9ca26b740569d1a4ca5488.jpg", "label1": "Written by", "data1": "Mohammad Iqbal", "label2": "Filed under", "data2": "React, Tech, Programming, Productivity, Technology", "site": "@freecodecamp", "creator": "@iqbal125sf"}}}