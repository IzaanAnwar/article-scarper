{"title": "How to choose which validator to use: a comparison between Joi & express-validator", "byline": "Shailesh Shekhawat", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>How to choose which validator to use: a comparison between Joi &amp; express-validator</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>Imagine you have an e-commerce website and you\u2019re allowing users to create accounts using their name and email. You want to make sure they sign up with real names, not something like cool_dud3.</p><p>That's where we use validation to validate inputs and make sure input data follows certain rules.</p><p>In the market, we already have a bunch of validation libraries, but I will compare two important validation libraries: <a href=\"https://github.com/hapijs/joi\" rel=\"noopener\">Joi</a> and <a href=\"https://github.com/express-validator/express-validator\" rel=\"noopener\">express-validator</a> for <strong>express.js based applications</strong>.</p><p>This comparison is useful when you have decided to use external input validation library for your application built on <strong>expressjs </strong>and are somewhat not sure which one to use.</p><h3 id=\"who-is-what\">Who is what?</h3><h4 id=\"joi\">Joi</h4><p>Joi allows you to create <em>blueprints</em> or <em>schemas</em> for JavaScript objects (an object that stores information) to ensure <em>validation</em> of key information.</p><h4 id=\"express-validator\">Express-validator</h4><p><em>express-validator</em> is a set of <a href=\"http://expressjs.com/\" rel=\"noopener\">express.js</a> middlewares that wraps <a href=\"https://github.com/chriso/validator.js\" rel=\"noopener\">validator.js</a> validator and sanitizer functions.</p><p>So by definition, we can say that:</p><ul><li>Joi can be used for creating schemas (just like we use mongoose for creating NoSQL schemas) and you can use it with plain Javascript objects. It's like a plug n play library and is easy to use.</li><li>On the other hand, <em>express-validator </em>uses <a href=\"https://github.com/chriso/validator.js\" rel=\"noopener\">validator.js</a> to validate expressjs routes, and it's mainly built for express.js applications. This makes this library more niche and provides out of box custom validation and sanitization. Also, I find it easy to understand personally :)</li></ul><p>Too many methods and API's for doing certain validation in Joi might make you feel overwhelmed so you might end up closing the tab.</p><p>But I may be wrong \u2014 so let\u2019s keep opinions aside and compare both libraries.</p><h3 id=\"instantiation\">Instantiation</h3><h4 id=\"joi-1\">Joi</h4><p>In<em> </em>Joi<em>, </em>you need to use <code><strong>Joi.object()</strong></code><strong> </strong>to instantiate a Joi schema object to work with.</p><p>All schemas require <code>Joi.object()</code>to process validation and other Joi features.</p><p>You need to separately read <code>req.body</code> , <code>req.params</code> , <code>req.query</code> to request body, params, and query.</p><pre tabindex=\"0\"><code>const Joi = require('joi');\n\nconst schema = Joi.object().keys({\n   // validate fields here\n})</code></pre><h4 id=\"express-validator-1\">Express-validator</h4><p>You can just require <em>express-validator </em>and<em> </em>start using its methods. You don't need to read values from <code>req.body</code> , <code>req.params</code> , and <code>req.query</code> separately.</p><p>You just need to use the <code>param, query, body</code> methods below to validate inputs respectively as you can see here:</p><pre tabindex=\"0\"><code>const {\n  param, query, cookies, header \n  body, validationResult } = require('express-validator/check')\n\napp.post('/user', [   \n    \n// validate fields here\n \n], (req, res) =&gt; {\nconst errors = validationResult(req);\n   \n  if (!errors.isEmpty()) {     \n    return res.status(422).json({ errors: errors.array() });   \n  }\n}</code></pre><h4 id=\"field-is-required\">Field is required</h4><p>Let\u2019s take a very basic example where we want to make sure that a <code>username</code> should be required <code>string</code> and is <code>alphaNumeric</code> with <code>min</code> and <code>max</code> characters.</p><ul><li><strong>Joi:</strong></li></ul><pre tabindex=\"0\"><code>const Joi = require('joi');\nconst schema = Joi.object().keys({\n    username: Joi.string().alphanum().min(3).max(30).required()\n})\n\napp.post('/user', (req, res, next) =&gt; {   \n  const result = Joi.validate(req.body, schema)\n  if (result.error) {\n    return res.status(400).json({ error: result.error });\n  }\n});</code></pre><ul><li><strong>Express-validator</strong></li></ul><pre tabindex=\"0\"><code>const { body, validationResult } = require('express-validator/check')\n\napp.post('/user', [   \n body('username')\n  .isString()\n  .isAlphanumeric()\n  .isLength({min: 3, max: 30})\n  .exists(), \n], (req, res) =&gt; {\n  const errors = validationResult(req);\n   \n  if (!errors.isEmpty()) {     \n    return res.status(422).json({ errors: errors.array() });   \n  }\n}</code></pre><h3 id=\"sanitization\">Sanitization</h3><p>Sanitization is basically checking input to make sure it's free of noise, for example, we all have used <code>.trim()</code> on string to remove spaces.</p><p>Or if you have faced a situation where a number is coming in as <code>\"1\"</code> so in those cases, we want to sanitize and convert the type during runtime.</p><p>Sadly, Joi doesn\u2019t provide sanitization out of the box but <em>express-validator </em>does.</p><h4 id=\"example-converting-to-mongodb-s-objectid\">Example: converting to MongoDB\u2019s ObjectID</h4><pre tabindex=\"0\"><code>const { sanitizeParam } = require('express-validator/filter');  \n\napp.post('/object/:id',  \n   sanitizeParam('id')\n  .customSanitizer(value =&gt; {\n     return ObjectId(value); \n}), (req, res) =&gt; {   // Handle the request });</code></pre><h3 id=\"custom-validation\">Custom Validation</h3><h4 id=\"joi-extend-extension-\">Joi: <strong>.extend(</strong><code>extension</code><strong>)</strong></h4><p>This creates a new Joi instance customized with the extension(s) you provide included.</p><p>The extension makes use of some common structures that need to be described first:</p><ul><li><code>value</code> - the value being processed by Joi.</li><li><code>state</code> - an object containing the current context of validation.</li><li><code>key</code> - the key of the current value.</li><li><code>path</code> - the full path of the current value.</li><li><code>parent</code> - the potential parent of the current value.</li><li><code>options</code> - options object provided through <code><a href=\"https://github.com/hapijs/joi/blob/master/API.md#anyoptionsoptions\" rel=\"noopener\">any().options()</a></code> or <code><a href=\"https://github.com/hapijs/joi/blob/master/API.md#validatevalue-schema-options-callback\" rel=\"noopener\">Joi.validate()</a></code>.</li></ul><h4 id=\"extension\">Extension</h4><p><code>extension</code> can be:</p><ul><li>a single extension object</li><li>a factory function generating an extension object</li><li>or an array of those</li></ul><p>Extension objects use the following parameters:</p><ul><li><code>name</code> - name of the new type you are defining, this can be an existing type. Required.</li><li><code>base</code> - an existing Joi schema to base your type on. Defaults to <code>Joi.any()</code>.</li><li><code>coerce</code> - an optional function that runs before the base, usually serves when you want to coerce values of a different type than your base. It takes 3 arguments <code>value</code>, <code>state</code> and <code>options</code>.</li><li><code>pre</code> - an optional function that runs first in the validation chain, usually serves when you need to cast values. It takes 3 arguments <code>value</code>, <code>state</code> and <code>options</code>.</li><li><code>language</code> - an optional object to add error definitions. Every key will be prefixed by the type name.</li><li><code>describe</code> - an optional function taking the fully formed description to post-process it.</li><li><code>rules</code> - an optional array of rules to add.</li><li><code>name</code> - name of the new rule. Required.</li><li><code>params</code> - an optional object containing Joi schemas of each parameter ordered. You can also pass a single Joi schema as long as it is a <code>Joi.object()</code>. Of course some methods such as <code>pattern</code> or <code>rename</code> won't be useful or won't work at all in this given context.</li><li><code>setup</code> - an optional function that takes an object with the provided parameters to allow for internal manipulation of the schema when a rule is set. You can optionally return a new Joi schema that will be taken as the new schema instance. At least one of either <code>setup</code> or <code>validate</code> must be provided.</li><li><code>validate</code> - an optional function to validate values that takes 4 parameters <code>params</code>, <code>value</code>, <code>state</code> and <code>options</code>. At least one of <code>setup</code> or <code>validate</code> must be provided.</li><li><code>description</code> - an optional string or function taking the parameters as an argument to describe what the rule is doing.</li></ul><pre tabindex=\"0\"><code>joi.extend((joi) =&gt; ({\n    base: joi.object().keys({\n        name: joi.string(),\n        age: joi.number(),\n        adult: joi.bool().optional(),\n    }),\n    name: 'person',\n    language: {\n        adult: 'needs to be an adult',\n    },\nrules: [\n        {\n            name: 'adult',\n            validate(params, value, state, options) {\n\n                if (!value.adult) {\n                    // Generate an error, state and options need to be passed\n                    return this.createError('person.adult', {}, state, options);\n                }\n\n                return value; // Everything is OK\n            }\n        }\n    ]\n})</code></pre><h4 id=\"express-validator-2\">Express-validator</h4><p>A custom validator may be implemented by using the chain method <code><a href=\"https://express-validator.github.io/docs/validation-chain-api.html#customvalidator\" rel=\"noopener\">.custom()</a></code>. It takes a validator function.</p><p>Custom validators may return Promises to indicate an async validation (which will be awaited upon), or <code>throw</code> any value/reject a promise to <a href=\"https://express-validator.github.io/docs/custom-error-messages.html#custom-validator-level\" rel=\"noopener\">use a custom error message</a>.</p><pre tabindex=\"0\"><code>const {\n  param, query, cookies, header \n  body, validationResult } = require('express-validator/check')\n\napp.get('/user/:userId', [   \n param('userId')\n  .exists()\n  .isMongoId()\n  .custom(val =&gt; UserSchema.isValidUser(val)), \n], (req, res) =&gt; {\n    \nconst errors = validationResult(req);\n   \n  if (!errors.isEmpty()) {     \n    return res.status(422).json({ errors: errors.array() });   \n  }\n}</code></pre><h3 id=\"conditional-validation\">Conditional Validation</h3><p><em>express-validator </em>does not support conditional validation as of now, but there is a PR for that already you can check <a href=\"https://github.com/express-validator/express-validator/pull/658\" rel=\"noopener\">https://github.com/express-validator/express-validator/pull/658</a></p><p>Let\u2019s see how it works in Joi:</p><h4 id=\"any-when-condition-options-\"><code>any.when(condition, options)</code></h4><p><code><strong>any:</strong></code><strong> </strong>Generates a schema object that matches any data type.</p><pre tabindex=\"0\"><code>const schema = Joi.object({\n    a: Joi.any().valid('x'),\n    b: Joi.any()\n}).when(\n    Joi.object({ b: Joi.exist() })\n    .unknown(), {\n    then: Joi.object({\n        a: Joi.valid('y')\n    }),\n    otherwise: Joi.object({\n        a: Joi.valid('z')\n    })\n});</code></pre><h4 id=\"alternatives-when-condition-options-\"><code>alternatives.when(condition, options)</code></h4><p>Adds a conditional alternative schema type, either based on another key (not the same as <code>any.when()</code>) value, or a schema peeking into the current value, where:</p><ul><li><code>condition</code> - the key name or <a href=\"https://github.com/hapijs/joi/blob/master/API.md#refkey-options\" rel=\"noopener\">reference</a>, or a schema.</li><li><code>options</code> - an object with:</li><li><code>is</code> - the required condition joi type. Forbidden when <code>condition</code> is a schema.</li><li><code>then</code> - the alternative schema type to try if the condition is true. Required if <code>otherwise</code> is missing.</li><li><code>otherwise</code> - the alternative schema type to try if the condition is false. Required if <code>then</code> is missing.</li></ul><pre tabindex=\"0\"><code>const schema = Joi\n     .alternatives()\n     .when(Joi.object({ b: 5 }).unknown(), {\n        then: Joi.object({\n           a: Joi.string(),\n           b: Joi.any()\n      }),\n      otherwise: Joi.object({\n        a: Joi.number(),\n        b: Joi.any()\n      })\n});</code></pre><h3 id=\"nested-validation\">Nested Validation</h3><p>When you want to validate an array of objects/items or just object keys</p><p>Both libraries support nested validation</p><p>Now what about express-validator?</p><h4 id=\"wildcards\">Wildcards</h4><p>Wildcards allow you to iterate over an array of items or object keys and validate each item or its properties.</p><p>The <code>*</code> character is also known as a wildcard.</p><pre tabindex=\"0\"><code>const express = require('express'); \nconst { check } = require('express-validator/check'); \nconst { sanitize } = require('express-validator/filter');  \nconst app = express(); \n\napp.use(express.json());  \napp.post('/addresses', [   \n    check('addresses.*.postalCode').isPostalCode(),\n    sanitize('addresses.*.number').toInt() \n], \n(req, res) =&gt; {   // Handle the request });</code></pre><pre tabindex=\"0\"><code>const schema = Joi.object().keys({\n    addresses: Joi.array().items(\n        Joi.object().keys({\n            postalCode: Joi.string().required(),\n        }),\n    )\n});</code></pre><h3 id=\"custom-error-messages\">Custom Error Messages</h3><h4 id=\"joi-2\">Joi</h4><h4 id=\"any-error-err-options-\"><code>any.error(err, [options])</code></h4><p>Overrides the default joi error with a custom error</p><pre tabindex=\"0\"><code>let schema = Joi.string().error(new Error('Was REALLY expecting a string'));</code></pre><h4 id=\"express-validator-3\">Express-validator</h4><pre tabindex=\"0\"><code>const { check } = require('express-validator/check'); \n\napp.post('/user', [   \n   // ...some other validations...   \n   check('password')     \n   .isLength({ min: 5 }).withMessage('must be at 5 chars long')\n   .matches(/\\d/).withMessage('must contain a number') \n], \n(req, res) =&gt; {   // Handle the request somehow });</code></pre><h3 id=\"conclusion\">Conclusion</h3><p>I covered the most important parts of both libraries and you can decide yourself which one you want to use. Please let me know in the comments below if I left out anything important in the comparison.</p><p>I hope you find it helpful when deciding the next input validation module for your express.js application.</p><p>I wrote an in-depth article on it here: <a href=\"https://medium.freecodecamp.org/how-to-make-input-validation-simple-and-clean-in-your-express-js-app-ea9b5ff5a8a7\" rel=\"noopener\">how to validate inputs</a>. Do check it out.</p><p><em>Don\u2019t hesitate to clap if you considered this a worthwhile read!</em></p><p><em>Originally published at <a href=\"https://101node.io/blog/javascript-validators-comparison-using-joi-vs-express-validator/\" rel=\"noopener\">101node.io</a> on March 31, 2019.</em></p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nImagine you have an e-commerce website and you\u2019re allowing users to create accounts using their name and email. You want to make sure they sign up with real names, not something like cool_dud3.That's where we use validation to validate inputs and make sure input data follows certain rules.In the market, we already have a bunch of validation libraries, but I will compare two important validation libraries: Joi and express-validator for express.js based applications.This comparison is useful when you have decided to use external input validation library for your application built on expressjs and are somewhat not sure which one to use.Who is what?JoiJoi allows you to create blueprints or schemas for JavaScript objects (an object that stores information) to ensure validation of key information.Express-validatorexpress-validator is a set of express.js middlewares that wraps validator.js validator and sanitizer functions.So by definition, we can say that:Joi can be used for creating schemas (just like we use mongoose for creating NoSQL schemas) and you can use it with plain Javascript objects. It's like a plug n play library and is easy to use.On the other hand, express-validator uses validator.js to validate expressjs routes, and it's mainly built for express.js applications. This makes this library more niche and provides out of box custom validation and sanitization. Also, I find it easy to understand personally :)Too many methods and API's for doing certain validation in Joi might make you feel overwhelmed so you might end up closing the tab.But I may be wrong \u2014 so let\u2019s keep opinions aside and compare both libraries.InstantiationJoiIn Joi, you need to use Joi.object() to instantiate a Joi schema object to work with.All schemas require Joi.object()to process validation and other Joi features.You need to separately read req.body , req.params , req.query to request body, params, and query.const Joi = require('joi');\n\nconst schema = Joi.object().keys({\n   // validate fields here\n})Express-validatorYou can just require express-validator and start using its methods. You don't need to read values from req.body , req.params , and req.query separately.You just need to use the param, query, body methods below to validate inputs respectively as you can see here:const {\n  param, query, cookies, header \n  body, validationResult } = require('express-validator/check')\n\napp.post('/user', [   \n    \n// validate fields here\n \n], (req, res) => {\nconst errors = validationResult(req);\n   \n  if (!errors.isEmpty()) {     \n    return res.status(422).json({ errors: errors.array() });   \n  }\n}Field is requiredLet\u2019s take a very basic example where we want to make sure that a username should be required string and is alphaNumeric with min and max characters.Joi:const Joi = require('joi');\nconst schema = Joi.object().keys({\n    username: Joi.string().alphanum().min(3).max(30).required()\n})\n\napp.post('/user', (req, res, next) => {   \n  const result = Joi.validate(req.body, schema)\n  if (result.error) {\n    return res.status(400).json({ error: result.error });\n  }\n});Express-validatorconst { body, validationResult } = require('express-validator/check')\n\napp.post('/user', [   \n body('username')\n  .isString()\n  .isAlphanumeric()\n  .isLength({min: 3, max: 30})\n  .exists(), \n], (req, res) => {\n  const errors = validationResult(req);\n   \n  if (!errors.isEmpty()) {     \n    return res.status(422).json({ errors: errors.array() });   \n  }\n}SanitizationSanitization is basically checking input to make sure it's free of noise, for example, we all have used .trim() on string to remove spaces.Or if you have faced a situation where a number is coming in as \"1\" so in those cases, we want to sanitize and convert the type during runtime.Sadly, Joi doesn\u2019t provide sanitization out of the box but express-validator does.Example: converting to MongoDB\u2019s ObjectIDconst { sanitizeParam } = require('express-validator/filter');  \n\napp.post('/object/:id',  \n   sanitizeParam('id')\n  .customSanitizer(value => {\n     return ObjectId(value); \n}), (req, res) => {   // Handle the request });Custom ValidationJoi: .extend(extension)This creates a new Joi instance customized with the extension(s) you provide included.The extension makes use of some common structures that need to be described first:value - the value being processed by Joi.state - an object containing the current context of validation.key - the key of the current value.path - the full path of the current value.parent - the potential parent of the current value.options - options object provided through any().options() or Joi.validate().Extensionextension can be:a single extension objecta factory function generating an extension objector an array of thoseExtension objects use the following parameters:name - name of the new type you are defining, this can be an existing type. Required.base - an existing Joi schema to base your type on. Defaults to Joi.any().coerce - an optional function that runs before the base, usually serves when you want to coerce values of a different type than your base. It takes 3 arguments value, state and options.pre - an optional function that runs first in the validation chain, usually serves when you need to cast values. It takes 3 arguments value, state and options.language - an optional object to add error definitions. Every key will be prefixed by the type name.describe - an optional function taking the fully formed description to post-process it.rules - an optional array of rules to add.name - name of the new rule. Required.params - an optional object containing Joi schemas of each parameter ordered. You can also pass a single Joi schema as long as it is a Joi.object(). Of course some methods such as pattern or rename won't be useful or won't work at all in this given context.setup - an optional function that takes an object with the provided parameters to allow for internal manipulation of the schema when a rule is set. You can optionally return a new Joi schema that will be taken as the new schema instance. At least one of either setup or validate must be provided.validate - an optional function to validate values that takes 4 parameters params, value, state and options. At least one of setup or validate must be provided.description - an optional string or function taking the parameters as an argument to describe what the rule is doing.Example:joi.extend((joi) => ({\n    base: joi.object().keys({\n        name: joi.string(),\n        age: joi.number(),\n        adult: joi.bool().optional(),\n    }),\n    name: 'person',\n    language: {\n        adult: 'needs to be an adult',\n    },\nrules: [\n        {\n            name: 'adult',\n            validate(params, value, state, options) {\n\n                if (!value.adult) {\n                    // Generate an error, state and options need to be passed\n                    return this.createError('person.adult', {}, state, options);\n                }\n\n                return value; // Everything is OK\n            }\n        }\n    ]\n})Express-validatorA custom validator may be implemented by using the chain method .custom(). It takes a validator function.Custom validators may return Promises to indicate an async validation (which will be awaited upon), or throw any value/reject a promise to use a custom error message.const {\n  param, query, cookies, header \n  body, validationResult } = require('express-validator/check')\n\napp.get('/user/:userId', [   \n param('userId')\n  .exists()\n  .isMongoId()\n  .custom(val => UserSchema.isValidUser(val)), \n], (req, res) => {\n    \nconst errors = validationResult(req);\n   \n  if (!errors.isEmpty()) {     \n    return res.status(422).json({ errors: errors.array() });   \n  }\n}Conditional Validationexpress-validator does not support conditional validation as of now, but there is a PR for that already you can check https://github.com/express-validator/express-validator/pull/658Let\u2019s see how it works in Joi:any.when(condition, options)any: Generates a schema object that matches any data type.const schema = Joi.object({\n    a: Joi.any().valid('x'),\n    b: Joi.any()\n}).when(\n    Joi.object({ b: Joi.exist() })\n    .unknown(), {\n    then: Joi.object({\n        a: Joi.valid('y')\n    }),\n    otherwise: Joi.object({\n        a: Joi.valid('z')\n    })\n});alternatives.when(condition, options)Adds a conditional alternative schema type, either based on another key (not the same as any.when()) value, or a schema peeking into the current value, where:condition - the key name or reference, or a schema.options - an object with:is - the required condition joi type. Forbidden when condition is a schema.then - the alternative schema type to try if the condition is true. Required if otherwise is missing.otherwise - the alternative schema type to try if the condition is false. Required if then is missing.const schema = Joi\n     .alternatives()\n     .when(Joi.object({ b: 5 }).unknown(), {\n        then: Joi.object({\n           a: Joi.string(),\n           b: Joi.any()\n      }),\n      otherwise: Joi.object({\n        a: Joi.number(),\n        b: Joi.any()\n      })\n});Nested ValidationWhen you want to validate an array of objects/items or just object keysBoth libraries support nested validationNow what about express-validator?WildcardsWildcards allow you to iterate over an array of items or object keys and validate each item or its properties.The * character is also known as a wildcard.const express = require('express'); \nconst { check } = require('express-validator/check'); \nconst { sanitize } = require('express-validator/filter');  \nconst app = express(); \n\napp.use(express.json());  \napp.post('/addresses', [   \n    check('addresses.*.postalCode').isPostalCode(),\n    sanitize('addresses.*.number').toInt() \n], \n(req, res) => {   // Handle the request });Joiconst schema = Joi.object().keys({\n    addresses: Joi.array().items(\n        Joi.object().keys({\n            postalCode: Joi.string().required(),\n        }),\n    )\n});Custom Error MessagesJoiany.error(err, [options])Overrides the default joi error with a custom errorlet schema = Joi.string().error(new Error('Was REALLY expecting a string'));Express-validatorconst { check } = require('express-validator/check'); \n\napp.post('/user', [   \n   // ...some other validations...   \n   check('password')     \n   .isLength({ min: 5 }).withMessage('must be at 5 chars long')\n   .matches(/\\d/).withMessage('must contain a number') \n], \n(req, res) => {   // Handle the request somehow });ConclusionI covered the most important parts of both libraries and you can decide yourself which one you want to use. Please let me know in the comments below if I left out anything important in the comparison.I hope you find it helpful when deciding the next input validation module for your express.js application.I wrote an in-depth article on it here: how to validate inputs. Do check it out.Don\u2019t hesitate to clap if you considered this a worthwhile read!Originally published at 101node.io on March 31, 2019.\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 11678, "excerpt": "Imagine you have an e-commerce website and you\u2019re allowing users to create\naccounts using their name and email. You want to make sure they sign up with\nreal names, not something like cool_dud3.\n\nThat's where we use validation to validate inputs and make sure input data\nfollows certain rules.\n\nIn the market, we already have a bunch of validation libraries, but I will\ncompare two important validation libraries: Joi [https://github.com/hapijs/joi] \nand express-validator [https://github.com/express-", "siteName": "freeCodeCamp.org", "publishedTime": "2019-05-09T16:28:17.000Z", "id": "dd63ed763046bc29f0932db1f517445e9bc0e99d", "url": "https://www.freecodecamp.org/news/how-to-choose-which-validator-to-use-a-comparison-between-joi-express-validator-ac0b910c1a8c/", "domain": "freecodecamp.org", "date": "2023-12-27T18:10:14.231270", "resultUri": "http://localhost:3000/result/dd63ed763046bc29f0932db1f517445e9bc0e99d", "query": {"url": ["https://www.freecodecamp.org/news/how-to-choose-which-validator-to-use-a-comparison-between-joi-express-validator-ac0b910c1a8c/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "How to choose which validator to use: a comparison between Joi & express-validator", "description": "Imagine you have an e-commerce website and you\u2019re allowing users to create accounts using their name and email. You want to make sure they sign up with real names, not something like cool_dud3. That's where we use validation to validate inputs and make sure input data follows certain rules. In", "url": "https://www.freecodecamp.org/news/how-to-choose-which-validator-to-use-a-comparison-between-joi-express-validator-ac0b910c1a8c/", "image": "https://cdn-media-1.freecodecamp.org/images/1*s3Fzn57ud8r82T56w9biWg.png", "image:width": "800", "image:height": "670"}, "twitter": {"card": "summary_large_image", "title": "How to choose which validator to use: a comparison between Joi & express-validator", "description": "Imagine you have an e-commerce website and you\u2019re allowing users to create accounts using their name and email. You want to make sure they sign up with real names, not something like cool_dud3. That's where we use validation to validate inputs and make sure input data follows certain rules. In", "url": "https://www.freecodecamp.org/news/how-to-choose-which-validator-to-use-a-comparison-between-joi-express-validator-ac0b910c1a8c/", "image": "https://cdn-media-1.freecodecamp.org/images/1*s3Fzn57ud8r82T56w9biWg.png", "label1": "Written by", "data1": "Shailesh Shekhawat", "label2": "Filed under", "data2": "JavaScript, Nodejs, Expressjs, Tech, Programming", "site": "@freecodecamp", "creator": "@thatshailesh"}}}