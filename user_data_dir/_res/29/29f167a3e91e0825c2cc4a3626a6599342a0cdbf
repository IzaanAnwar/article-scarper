{"title": "A basic guide to Closures in JavaScript", "byline": "Parathan Thiyagalingam", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>A basic guide to Closures in JavaScript</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>The Closure is a collection of all variables in scope at the time of function creation. To use closure, create a function inside another function which is called a Nested Function. The inner function will have access to the variables in the outer function scope (<strong>Closure</strong> helps to access the outer function scope), even after the outer function has returned. Closures are created every time a function is created.</p><p>Before moving on to understand about Closures, let\u2019s first get the big picture about Scope Chain in JavaScript.</p><p>Normally, there are 2 types of scope:</p><ul><li>Global Scope</li><li>Local Scope</li></ul><p>In ES5 version, a variable inside a function is not visible outside. But variables inside a block (conditions like if or while) are visible outside too.</p><p>From this, ES5 has function scope. There is no block scope.</p><blockquote>Edited on: 9th May 2019</blockquote><blockquote>According to <strong>ES5</strong>, using functions were the only way to declare a block scope in code.</blockquote><blockquote>But, in ES6 it was eased by <strong>let</strong> &amp; <strong>const</strong> keywords which provides block scope.</blockquote><blockquote>Anyhow, Its better to have a knowledge on how JavaScript evolved step by step.</blockquote><p>Lets continue this in ES5 version :</p><pre tabindex=\"0\"><code>var a = 10;\nfunction app(){\n   var b = 2;\n   console.log(a); // 10\n   console.log(b); // 2\n}\nconsole.log(b); //   ReferenceError: b is not defined\napp();</code></pre><p>As we already know, <strong>a</strong> is a Global variable &amp; <strong>b</strong> is a local variable which is <strong>specific </strong>to the app function.</p><p>We can\u2019t get the value of a local variable out of the local scope.</p><h4 id=\"using-a-nested-function-function-inside-a-function\">Using a Nested Function \u2014 Function inside a Function</h4><pre tabindex=\"0\"><code>var a = 10;\nfunction app(){\n     var b = 2;\n     var d = 3;\n  function add(){\n     var c = a + b;\n   }\n return add;\n}\nvar x = app();\nconsole.dir(x);</code></pre><p>Here, the app is the parent function &amp; add function is the child function.</p><ul><li>Rather than using console.log, <strong>console.dir</strong> is used to console all the properties of a specified JavaScript object which helps developers get the properties of that object</li><li>Variable x is assigned to app function &amp; the app function returns the add function. Therefore we could see all the object properties of the add function.</li></ul><p>If you see the console in the browser, you could see the Closure object inside the Scopes array.</p><figure><img alt=\"QT8fuXZHAuL9OPxS3M2v7nI2hF7c4rX1zt3U\" height=\"252\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/QT8fuXZHAuL9OPxS3M2v7nI2hF7c4rX1zt3U\" width=\"800\"/></figure><p>Since the inner<strong> function add</strong> accesses the outer function variables <strong>b &amp; d</strong>, those 2 variables will be added to the Closure object for the reference.</p><p>Let\u2019s have look at the next example for Closure:</p><pre tabindex=\"0\"><code>var a = 10;\nvar startFunc;\nfunction app(){\n      var b = 2;\n   function add(){\n      var c = a + b;\n      console.log(c);\n   }\n   startFunc = add();\n}\napp(); // Invoke the app function\nstartFunc; \n// as the app function invoked above will assign the add function to startFunc &amp; console the value of c</code></pre><ul><li>a Global function called startFunc is assigned to the add function which is a child function of the parent app function.</li><li>This is possible only after the app function is invoked, otherwise startFunc will act as a global variable without any value assigned</li></ul><h4 id=\"application-of-closures-in-javascript\">Application of Closures in JavaScript</h4><p>Most of us use Closures while coding but we don\u2019t get why we are using it. JavaScript doesn\u2019t have the access modifiers like <strong>private, public, protected</strong> like other Object Oriented Programming Languages. So, we have to use functions to protect the namespace from the outside code usage in ES5.</p><p>Especially in functions, <strong>Immediately-invoked Function Expression (IIFE) </strong>is the one which is executed immediately after the declaration. You don\u2019t need to invoke the function after the function is declared.</p><p>IIFE enables to write <strong>Module Pattern</strong> (one of the Design Pattern) in JavaScript.</p><p>Syntax definition of IIFE is:</p><pre><code>(function(){\n             //variables &amp; scope that inside the function \n})();</code></pre><p>Let\u2019s have an example:</p><pre tabindex=\"0\"><code>var studnetEnrollment = (function () {\n    //private variables which no one can change\n    //except the function declared below.\n     var count = 0;\n     var prefix = \"S\";\n    // returning a named function expression\n     function innerFunc() {\n         count = count + 1;\n         return prefix + count;\n     };\n return innerFunc;\n})();\nvar x = studnetEnrollment(); // S1\nconsole.log(x);\nvar y = studnetEnrollment(); // S2 \nconsole.log(y);</code></pre><p>count &amp; prefix are the 2 private variables which can\u2019t be changed by anyone &amp; can only be accessible to the inner function (here its innerFunc). This access is possible only by the feature called Closure.</p><ul><li>At the first time, when the studentEnrollment function is called, the count variable inside the function is incremented 1 by innerFunc function.</li><li>At the second time, the count is incremented the previous value of count which is 1 to 2</li><li>These are possible by the Closure feature.</li></ul><h4 id=\"conclusion\">Conclusion</h4><p>The Closure is a collection of variables in an outer function which gives access to the inner function scope to protect the global namespace.</p><p>Closures enable developers to write clean code like OOP Languages which doesn\u2019t confuse the global &amp; local variable names in ES5 version.</p><p>Happy Coding\u2026\u2026.!!!!!</p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nThe Closure is a collection of all variables in scope at the time of function creation. To use closure, create a function inside another function which is called a Nested Function. The inner function will have access to the variables in the outer function scope (Closure helps to access the outer function scope), even after the outer function has returned. Closures are created every time a function is created.Before moving on to understand about Closures, let\u2019s first get the big picture about Scope Chain in JavaScript.Normally, there are 2 types of scope:Global ScopeLocal ScopeIn ES5 version, a variable inside a function is not visible outside. But variables inside a block (conditions like if or while) are visible outside too.From this, ES5 has function scope. There is no block scope.Edited on: 9th May 2019According to ES5, using functions were the only way to declare a block scope in code.But, in ES6 it was eased by let & const keywords which provides block scope.Anyhow, Its better to have a knowledge on how JavaScript evolved step by step.Lets continue this in ES5 version :var a = 10;\nfunction app(){\n   var b = 2;\n   console.log(a); // 10\n   console.log(b); // 2\n}\nconsole.log(b); //   ReferenceError: b is not defined\napp();As we already know, a is a Global variable & b is a local variable which is specific to the app function.We can\u2019t get the value of a local variable out of the local scope.Using a Nested Function \u2014 Function inside a Functionvar a = 10;\nfunction app(){\n     var b = 2;\n     var d = 3;\n  function add(){\n     var c = a + b;\n   }\n return add;\n}\nvar x = app();\nconsole.dir(x);Here, the app is the parent function & add function is the child function.Rather than using console.log, console.dir is used to console all the properties of a specified JavaScript object which helps developers get the properties of that objectVariable x is assigned to app function & the app function returns the add function. Therefore we could see all the object properties of the add function.If you see the console in the browser, you could see the Closure object inside the Scopes array.Since the inner function add accesses the outer function variables b & d, those 2 variables will be added to the Closure object for the reference.Let\u2019s have look at the next example for Closure:var a = 10;\nvar startFunc;\nfunction app(){\n      var b = 2;\n   function add(){\n      var c = a + b;\n      console.log(c);\n   }\n   startFunc = add();\n}\napp(); // Invoke the app function\nstartFunc; \n// as the app function invoked above will assign the add function to startFunc & console the value of ca Global function called startFunc is assigned to the add function which is a child function of the parent app function.This is possible only after the app function is invoked, otherwise startFunc will act as a global variable without any value assignedApplication of Closures in JavaScriptMost of us use Closures while coding but we don\u2019t get why we are using it. JavaScript doesn\u2019t have the access modifiers like private, public, protected like other Object Oriented Programming Languages. So, we have to use functions to protect the namespace from the outside code usage in ES5.Especially in functions, Immediately-invoked Function Expression (IIFE) is the one which is executed immediately after the declaration. You don\u2019t need to invoke the function after the function is declared.IIFE enables to write Module Pattern (one of the Design Pattern) in JavaScript.Syntax definition of IIFE is:(function(){\n             //variables & scope that inside the function \n})();Let\u2019s have an example:var studnetEnrollment = (function () {\n    //private variables which no one can change\n    //except the function declared below.\n     var count = 0;\n     var prefix = \"S\";\n    // returning a named function expression\n     function innerFunc() {\n         count = count + 1;\n         return prefix + count;\n     };\n return innerFunc;\n})();\nvar x = studnetEnrollment(); // S1\nconsole.log(x);\nvar y = studnetEnrollment(); // S2 \nconsole.log(y);count & prefix are the 2 private variables which can\u2019t be changed by anyone & can only be accessible to the inner function (here its innerFunc). This access is possible only by the feature called Closure.At the first time, when the studentEnrollment function is called, the count variable inside the function is incremented 1 by innerFunc function.At the second time, the count is incremented the previous value of count which is 1 to 2These are possible by the Closure feature.ConclusionThe Closure is a collection of variables in an outer function which gives access to the inner function scope to protect the global namespace.Closures enable developers to write clean code like OOP Languages which doesn\u2019t confuse the global & local variable names in ES5 version.Happy Coding\u2026\u2026.!!!!!\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 5509, "excerpt": "The Closure is a collection of all variables in scope at the time of function\ncreation. To use closure, create a function inside another function which is\ncalled a Nested Function. The inner function will have access to the variables\nin the outer function scope (Closure helps to access the outer function scope),\neven after the outer function has returned. Closures are created every time a\nfunction is created.\n\nBefore moving on to understand about Closures, let\u2019s first get the big picture\nabout S", "siteName": "freeCodeCamp.org", "publishedTime": "2019-05-03T18:47:26.000Z", "id": "29f167a3e91e0825c2cc4a3626a6599342a0cdbf", "url": "https://www.freecodecamp.org/news/a-basic-guide-to-closures-in-javascript-9fc8b7e3463e/", "domain": "freecodecamp.org", "date": "2023-12-27T18:10:39.582202", "resultUri": "http://localhost:3000/result/29f167a3e91e0825c2cc4a3626a6599342a0cdbf", "query": {"url": ["https://www.freecodecamp.org/news/a-basic-guide-to-closures-in-javascript-9fc8b7e3463e/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "A basic guide to Closures in JavaScript", "description": "The Closure is a collection of all variables in scope at the time of function creation. To use closure, create a function inside another function which is called a Nested Function. The inner function will have access to the variables in the outer function scope (Closure helps to access the", "url": "https://www.freecodecamp.org/news/a-basic-guide-to-closures-in-javascript-9fc8b7e3463e/", "image": "https://cdn-media-1.freecodecamp.org/images/1*Nm0GW5PgM1okjXAZz_aQrQ.jpeg", "image:width": "800", "image:height": "582"}, "twitter": {"card": "summary_large_image", "title": "A basic guide to Closures in JavaScript", "description": "The Closure is a collection of all variables in scope at the time of function creation. To use closure, create a function inside another function which is called a Nested Function. The inner function will have access to the variables in the outer function scope (Closure helps to access the", "url": "https://www.freecodecamp.org/news/a-basic-guide-to-closures-in-javascript-9fc8b7e3463e/", "image": "https://cdn-media-1.freecodecamp.org/images/1*Nm0GW5PgM1okjXAZz_aQrQ.jpeg", "label1": "Written by", "data1": "Parathan Thiyagalingam", "label2": "Filed under", "data2": "JavaScript, ES6, Tech, Programming, Web Development", "site": "@freecodecamp", "creator": "@parathantl"}}}