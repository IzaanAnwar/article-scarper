{"title": "How to Handle Exceptions in Python: A Detailed Visual Introduction", "byline": "Estefania Cassingena Navone", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>How to Handle Exceptions in Python: A Detailed Visual Introduction</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>Welcome! In this article, you will learn how to handle exceptions in Python.</p><p><strong>In particular, we will cover:</strong></p><ul><li>Exceptions</li><li>The purpose of exception handling</li><li>The try clause</li><li>The except clause</li><li>The else clause</li><li>The finally clause</li><li>How to raise exceptions</li></ul><p><strong>Are you ready? Let's begin! \ud83d\ude00</strong></p><h2 id=\"1-intro-to-exceptions\">1\ufe0f\u20e3 Intro to Exceptions</h2><p>We will start with exceptions:</p><ul><li><strong>What </strong>are they? </li><li><strong>Why </strong>are they relevant? </li><li><strong>Why </strong>should you handle them?</li></ul><p>According to the <a href=\"https://docs.python.org/3/tutorial/errors.html#exceptions\">Python documentation</a>:</p><blockquote>Errors detected during execution are called <strong><em>exceptions</em> </strong>and are not unconditionally fatal.</blockquote><p><strong>Exceptions are raised when the program encounters an error during its execution.</strong> They disrupt the normal flow of the program and usually end it abruptly. To avoid this, you can catch them and handle them appropriately.</p><p>You've probably seen them during your programming projects. </p><p>If you've ever tried to divide by zero in Python, you must have seen this error message:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; a = 5/0\nTraceback (most recent call last):\n  File \"&lt;pyshell#1&gt;\", line 1, in &lt;module&gt;\n    a = 5/0\nZeroDivisionError: division by zero</code></pre><p>If you tried to index a string with an invalid index, you definitely got this error message:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; a = \"Hello, World\"\n&gt;&gt;&gt; a[456]\nTraceback (most recent call last):\n  File \"&lt;pyshell#3&gt;\", line 1, in &lt;module&gt;\n    a[456]\nIndexError: string index out of range</code></pre><p>These are examples of exceptions.</p><h3 id=\"-common-exceptions\">\ud83d\udd39 Common Exceptions</h3><p>There are many different types of exceptions, and they are all raised in particular situations. Some of the exceptions that you will most likely see as you work on your projects are:</p><ul><li><strong>IndexError</strong> - raised when you try to index a list, tuple, or string beyond the permitted boundaries. For example:</li></ul><pre tabindex=\"0\"><code>&gt;&gt;&gt; num = [1, 2, 6, 5]\n&gt;&gt;&gt; num[56546546]\nTraceback (most recent call last):\n  File \"&lt;pyshell#7&gt;\", line 1, in &lt;module&gt;\n    num[56546546]\nIndexError: list index out of range</code></pre><ul><li><strong>KeyError </strong>- raised when you try to access the value of a key that doesn't exist in a dictionary. For example:</li></ul><pre tabindex=\"0\"><code>&gt;&gt;&gt; students = {\"Nora\": 15, \"Gino\": 30}\n&gt;&gt;&gt; students[\"Lisa\"]\nTraceback (most recent call last):\n  File \"&lt;pyshell#9&gt;\", line 1, in &lt;module&gt;\n    students[\"Lisa\"]\nKeyError: 'Lisa'</code></pre><ul><li><strong>NameError</strong> - raised when a name that you are referencing in the code doesn't exist. For example:</li></ul><pre tabindex=\"0\"><code>&gt;&gt;&gt; a = b\nTraceback (most recent call last):\n  File \"&lt;pyshell#10&gt;\", line 1, in &lt;module&gt;\n    a = b\nNameError: name 'b' is not defined</code></pre><ul><li><strong>TypeError</strong> - raised when an operation or function is applied to an object of an inappropriate type. For example:</li></ul><pre tabindex=\"0\"><code>&gt;&gt;&gt; (5, 6, 7) * (1, 2, 3)\nTraceback (most recent call last):\n  File \"&lt;pyshell#12&gt;\", line 1, in &lt;module&gt;\n    (5, 6, 7) * (1, 2, 3)\nTypeError: can't multiply sequence by non-int of type 'tuple'</code></pre><ul><li><strong>ZeroDivisionError </strong>- raised when you try to divide by zero.</li></ul><pre tabindex=\"0\"><code>&gt;&gt;&gt; a = 5/0\nTraceback (most recent call last):\n  File \"&lt;pyshell#13&gt;\", line 1, in &lt;module&gt;\n    a = 5/0\nZeroDivisionError: division by zero</code></pre><p>\ud83d\udca1 <strong>Tips:</strong> To learn more about other types of built-in exceptions, please <a href=\"https://docs.python.org/3/library/exceptions.html\">refer to this article</a> in the Python Documentation.</p><h3 id=\"-anatomy-of-an-exception\">\ud83d\udd38 <strong>Anatomy of an Exception</strong></h3><p>I'm sure that you must have noticed a general pattern in these error messages. Let's break down their general structure piece by piece:</p><figure><img alt=\"image-8\" height=\"351\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2019/12/image-8.png\" width=\"813\"/></figure><p>First, we find this line (see below). A <strong>traceback </strong>is basically a list detailing the function calls that were made before the exception was raised. </p><p>The traceback helps you during the debugging process because you can analyze the sequence of function calls that resulted in the exception:</p><pre tabindex=\"0\"><code>Traceback (most recent call last):</code></pre><p>Then, we see this line (see below) with the path to the file and the line that raised the exception. In this case, the path was the Python shell &lt;pyshell#0&gt; since the example was executed directly in IDLE.</p><pre tabindex=\"0\"><code>File \"&lt;pyshell#0&gt;\", line 1, in &lt;module&gt;\n   a - 5/0</code></pre><p><strong>\ud83d\udca1 Tip:</strong> If the line that raised the exception belongs to a function, &lt;module&gt; \u00a0is replaced by the name of the function.</p><p>Finally, we see a descriptive message detailing the type of exception and providing additional information to help us debug the code:</p><pre><code>NameError: name 'a' is not defined</code></pre><h2 id=\"2-exception-handling-purpose-context\">2\ufe0f\u20e3 Exception Handling: Purpose &amp; Context</h2><p>You may ask: why would I want to handle exceptions? Why is this helpful for me? By handling exceptions, you can provide an alternative flow of execution to avoid crashing your program unexpectedly.</p><h3 id=\"-example-user-input\">\ud83d\udd39 Example: User Input</h3><p>Imagine what would happen if a user who is working with your program enters an invalid input. This would raise an exception because an invalid operation was performed during the process. </p><p>If your program doesn't handle this correctly, it will crash suddenly and the user will have a very disappointing experience with your product.</p><p><strong>But if you do handle the exception, you will be able to provide an alternative to improve the experience of the user.</strong> </p><p>Perhaps you could display a descriptive message asking the user to enter a valid input, or you could provide a default value for the input. Depending on the context, you can choose what to do when this happens, and this is the magic of error handling. It can save the day when unexpected things happen. \u2b50\ufe0f</p><h3 id=\"-what-happens-behind-the-scenes\">\ud83d\udd38 What Happens Behind the Scenes?</h3><p>Basically, when we handle an exception, we are telling the program what to do if the exception is raised. In that case, the \"alternative\" flow of execution will come to the rescue. If no exceptions are raised, the code will run as expected.</p><figure><img alt=\"image-10\" height=\"440\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2019/12/image-10.png\" width=\"729\"/></figure><h2 id=\"3-time-to-code-the-try-except-statement\">3\ufe0f\u20e3 Time to Code: The try ... except Statement</h2><p>Now that you know what exceptions are and why you should we handle them, we will start diving into the built-in tools that the Python languages offers for this purpose. </p><p><strong>First, we have the most basic statement: try ... except.</strong></p><p>Let's illustrate this with a simple example. We have this small program that asks the user to enter the name of a student to display his/her age:</p><pre tabindex=\"0\"><code>students = {\"Nora\": 15, \"Gino\": 30}\n\ndef print_student_age():\n    name = input(\"Please enter the name of the student: \")\n    print(students[name])\n\nprint_student_age()</code></pre><p>Notice how we are not validating user input at the moment, so the user might enter invalid values (names that are not in the dictionary) and the consequences would be catastrophic because the program would crash if a KeyError is raised:</p><pre tabindex=\"0\"><code># User Input\nPlease enter the name of the student: \"Daniel\"\n\n# Error Message\nTraceback (most recent call last):\n  File \"&lt;path&gt;\", line 15, in &lt;module&gt;\n    print_student_age()\n  File \"&lt;path&gt;\", line 13, in print_student_age\n    print(students[name])\nKeyError: '\"Daniel\"'</code></pre><h3 id=\"-syntax\">\ud83d\udd39 Syntax</h3><p>We can handle this nicely using try ... except. This is the basic syntax:</p><figure><img alt=\"image-11\" height=\"317\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2019/12/image-11.png\" width=\"854\"/></figure><p>In our example, we would add the try ... except statement within the function. Let's break this down piece by piece:</p><pre tabindex=\"0\"><code>students = {\"Nora\": 15, \"Gino\": 30}\n\ndef print_student_age():\n    while True:\n        try:\n            name = input(\"Please enter the name of the student: \")\n            print(students[name])\n            break\n        except:\n            print(\"This name is not registered\")\n    \n\nprint_student_age()</code></pre><p>If we \"zoom in\", we see the try ... except statement:</p><pre><code>try:\n\tname = input(\"Please enter the name of the student: \")\n\tprint(students[name])\n\tbreak\nexcept:\n\tprint(\"This name is not registered\")</code></pre><ul><li>When the function is called, the try clause will run. If no exceptions are raised, the program will run as expected. </li><li>But if an exception is raised in the try clause, the flow of execution will immediately jump to the except clause to handle the exception.</li></ul><p><strong>\ud83d\udca1 Note: </strong>This code is contained within a while loop to continue asking for user input if the value is invalid. This is an example:</p><pre tabindex=\"0\"><code>Please enter the name of the student: \"Lulu\"\nThis name is not registered\nPlease enter the name of the student: </code></pre><p>This is great, right? Now we can continue asking for user input if the value is invalid. </p><p>At the moment, we are handling all possible exceptions with the same except clause. But what if we only want to handle a specific type of exception? Let's see how we could do this.</p><h3 id=\"-catching-specific-exceptions\">\ud83d\udd38 Catching Specific Exceptions</h3><p>Since not all types of exceptions are handled in the same way, we can specify which exceptions we would like to handle with this syntax:</p><figure><img alt=\"image-15\" height=\"325\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2019/12/image-15.png\" width=\"712\"/></figure><p>This is an example. We are handling the ZeroDivisionError exception in case the user enters zero as the denominator:</p><pre tabindex=\"0\"><code>def divide_integers():\n    while True:\n        try:\n            a = int(input(\"Please enter the numerator: \"))\n            b = int(input(\"Please enter the denominator: \"))\n            print(a / b)\n        except ZeroDivisionError:\n            print(\"Please enter a valid denominator.\")\n\n\ndivide_integers()</code></pre><p>This would be the result:</p><pre tabindex=\"0\"><code># First iteration\nPlease enter the numerator: 5\nPlease enter the denominator: 0\nPlease enter a valid denominator. \n\n# Second iteration\nPlease enter the numerator: 5\nPlease enter the denominator: 2\n2.5</code></pre><p>We are handling this correctly. But... if another type of exception is raised, the program will not handle it gracefully. </p><p>Here we have an example of a ValueError because one of the values is a float, not an int:</p><pre tabindex=\"0\"><code>Please enter the numerator: 5\nPlease enter the denominator: 0.5\nTraceback (most recent call last):\n  File \"&lt;path&gt;\", line 53, in &lt;module&gt;\n    divide_integers()\n  File \"&lt;path&gt;\", line 47, in divide_integers\n    b = int(input(\"Please enter the denominator: \"))\nValueError: invalid literal for int() with base 10: '0.5'</code></pre><p>We can customize how we handle different types of exceptions.</p><h3 id=\"-multiple-except-clauses\">\ud83d\udd39 Multiple Except Clauses</h3><p>To do this, we need to add multiple <code>except</code> clauses to handle different types of exceptions differently. </p><p>According to the <a href=\"https://docs.python.org/3/tutorial/errors.html#handling-exceptions\">Python Documentation</a>:</p><blockquote>A try statement may have <strong>more than one except clause</strong>, to specify handlers for different exceptions. <strong>At most one handler will be executed</strong>.</blockquote><p>In this example, we have two except clauses. One of them handles ZeroDivisionError and the other one handles ValueError, the two types of exceptions that could be raised in this try block. </p><pre><code>def divide_integers():\n    while True:\n        try:\n            a = int(input(\"Please enter the numerator: \"))\n            b = int(input(\"Please enter the denominator: \"))\n            print(a / b)\n        except ZeroDivisionError:\n            print(\"Please enter a valid denominator.\")\n        except ValueError:\n            print(\"Both values have to be integers.\")\n\n\ndivide_integers() </code></pre><p>\ud83d\udca1 <strong>Tip: </strong>You have to determine which types of exceptions might be raised in the try block to handle them appropriately.</p><h3 id=\"-multiple-exceptions-one-except-clause\">\ud83d\udd38 Multiple Exceptions, One Except Clause</h3><p>You can also choose to handle different types of exceptions with the same except clause. </p><p>According to the <a href=\"https://docs.python.org/3/tutorial/errors.html#handling-exceptions\">Python Documentation</a>:</p><blockquote>An except clause may name <strong>multiple exceptions</strong> as a parenthesized tuple.</blockquote><p>This is an example where we catch two exceptions (ZeroDivisionError and ValueError) with the same <code>except</code> clause:</p><pre tabindex=\"0\"><code>def divide_integers():\n    while True:\n        try:\n            a = int(input(\"Please enter the numerator: \"))\n            b = int(input(\"Please enter the denominator: \"))\n            print(a / b)\n        except (ZeroDivisionError, ValueError):\n            print(\"Please enter valid integers.\")\n\ndivide_integers()</code></pre><p>The output would be the same for the two types of exceptions because they are handled by the same except clause:</p><pre tabindex=\"0\"><code>Please enter the numerator: 5\nPlease enter the denominator: 0\nPlease enter valid integers.</code></pre><pre tabindex=\"0\"><code>Please enter the numerator: 0.5\nPlease enter valid integers.\nPlease enter the numerator: </code></pre><h3 id=\"-handling-exceptions-raised-by-functions-called-in-the-try-clause\">\ud83d\udd39 Handling Exceptions Raised by Functions Called in the try Clause</h3><p>An interesting aspect of exception handling is that if an exception is raised in a function that was previously called in the try clause of another function and the function itself does not handle it, the caller will handle it if there is an appropriate except clause. </p><p>According to the <a href=\"https://docs.python.org/3/tutorial/errors.html#handling-exceptions\">Python Documentation</a>:</p><blockquote>Exception handlers don\u2019t just handle exceptions if they occur immediately in the try clause, but also <strong>if they occur inside functions that are called (even indirectly) in the try clause.</strong></blockquote><p>Let's see an example to illustrate this:</p><pre><code>def f(i):\n    try:\n        g(i)\n    except IndexError:\n        print(\"Please enter a valid index\")\n\ndef g(i):\n    a = \"Hello\"\n    return a[i]\n\nf(50)</code></pre><p>We have the <code>f</code> function and the <code>g</code> function. <code>f</code> calls <code>g</code> in the try clause. With the argument 50, <code>g</code> will raise an IndexError because the index 50 is not valid for the string a. </p><p>But <code>g</code> itself doesn't handle the exception. Notice how there is no try ... except statement in the <code>g</code> function. Since it doesn't handle the exception, it \"sends\" it to <code>f</code> to see if it can handle it, as you can see in the diagram below:</p><figure><img alt=\"image-16\" height=\"553\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2019/12/image-16.png\" width=\"652\"/></figure><p>Since f <em>does </em>know how to handle an IndexError, the situation is handled gracefully and this is the output:</p><pre tabindex=\"0\"><code>Please enter a valid index</code></pre><p><strong>\ud83d\udca1 Note:</strong> If <code>f</code> had not handled the exception, the program would have ended abruptly with the default error message for an IndexError.</p><h3 id=\"-accessing-specific-details-of-exceptions\">\ud83d\udd38 Accessing Specific Details of Exceptions</h3><p>Exceptions are objects in Python, so you can assign the exception that was raised to a variable. This way, you can print the default description of the exception and access its arguments.</p><p>According to the <a href=\"https://docs.python.org/3/tutorial/errors.html#handling-exceptions\">Python Documentation</a>:</p><blockquote>The except clause <strong>may specify a variable after the exception name</strong>. The variable is bound to an exception instance with the arguments stored in instance.args.</blockquote><p>Here we have an example (see below) were we assign the instance of <code>ZeroDivisionError</code> to the variable <code>e</code>. Then, we can use this variable within the except clause to access the type of the exception, its message, and arguments. </p><pre tabindex=\"0\"><code>def divide_integers():\n    while True:\n        try:\n            a = int(input(\"Please enter the numerator: \"))\n            b = int(input(\"Please enter the denominator: \"))\n            print(a / b)\n        # Here we assign the exception to the variable e\n        except ZeroDivisionError as e:\n            print(type(e))\n            print(e)\n            print(e.args)\n\ndivide_integers()</code></pre><p>The corresponding output would be:</p><pre tabindex=\"0\"><code>Please enter the numerator: 5\nPlease enter the denominator: 0\n\n# Type\n&lt;class 'ZeroDivisionError'&gt;\n\n# Message\ndivision by zero\n\n# Args\n('division by zero',)</code></pre><p><strong>\ud83d\udca1 Tip:</strong> If you are familiar with special methods, according to the <a href=\"https://docs.python.org/3/tutorial/errors.html#handling-exceptions\">Python Documentation</a>: \"for convenience, the exception instance defines <code><a href=\"https://docs.python.org/3/reference/datamodel.html#object.__str__\">__str__()</a></code> so the arguments can be printed directly without having to reference <code>.args</code>.\"</p><h2 id=\"4-now-let-s-add-the-else-clause\">4\ufe0f\u20e3 Now Let's Add: The \"else\" Clause</h2><p>The <code>else</code> clause is optional, but it's a great tool because it lets us execute code that should only run if no exceptions were raised in the try clause.</p><figure><img alt=\"image-17\" height=\"376\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2019/12/image-17.png\" width=\"719\"/></figure><p>According to the <a href=\"https://docs.python.org/3/tutorial/errors.html#handling-exceptions\">Python Documentation</a>:</p><blockquote>The <a href=\"https://docs.python.org/3/reference/compound_stmts.html#try\"><code>try</code></a> \u2026 <a href=\"https://docs.python.org/3/reference/compound_stmts.html#except\"><code>except</code></a> statement has an <strong>optional </strong><em>else clause</em>, which, when present, must follow all except clauses. It is useful for code that must be executed <strong>if the try clause does not raise an exception.</strong></blockquote><p>Here is an example of the use of the <code>else</code> clause:</p><pre tabindex=\"0\"><code>def divide_integers():\n    while True:\n        try:\n            a = int(input(\"Please enter the numerator: \"))\n            b = int(input(\"Please enter the denominator: \"))\n            result = a / b\n        except (ZeroDivisionError, ValueError):\n            print(\"Please enter valid integers. The denominator can't be zero\")\n        else:\n            print(result)\n\ndivide_integers()</code></pre><p>If no exception are raised, the result is printed:</p><pre tabindex=\"0\"><code>Please enter the numerator: 5\nPlease enter the denominator: 5\n1.0</code></pre><p>But if an exception is raised, the result is not printed:</p><pre tabindex=\"0\"><code>Please enter the numerator: 5\nPlease enter the denominator: 0\nPlease enter valid integers. The denominator can't be zero</code></pre><p>\ud83d\udca1 <strong>Tip:</strong> According to the <a href=\"https://docs.python.org/3/tutorial/errors.html#handling-exceptions\">Python Documentation</a>:</p><blockquote>The use of the <code>else</code> clause is better than adding additional code to the <a href=\"https://docs.python.org/3/reference/compound_stmts.html#try\"><code>try</code></a> clause because it avoids accidentally catching an exception that wasn\u2019t raised by the code being protected by the <code>try</code> \u2026 <code>except</code> statement.</blockquote><h2 id=\"5-the-finally-clause\">5\ufe0f\u20e3 The \"finally\" Clause</h2><p>The finally clause is the last clause in this sequence. It is <strong>optional</strong>, but if you include it, it has to be the last clause in the sequence. The <code>finally</code> clause is <strong>always </strong>executed, even if an exception was raised in the try clause. \u00a0</p><figure><img alt=\"image-19\" height=\"386\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2019/12/image-19.png\" width=\"726\"/></figure><p>According to the <a href=\"https://docs.python.org/3/tutorial/errors.html#defining-clean-up-actions\">Python Documentation</a>:</p><blockquote>If a <a href=\"https://docs.python.org/3/reference/compound_stmts.html#finally\"><code>finally</code></a> clause is present, the <a href=\"https://docs.python.org/3/reference/compound_stmts.html#finally\"><code>finally</code></a> clause will execute as the last task before the <a href=\"https://docs.python.org/3/reference/compound_stmts.html#try\"><code>try</code></a> statement completes. The <a href=\"https://docs.python.org/3/reference/compound_stmts.html#finally\"><code>finally</code></a> clause <strong>runs whether or not the <a href=\"https://docs.python.org/3/reference/compound_stmts.html#try\"><code>try</code></a> statement produces an exception.</strong></blockquote><p>The finally clause is usually used to perform \"clean-up\" actions that should always be completed. For example, if we are working with a file in the try clause, we will always need to close the file, even if an exception was raised when we were working with the data.</p><p>Here is an example of the finally clause:</p><pre tabindex=\"0\"><code>def divide_integers():\n    while True:\n        try:\n            a = int(input(\"Please enter the numerator: \"))\n            b = int(input(\"Please enter the denominator: \"))\n            result = a / b\n        except (ZeroDivisionError, ValueError):\n            print(\"Please enter valid integers. The denominator can't be zero\")\n        else:\n            print(result)\n        finally:\n            print(\"Inside the finally clause\")\n\ndivide_integers()</code></pre><p>This is the output when no exceptions were raised:</p><pre><code>Please enter the numerator: 5\nPlease enter the denominator: 5\n1.0\nInside the finally clause</code></pre><p>This is the output when an exception was raised:</p><pre tabindex=\"0\"><code>Please enter the numerator: 5\nPlease enter the denominator: 0\nPlease enter valid integers. The denominator can't be zero\nInside the finally clause</code></pre><p>Notice how the <code>finally</code> clause <strong>always </strong>runs.</p><p><strong>\u2757\ufe0fImportant:</strong> remember that the <code>else</code> clause and the <code>finally</code> clause are optional, but if you decide to include both, the finally clause has to be the last clause in the sequence.</p><h2 id=\"6-raising-exceptions\">6\ufe0f\u20e3 Raising Exceptions</h2><p>Now that you know how to handle exceptions in Python, I would like to share with you this helpful tip: <strong>you can also choose when to raise exceptions in your code. </strong></p><p>This can be helpful for certain scenarios. Let's see how you can do this:</p><figure><img alt=\"image-20\" height=\"331\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2019/12/image-20.png\" width=\"966\"/></figure><p>This line will raise a ValueError with a custom message.</p><p>Here we have an example (see below) of a function that prints the value of the items of a list or tuple, or the characters in a string. But you decided that you want the list, tuple, or string to be of length 5. You start the function with an if statement that checks if the length of the argument <code>data</code> is 5. If it isn't, a ValueError exception is raised:</p><pre tabindex=\"0\"><code>def print_five_items(data):\n    \n    if len(data) != 5:\n        raise ValueError(\"The argument must have five elements\")\n    \n    for item in data:\n        print(item)\n\nprint_five_items([5, 2])</code></pre><p>The output would be:</p><pre tabindex=\"0\"><code>Traceback (most recent call last):\n  File \"&lt;path&gt;\", line 122, in &lt;module&gt;\n    print_five_items([5, 2])\n  File \"&lt;path&gt;\", line 117, in print_five_items\n    raise ValueError(\"The argument must have five elements\")\nValueError: The argument must have five elements</code></pre><p>Notice how the last line displays the descriptive message:</p><pre tabindex=\"0\"><code>ValueError: The argument must have five elements</code></pre><p>You can then choose how to handle the exception with a try ... except statement. You could add an else clause and/or a finally clause. You can customize it to fit your needs. </p><h3 id=\"-helpful-resources\">\ud83d\udd39 Helpful Resources</h3><ul><li><a href=\"https://docs.python.org/3/tutorial/errors.html#exceptions\">Exceptions</a></li><li><a href=\"https://docs.python.org/3/tutorial/errors.html#handling-exceptions\">Handling Exceptions</a></li><li><a href=\"https://docs.python.org/3/tutorial/errors.html#defining-clean-up-actions\">Defining Clean-up Actions</a></li></ul><p><strong>I hope you enjoyed reading my article and found it helpful.</strong> Now you have the necessary tools to handle exceptions in Python and you can use them to your advantage when you write Python code. ? <a href=\"https://www.udemy.com/user/estefania-cn/\">Check out my online courses</a>. You can follow me on <a href=\"https://twitter.com/EstefaniaCassN\">Twitter</a>. </p><p>\u2b50\ufe0f You may enjoy my other freeCodeCamp /news articles:</p><ul><li><a href=\"https://www.freecodecamp.org/news/python-property-decorator/\">The @property Decorator in Python: Its Use Cases, Advantages, and Syntax</a></li><li><a href=\"https://www.freecodecamp.org/news/data-structures-101-graphs-a-visual-introduction-for-beginners-6d88f36ec768/\">Data Structures 101: Graphs\u200a\u2014\u200aA Visual Introduction for Beginners</a></li><li><a href=\"https://www.freecodecamp.org/news/data-structures-101-arrays-a-visual-introduction-for-beginners-7f013bcc355a/\">Data Structures 101: Arrays\u200a\u2014\u200aA Visual Introduction for Beginners</a></li></ul>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nWelcome! In this article, you will learn how to handle exceptions in Python.In particular, we will cover:ExceptionsThe purpose of exception handlingThe try clauseThe except clauseThe else clauseThe finally clauseHow to raise exceptionsAre you ready? Let's begin! \ud83d\ude001\ufe0f\u20e3 Intro to ExceptionsWe will start with exceptions:What are they? Why are they relevant? Why should you handle them?According to the Python documentation:Errors detected during execution are called exceptions and are not unconditionally fatal.Exceptions are raised when the program encounters an error during its execution. They disrupt the normal flow of the program and usually end it abruptly. To avoid this, you can catch them and handle them appropriately.You've probably seen them during your programming projects. If you've ever tried to divide by zero in Python, you must have seen this error message:>>> a = 5/0\nTraceback (most recent call last):\n  File \"<pyshell#1>\", line 1, in <module>\n    a = 5/0\nZeroDivisionError: division by zeroIf you tried to index a string with an invalid index, you definitely got this error message:>>> a = \"Hello, World\"\n>>> a[456]\nTraceback (most recent call last):\n  File \"<pyshell#3>\", line 1, in <module>\n    a[456]\nIndexError: string index out of rangeThese are examples of exceptions.\ud83d\udd39 Common ExceptionsThere are many different types of exceptions, and they are all raised in particular situations. Some of the exceptions that you will most likely see as you work on your projects are:IndexError - raised when you try to index a list, tuple, or string beyond the permitted boundaries. For example:>>> num = [1, 2, 6, 5]\n>>> num[56546546]\nTraceback (most recent call last):\n  File \"<pyshell#7>\", line 1, in <module>\n    num[56546546]\nIndexError: list index out of rangeKeyError - raised when you try to access the value of a key that doesn't exist in a dictionary. For example:>>> students = {\"Nora\": 15, \"Gino\": 30}\n>>> students[\"Lisa\"]\nTraceback (most recent call last):\n  File \"<pyshell#9>\", line 1, in <module>\n    students[\"Lisa\"]\nKeyError: 'Lisa'NameError - raised when a name that you are referencing in the code doesn't exist. For example:>>> a = b\nTraceback (most recent call last):\n  File \"<pyshell#10>\", line 1, in <module>\n    a = b\nNameError: name 'b' is not definedTypeError - raised when an operation or function is applied to an object of an inappropriate type. For example:>>> (5, 6, 7) * (1, 2, 3)\nTraceback (most recent call last):\n  File \"<pyshell#12>\", line 1, in <module>\n    (5, 6, 7) * (1, 2, 3)\nTypeError: can't multiply sequence by non-int of type 'tuple'ZeroDivisionError - raised when you try to divide by zero.>>> a = 5/0\nTraceback (most recent call last):\n  File \"<pyshell#13>\", line 1, in <module>\n    a = 5/0\nZeroDivisionError: division by zero\ud83d\udca1 Tips: To learn more about other types of built-in exceptions, please refer to this article in the Python Documentation.\ud83d\udd38 Anatomy of an ExceptionI'm sure that you must have noticed a general pattern in these error messages. Let's break down their general structure piece by piece:First, we find this line (see below). A traceback is basically a list detailing the function calls that were made before the exception was raised. The traceback helps you during the debugging process because you can analyze the sequence of function calls that resulted in the exception:Traceback (most recent call last):Then, we see this line (see below) with the path to the file and the line that raised the exception. In this case, the path was the Python shell <pyshell#0> since the example was executed directly in IDLE.File \"<pyshell#0>\", line 1, in <module>\n   a - 5/0\ud83d\udca1 Tip: If the line that raised the exception belongs to a function, <module> \u00a0is replaced by the name of the function.Finally, we see a descriptive message detailing the type of exception and providing additional information to help us debug the code:NameError: name 'a' is not defined2\ufe0f\u20e3 Exception Handling: Purpose & ContextYou may ask: why would I want to handle exceptions? Why is this helpful for me? By handling exceptions, you can provide an alternative flow of execution to avoid crashing your program unexpectedly.\ud83d\udd39 Example: User InputImagine what would happen if a user who is working with your program enters an invalid input. This would raise an exception because an invalid operation was performed during the process. If your program doesn't handle this correctly, it will crash suddenly and the user will have a very disappointing experience with your product.But if you do handle the exception, you will be able to provide an alternative to improve the experience of the user. Perhaps you could display a descriptive message asking the user to enter a valid input, or you could provide a default value for the input. Depending on the context, you can choose what to do when this happens, and this is the magic of error handling. It can save the day when unexpected things happen. \u2b50\ufe0f\ud83d\udd38 What Happens Behind the Scenes?Basically, when we handle an exception, we are telling the program what to do if the exception is raised. In that case, the \"alternative\" flow of execution will come to the rescue. If no exceptions are raised, the code will run as expected.3\ufe0f\u20e3 Time to Code: The try ... except StatementNow that you know what exceptions are and why you should we handle them, we will start diving into the built-in tools that the Python languages offers for this purpose. First, we have the most basic statement: try ... except.Let's illustrate this with a simple example. We have this small program that asks the user to enter the name of a student to display his/her age:students = {\"Nora\": 15, \"Gino\": 30}\n\ndef print_student_age():\n    name = input(\"Please enter the name of the student: \")\n    print(students[name])\n\nprint_student_age()Notice how we are not validating user input at the moment, so the user might enter invalid values (names that are not in the dictionary) and the consequences would be catastrophic because the program would crash if a KeyError is raised:# User Input\nPlease enter the name of the student: \"Daniel\"\n\n# Error Message\nTraceback (most recent call last):\n  File \"<path>\", line 15, in <module>\n    print_student_age()\n  File \"<path>\", line 13, in print_student_age\n    print(students[name])\nKeyError: '\"Daniel\"'\ud83d\udd39 SyntaxWe can handle this nicely using try ... except. This is the basic syntax:In our example, we would add the try ... except statement within the function. Let's break this down piece by piece:students = {\"Nora\": 15, \"Gino\": 30}\n\ndef print_student_age():\n    while True:\n        try:\n            name = input(\"Please enter the name of the student: \")\n            print(students[name])\n            break\n        except:\n            print(\"This name is not registered\")\n    \n\nprint_student_age()If we \"zoom in\", we see the try ... except statement:try:\n\tname = input(\"Please enter the name of the student: \")\n\tprint(students[name])\n\tbreak\nexcept:\n\tprint(\"This name is not registered\")When the function is called, the try clause will run. If no exceptions are raised, the program will run as expected. But if an exception is raised in the try clause, the flow of execution will immediately jump to the except clause to handle the exception.\ud83d\udca1 Note: This code is contained within a while loop to continue asking for user input if the value is invalid. This is an example:Please enter the name of the student: \"Lulu\"\nThis name is not registered\nPlease enter the name of the student: This is great, right? Now we can continue asking for user input if the value is invalid. At the moment, we are handling all possible exceptions with the same except clause. But what if we only want to handle a specific type of exception? Let's see how we could do this.\ud83d\udd38 Catching Specific ExceptionsSince not all types of exceptions are handled in the same way, we can specify which exceptions we would like to handle with this syntax:This is an example. We are handling the ZeroDivisionError exception in case the user enters zero as the denominator:def divide_integers():\n    while True:\n        try:\n            a = int(input(\"Please enter the numerator: \"))\n            b = int(input(\"Please enter the denominator: \"))\n            print(a / b)\n        except ZeroDivisionError:\n            print(\"Please enter a valid denominator.\")\n\n\ndivide_integers()This would be the result:# First iteration\nPlease enter the numerator: 5\nPlease enter the denominator: 0\nPlease enter a valid denominator. \n\n# Second iteration\nPlease enter the numerator: 5\nPlease enter the denominator: 2\n2.5We are handling this correctly. But... if another type of exception is raised, the program will not handle it gracefully. Here we have an example of a ValueError because one of the values is a float, not an int:Please enter the numerator: 5\nPlease enter the denominator: 0.5\nTraceback (most recent call last):\n  File \"<path>\", line 53, in <module>\n    divide_integers()\n  File \"<path>\", line 47, in divide_integers\n    b = int(input(\"Please enter the denominator: \"))\nValueError: invalid literal for int() with base 10: '0.5'We can customize how we handle different types of exceptions.\ud83d\udd39 Multiple Except ClausesTo do this, we need to add multiple except clauses to handle different types of exceptions differently. According to the Python Documentation:A try statement may have more than one except clause, to specify handlers for different exceptions. At most one handler will be executed.In this example, we have two except clauses. One of them handles ZeroDivisionError and the other one handles ValueError, the two types of exceptions that could be raised in this try block. def divide_integers():\n    while True:\n        try:\n            a = int(input(\"Please enter the numerator: \"))\n            b = int(input(\"Please enter the denominator: \"))\n            print(a / b)\n        except ZeroDivisionError:\n            print(\"Please enter a valid denominator.\")\n        except ValueError:\n            print(\"Both values have to be integers.\")\n\n\ndivide_integers() \ud83d\udca1 Tip: You have to determine which types of exceptions might be raised in the try block to handle them appropriately.\ud83d\udd38 Multiple Exceptions, One Except ClauseYou can also choose to handle different types of exceptions with the same except clause. According to the Python Documentation:An except clause may name multiple exceptions as a parenthesized tuple.This is an example where we catch two exceptions (ZeroDivisionError and ValueError) with the same except clause:def divide_integers():\n    while True:\n        try:\n            a = int(input(\"Please enter the numerator: \"))\n            b = int(input(\"Please enter the denominator: \"))\n            print(a / b)\n        except (ZeroDivisionError, ValueError):\n            print(\"Please enter valid integers.\")\n\ndivide_integers()The output would be the same for the two types of exceptions because they are handled by the same except clause:Please enter the numerator: 5\nPlease enter the denominator: 0\nPlease enter valid integers.Please enter the numerator: 0.5\nPlease enter valid integers.\nPlease enter the numerator: \ud83d\udd39 Handling Exceptions Raised by Functions Called in the try ClauseAn interesting aspect of exception handling is that if an exception is raised in a function that was previously called in the try clause of another function and the function itself does not handle it, the caller will handle it if there is an appropriate except clause. According to the Python Documentation:Exception handlers don\u2019t just handle exceptions if they occur immediately in the try clause, but also if they occur inside functions that are called (even indirectly) in the try clause.Let's see an example to illustrate this:def f(i):\n    try:\n        g(i)\n    except IndexError:\n        print(\"Please enter a valid index\")\n\ndef g(i):\n    a = \"Hello\"\n    return a[i]\n\nf(50)We have the f function and the g function. f calls g in the try clause. With the argument 50, g will raise an IndexError because the index 50 is not valid for the string a. But g itself doesn't handle the exception. Notice how there is no try ... except statement in the g function. Since it doesn't handle the exception, it \"sends\" it to f to see if it can handle it, as you can see in the diagram below:Since f does know how to handle an IndexError, the situation is handled gracefully and this is the output:Please enter a valid index\ud83d\udca1 Note: If f had not handled the exception, the program would have ended abruptly with the default error message for an IndexError.\ud83d\udd38 Accessing Specific Details of ExceptionsExceptions are objects in Python, so you can assign the exception that was raised to a variable. This way, you can print the default description of the exception and access its arguments.According to the Python Documentation:The except clause may specify a variable after the exception name. The variable is bound to an exception instance with the arguments stored in instance.args.Here we have an example (see below) were we assign the instance of ZeroDivisionError to the variable e. Then, we can use this variable within the except clause to access the type of the exception, its message, and arguments. def divide_integers():\n    while True:\n        try:\n            a = int(input(\"Please enter the numerator: \"))\n            b = int(input(\"Please enter the denominator: \"))\n            print(a / b)\n        # Here we assign the exception to the variable e\n        except ZeroDivisionError as e:\n            print(type(e))\n            print(e)\n            print(e.args)\n\ndivide_integers()The corresponding output would be:Please enter the numerator: 5\nPlease enter the denominator: 0\n\n# Type\n<class 'ZeroDivisionError'>\n\n# Message\ndivision by zero\n\n# Args\n('division by zero',)\ud83d\udca1 Tip: If you are familiar with special methods, according to the Python Documentation: \"for convenience, the exception instance defines __str__() so the arguments can be printed directly without having to reference .args.\"4\ufe0f\u20e3 Now Let's Add: The \"else\" ClauseThe else clause is optional, but it's a great tool because it lets us execute code that should only run if no exceptions were raised in the try clause.According to the Python Documentation:The try \u2026 except statement has an optional else clause, which, when present, must follow all except clauses. It is useful for code that must be executed if the try clause does not raise an exception.Here is an example of the use of the else clause:def divide_integers():\n    while True:\n        try:\n            a = int(input(\"Please enter the numerator: \"))\n            b = int(input(\"Please enter the denominator: \"))\n            result = a / b\n        except (ZeroDivisionError, ValueError):\n            print(\"Please enter valid integers. The denominator can't be zero\")\n        else:\n            print(result)\n\ndivide_integers()If no exception are raised, the result is printed:Please enter the numerator: 5\nPlease enter the denominator: 5\n1.0But if an exception is raised, the result is not printed:Please enter the numerator: 5\nPlease enter the denominator: 0\nPlease enter valid integers. The denominator can't be zero\ud83d\udca1 Tip: According to the Python Documentation:The use of the else clause is better than adding additional code to the try clause because it avoids accidentally catching an exception that wasn\u2019t raised by the code being protected by the try \u2026 except statement.5\ufe0f\u20e3 The \"finally\" ClauseThe finally clause is the last clause in this sequence. It is optional, but if you include it, it has to be the last clause in the sequence. The finally clause is always executed, even if an exception was raised in the try clause. \u00a0According to the Python Documentation:If a finally clause is present, the finally clause will execute as the last task before the try statement completes. The finally clause runs whether or not the try statement produces an exception.The finally clause is usually used to perform \"clean-up\" actions that should always be completed. For example, if we are working with a file in the try clause, we will always need to close the file, even if an exception was raised when we were working with the data.Here is an example of the finally clause:def divide_integers():\n    while True:\n        try:\n            a = int(input(\"Please enter the numerator: \"))\n            b = int(input(\"Please enter the denominator: \"))\n            result = a / b\n        except (ZeroDivisionError, ValueError):\n            print(\"Please enter valid integers. The denominator can't be zero\")\n        else:\n            print(result)\n        finally:\n            print(\"Inside the finally clause\")\n\ndivide_integers()This is the output when no exceptions were raised:Please enter the numerator: 5\nPlease enter the denominator: 5\n1.0\nInside the finally clauseThis is the output when an exception was raised:Please enter the numerator: 5\nPlease enter the denominator: 0\nPlease enter valid integers. The denominator can't be zero\nInside the finally clauseNotice how the finally clause always runs.\u2757\ufe0fImportant: remember that the else clause and the finally clause are optional, but if you decide to include both, the finally clause has to be the last clause in the sequence.6\ufe0f\u20e3 Raising ExceptionsNow that you know how to handle exceptions in Python, I would like to share with you this helpful tip: you can also choose when to raise exceptions in your code. This can be helpful for certain scenarios. Let's see how you can do this:This line will raise a ValueError with a custom message.Here we have an example (see below) of a function that prints the value of the items of a list or tuple, or the characters in a string. But you decided that you want the list, tuple, or string to be of length 5. You start the function with an if statement that checks if the length of the argument data is 5. If it isn't, a ValueError exception is raised:def print_five_items(data):\n    \n    if len(data) != 5:\n        raise ValueError(\"The argument must have five elements\")\n    \n    for item in data:\n        print(item)\n\nprint_five_items([5, 2])The output would be:Traceback (most recent call last):\n  File \"<path>\", line 122, in <module>\n    print_five_items([5, 2])\n  File \"<path>\", line 117, in print_five_items\n    raise ValueError(\"The argument must have five elements\")\nValueError: The argument must have five elementsNotice how the last line displays the descriptive message:ValueError: The argument must have five elementsYou can then choose how to handle the exception with a try ... except statement. You could add an else clause and/or a finally clause. You can customize it to fit your needs. \ud83d\udd39 Helpful ResourcesExceptionsHandling ExceptionsDefining Clean-up ActionsI hope you enjoyed reading my article and found it helpful. Now you have the necessary tools to handle exceptions in Python and you can use them to your advantage when you write Python code. ? Check out my online courses. You can follow me on Twitter. \u2b50\ufe0f You may enjoy my other freeCodeCamp /news articles:The @property Decorator in Python: Its Use Cases, Advantages, and SyntaxData Structures 101: Graphs\u200a\u2014\u200aA Visual Introduction for BeginnersData Structures 101: Arrays\u200a\u2014\u200aA Visual Introduction for Beginners\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 19873, "excerpt": "Welcome! In this article, you will learn how to handle exceptions in Python.\n\nIn particular, we will cover:\n\n * Exceptions\n * The purpose of exception handling\n * The try clause\n * The except clause\n * The else clause\n * The finally clause\n * How to raise exceptions\n\nAre you ready? Let's begin! \ud83d\ude00\n\n1\ufe0f\u20e3 Intro to Exceptions\nWe will start with exceptions:\n\n * What are they? \n * Why are they relevant? \n * Why should you handle them?\n\nAccording to the Python documentation\n[https://docs.python.org/3/t", "siteName": "freeCodeCamp.org", "publishedTime": "2019-12-22T15:27:27.000Z", "id": "3eb553e2107f3af35f3b6c53d73125fd708995f4", "url": "https://www.freecodecamp.org/news/exception-handling-python/", "domain": "freecodecamp.org", "date": "2023-12-27T18:07:35.828190", "resultUri": "http://localhost:3000/result/3eb553e2107f3af35f3b6c53d73125fd708995f4", "query": {"url": ["https://www.freecodecamp.org/news/exception-handling-python/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "How to Handle Exceptions in Python: A Detailed Visual Introduction", "description": "Welcome! In this article, you will learn how to handle exceptions in Python. In particular, we will cover:  * Exceptions  * The purpose of exception handling  * The try clause  * The except clause  * The else clause  * The finally clause  *", "url": "https://www.freecodecamp.org/news/exception-handling-python/", "image": "https://www.freecodecamp.org/news/content/images/2019/12/Exception-Handling-in-Python.png", "image:width": "1280", "image:height": "720"}, "twitter": {"card": "summary_large_image", "title": "How to Handle Exceptions in Python: A Detailed Visual Introduction", "description": "Welcome! In this article, you will learn how to handle exceptions in Python. In particular, we will cover:  * Exceptions  * The purpose of exception handling  * The try clause  * The except clause  * The else clause  * The finally clause  *", "url": "https://www.freecodecamp.org/news/exception-handling-python/", "image": "https://www.freecodecamp.org/news/content/images/2019/12/Exception-Handling-in-Python.png", "label1": "Written by", "data1": "Estefania Cassingena Navone", "label2": "Filed under", "data2": "Python, Exception Handling, Learning To Code, Programming", "site": "@freecodecamp", "creator": "@EstefaniaCassN"}}}