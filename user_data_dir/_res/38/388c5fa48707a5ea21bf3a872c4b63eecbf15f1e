{"title": "The Complete Guide to this in JavaScript", "byline": "freeCodeCamp.org", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>The Complete Guide to this in JavaScript</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>In JavaScript, every function has a <code>this</code> reference automatically created when you declare it. </p><p>JavaScript's <code>this</code> is quite similar to a <code>this</code> reference in other class-based languages such as Java or C# (JavaScript is a prototype-based language and no \u201cclass\u201d concept): <em>It points to the which object is calling to the function</em> (this object sometimes called as <em>context</em>). In JavaScript, however, <em>the <code>this</code> reference inside functions can be bound to different objects depending on where the function is being called</em>. </p><p>Here are 5 basic rules for <code>this</code> binding in JavaScript:</p><h3 id=\"rule-1\"><strong>Rule 1</strong></h3><p>When a function is called in the global scope, the <code>this</code> reference is by default bound to the <strong><strong>global object</strong></strong> (<code>window</code> in the browser, or <code>global</code> in Node.js). For example:</p><pre tabindex=\"0\"><code>function foo() {\n  this.a = 2;\n}\n\nfoo();\nconsole.log(a); // 2</code></pre><p>Note: If you declare the <code>foo()</code> function above in strict mode, then you call this function in global scope, <code>this</code> will be <code>undefined</code> and assignment <code>this.a = 2</code> will throw <code>Uncaught TypeError</code> exception.</p><h3 id=\"rule-2\"><strong>Rule 2</strong></h3><p>Let\u2019s examine example below:</p><pre tabindex=\"0\"><code>function foo() {\n  this.a = 2;\n}\n\nconst obj = {\n  foo: foo\n};\n\nobj.foo();\nconsole.log(obj.a); // 2</code></pre><p>Clearly, in the above snippet, the <code>foo()</code> function is being called with <em>context</em> is <code>obj</code> object and <code>this</code> reference now is bound to <code>obj</code>. So when a function is called with a context object, the <code>this</code> reference will be bound to this object.</p><h3 id=\"rule-3\"><strong>Rule 3</strong></h3><p><code>.call</code>, <code>.apply</code> and <code>.bind</code> can all be used at the call site to explicitly bind <code>this</code>. Using <code>.bind(this)</code> is something you may see in quite a lot of React components.</p><pre tabindex=\"0\"><code>const foo = function() {\n  console.log(this.bar)\n}\n\nfoo.call({ bar: 1 }) // 1</code></pre><p>Here\u2019s a quick example of how each one is used to bind <code>this</code>:</p><ul><li><code>.call()</code>: <code>fn.call(thisObj, fnParam1, fnParam2)</code></li><li><code>.apply()</code>: <code>fn.apply(thisObj, [fnParam1, fnParam2])</code></li><li><code>.bind()</code>: <code>const newFn = fn.bind(thisObj, fnParam1, fnParam2)</code></li></ul><h3 id=\"rule-4\"><strong>Rule 4</strong></h3><pre tabindex=\"0\"><code>function Point2D(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nconst p1 = new Point2D(1, 2);\nconsole.log(p1.x); // 1\nconsole.log(p1.y); // 2</code></pre><p>The thing you must notice that is the <code>Point2D</code> function called with <code>new</code> keyword, and <code>this</code> reference is bound to <code>p1</code> object. So when a function is called with <code>new</code> keyword, it will create a new object and <code>this</code> reference will be bound to this object.</p><p>Note: As you call a function with <code>new</code> keyword, we also call it as <em>constructor function</em>.</p><h3 id=\"rule-5\"><strong>Rule 5</strong></h3><p>JavaScript determines the value of <code>this</code> at runtime, based on the current context. So <code>this</code> can sometimes point to something other than what you expect.</p><p>Consider this example of a Cat class with a method called <code>makeSound()</code>, following the pattern in Rule 4 (above) with a constructor function and the <code>new</code> keyword.</p><pre tabindex=\"0\"><code>const Cat = function(name, sound) {\n  this.name = name;\n  this.sound = sound;\n  this.makeSound = function() {\n    console.log( this.name + ' says: ' + this.sound );\n  };\n}\n\nconst kitty = new Cat('Fat Daddy', 'Mrrooowww');\nkitty.makeSound(); // Fat Daddy says: Mrrooowww</code></pre><p>Now let\u2019s try to give the cat a way to <code>annoy()</code> people by repeating his sound 100 times, once every half second.</p><pre tabindex=\"0\"><code>const Cat = function(name, sound) {\n  this.name = name;\n  this.sound = sound;\n  this.makeSound = function() {\n    console.log( this.name + ' says: ' + this.sound );\n  };\n  this.annoy = function() {\n    let count = 0, max = 100;\n    const t = setInterval(function() {\n      this.makeSound(); // &lt;-- this line fails with `this.makeSound is not a function` \n      count++;\n      if (count === max) {\n        clearTimeout(t);\n      }\n    }, 500);\n  };\n}\n\nconst kitty = new Cat('Fat Daddy', 'Mrrooowww');\nkitty.annoy();</code></pre><p>That doesn\u2019t work because inside the <code>setInterval</code> callback we\u2019ve created a new context with global scope, so <code>this</code> no longer points to our kitty instance. In a web browser, <code>this</code> will instead point to the Window object, which doesn\u2019t have a <code>makeSound()</code> method.</p><p>A couple of ways to make it work:</p><ol><li>Before creating the new context, assign <code>this</code> to a local variable named <code>me</code>, or <code>self</code>, or whatever you want to call it, and use that variable inside the callback.</li></ol><pre tabindex=\"0\"><code>const Cat = function(name, sound) {\n  this.name = name;\n  this.sound = sound;\n  this.makeSound = function() {\n    console.log( this.name + ' says: ' + this.sound );\n  };\n  this.annoy = function() {\n    let count = 0, max = 100;\n    const self = this;\n    const t = setInterval(function() {\n      self.makeSound();\n      count++;\n      if (count === max) {\n        clearTimeout(t);\n      }\n    }, 500);\n  };\n}\n\nconst kitty = new Cat('Fat Daddy', 'Mrrooowww');\nkitty.annoy();</code></pre><ol><li>With ES6 you can avoid assigning <code>this</code> to a local variable by using an arrow function, which binds <code>this</code> to the context of the surrounding code where it\u2019s defined.</li></ol><pre tabindex=\"0\"><code>const Cat = function(name, sound) {\n  this.name = name;\n  this.sound = sound;\n  this.makeSound = function() {\n    console.log( this.name + ' says: ' + this.sound );\n  };\n  this.annoy = function() {\n    let count = 0, max = 100;\n    const t = setInterval(() =&gt; {\n      this.makeSound();\n      count++;\n      if (count === max) {\n        clearTimeout(t);\n      }\n    }, 500);\n  };\n}\n\nconst kitty = new Cat('Fat Daddy', 'Mrrooowww');\nkitty.annoy();</code></pre>\n</section>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nIn JavaScript, every function has a this reference automatically created when you declare it. JavaScript's this is quite similar to a this reference in other class-based languages such as Java or C# (JavaScript is a prototype-based language and no \u201cclass\u201d concept): It points to the which object is calling to the function (this object sometimes called as context). In JavaScript, however, the this reference inside functions can be bound to different objects depending on where the function is being called. Here are 5 basic rules for this binding in JavaScript:Rule 1When a function is called in the global scope, the this reference is by default bound to the global object (window in the browser, or global in Node.js). For example:function foo() {\n  this.a = 2;\n}\n\nfoo();\nconsole.log(a); // 2Note: If you declare the foo() function above in strict mode, then you call this function in global scope, this will be undefined and assignment this.a = 2 will throw Uncaught TypeError exception.Rule 2Let\u2019s examine example below:function foo() {\n  this.a = 2;\n}\n\nconst obj = {\n  foo: foo\n};\n\nobj.foo();\nconsole.log(obj.a); // 2Clearly, in the above snippet, the foo() function is being called with context is obj object and this reference now is bound to obj. So when a function is called with a context object, the this reference will be bound to this object.Rule 3.call, .apply and .bind can all be used at the call site to explicitly bind this. Using .bind(this) is something you may see in quite a lot of React components.const foo = function() {\n  console.log(this.bar)\n}\n\nfoo.call({ bar: 1 }) // 1Here\u2019s a quick example of how each one is used to bind this:.call(): fn.call(thisObj, fnParam1, fnParam2).apply(): fn.apply(thisObj, [fnParam1, fnParam2]).bind(): const newFn = fn.bind(thisObj, fnParam1, fnParam2)Rule 4function Point2D(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nconst p1 = new Point2D(1, 2);\nconsole.log(p1.x); // 1\nconsole.log(p1.y); // 2The thing you must notice that is the Point2D function called with new keyword, and this reference is bound to p1 object. So when a function is called with new keyword, it will create a new object and this reference will be bound to this object.Note: As you call a function with new keyword, we also call it as constructor function.Rule 5JavaScript determines the value of this at runtime, based on the current context. So this can sometimes point to something other than what you expect.Consider this example of a Cat class with a method called makeSound(), following the pattern in Rule 4 (above) with a constructor function and the new keyword.const Cat = function(name, sound) {\n  this.name = name;\n  this.sound = sound;\n  this.makeSound = function() {\n    console.log( this.name + ' says: ' + this.sound );\n  };\n}\n\nconst kitty = new Cat('Fat Daddy', 'Mrrooowww');\nkitty.makeSound(); // Fat Daddy says: MrrooowwwNow let\u2019s try to give the cat a way to annoy() people by repeating his sound 100 times, once every half second.const Cat = function(name, sound) {\n  this.name = name;\n  this.sound = sound;\n  this.makeSound = function() {\n    console.log( this.name + ' says: ' + this.sound );\n  };\n  this.annoy = function() {\n    let count = 0, max = 100;\n    const t = setInterval(function() {\n      this.makeSound(); // <-- this line fails with `this.makeSound is not a function` \n      count++;\n      if (count === max) {\n        clearTimeout(t);\n      }\n    }, 500);\n  };\n}\n\nconst kitty = new Cat('Fat Daddy', 'Mrrooowww');\nkitty.annoy();That doesn\u2019t work because inside the setInterval callback we\u2019ve created a new context with global scope, so this no longer points to our kitty instance. In a web browser, this will instead point to the Window object, which doesn\u2019t have a makeSound() method.A couple of ways to make it work:Before creating the new context, assign this to a local variable named me, or self, or whatever you want to call it, and use that variable inside the callback.const Cat = function(name, sound) {\n  this.name = name;\n  this.sound = sound;\n  this.makeSound = function() {\n    console.log( this.name + ' says: ' + this.sound );\n  };\n  this.annoy = function() {\n    let count = 0, max = 100;\n    const self = this;\n    const t = setInterval(function() {\n      self.makeSound();\n      count++;\n      if (count === max) {\n        clearTimeout(t);\n      }\n    }, 500);\n  };\n}\n\nconst kitty = new Cat('Fat Daddy', 'Mrrooowww');\nkitty.annoy();With ES6 you can avoid assigning this to a local variable by using an arrow function, which binds this to the context of the surrounding code where it\u2019s defined.const Cat = function(name, sound) {\n  this.name = name;\n  this.sound = sound;\n  this.makeSound = function() {\n    console.log( this.name + ' says: ' + this.sound );\n  };\n  this.annoy = function() {\n    let count = 0, max = 100;\n    const t = setInterval(() => {\n      this.makeSound();\n      count++;\n      if (count === max) {\n        clearTimeout(t);\n      }\n    }, 500);\n  };\n}\n\nconst kitty = new Cat('Fat Daddy', 'Mrrooowww');\nkitty.annoy();\n\n                        \n                    \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 5638, "excerpt": "In JavaScript, every function has a this reference automatically created when\nyou declare it. \n\nJavaScript's this is quite similar to a this reference in other class-based\nlanguages such as Java or C# (JavaScript is a prototype-based language and no\n\u201cclass\u201d concept): It points to the which object is calling to the function (this\nobject sometimes called as context). In JavaScript, however, the this reference\ninside functions can be bound to different objects depending on where the\nfunction is bei", "siteName": "freeCodeCamp.org", "publishedTime": "2020-01-18T07:45:00.000Z", "id": "388c5fa48707a5ea21bf3a872c4b63eecbf15f1e", "url": "https://www.freecodecamp.org/news/the-complete-guide-to-this-in-javascript/", "domain": "freecodecamp.org", "date": "2023-12-27T18:07:19.795754", "resultUri": "http://localhost:3000/result/388c5fa48707a5ea21bf3a872c4b63eecbf15f1e", "query": {"url": ["https://www.freecodecamp.org/news/the-complete-guide-to-this-in-javascript/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "The Complete Guide to this in JavaScript", "description": "In JavaScript, every function has a this reference automatically created when you declare it.  JavaScript's this is quite similar to a this reference in other class-based languages such as Java or C# (JavaScript is a prototype-based language and no \u201cclass\u201d concept): It points to the which object is calling", "url": "https://www.freecodecamp.org/news/the-complete-guide-to-this-in-javascript/", "image": "https://cdn-media-2.freecodecamp.org/w1280/5f9c9dc9740569d1a4ca39a1.jpg", "image:width": "1280", "image:height": "1613"}, "twitter": {"card": "summary_large_image", "title": "The Complete Guide to this in JavaScript", "description": "In JavaScript, every function has a this reference automatically created when you declare it.  JavaScript's this is quite similar to a this reference in other class-based languages such as Java or C# (JavaScript is a prototype-based language and no \u201cclass\u201d concept): It points to the which object is calling", "url": "https://www.freecodecamp.org/news/the-complete-guide-to-this-in-javascript/", "image": "https://cdn-media-2.freecodecamp.org/w1280/5f9c9dc9740569d1a4ca39a1.jpg", "label1": "Written by", "data1": "freeCodeCamp.org", "label2": "Filed under", "data2": "JavaScript, Web Development, Programming Languages, Programming", "site": "@freecodecamp"}}}