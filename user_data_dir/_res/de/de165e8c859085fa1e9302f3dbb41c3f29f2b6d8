{"title": "Discover the power of closures in VueJS", "byline": "freeCodeCamp.org", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>Discover the power of closures in VueJS</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>By Fabian Hinsenkamp</p><p>Today\u2019s frontend technology landscape requires engineers to know about a wide variety of technologies including frameworks, libraries and packages.</p><p>No wonder then that vanilla JavaScript skills and in-depth knowledge might start spreading thin. No matter if you are just learning JavaScript, refreshing your basic knowledge or preparing for job interviews \u2192 This tutorial is for you!</p><p>Here you will learn how powerful plain JavaScript closures are. Be aware, this tutorial comes with a challenge. ? It\u2019s all about building an elegant Emoji Picker in VueJS and leveraging closures by using higher order functions.</p><p><strong><strong>Let\u2019s dive right into it!</strong></strong></p><h3 id=\"function-scope\">Function Scope</h3><p>Even though closures are one of the most powerful concepts in JavaScript, they are easily overlooked by many.</p><p>Nevertheless, knowing about closures is fundamental as they define which variables a function has access to during its execution. More precisely, closures define which scopes a function has access to starting from its own, through all parent scopes up to the global scope.</p><p>To really master closures, it\u2019s essential to have a solid understanding of scopes first. You have probably already experienced the impact of scopes yourself. Every time you execute a function, a scope is created. Whenever you create variables within that function, these are only accessible from within the function itself.</p><p>At the time a function is completed (by reaching a <code>return</code> statement or <code>}</code> ) all these variables are destroyed. Next time you execute the function, the same procedure is applied.</p><p>Let\u2019s look at the following example to illustrate the concept.</p><pre><code>function square(x){\n  const squaredX = x  x;\n  console.log(squaredX); // 25\n  return squaredX;\n}\n\nconst squaredA = square(5);\n\nconsole.log(squaredA); // 25 \nconsole.log(squaredX); // ReferenceError: squaredX is not defined</code></pre><p>Think about scopes as the temporary context only the code within that function has access to.</p><p>While scopes have a very limited lifetime, limited by the time a function execution needs to execute, in contrast a function\u2019s closure is already created when a function is initially defined. It also will remain after the execution has been completed.</p><h3 id=\"closures\">Closures</h3><p>As mentioned before, closures are responsible for defining which variables are accessible in the scope of a function execution. It\u2019s essential to understand that closures do not provide copies of available variables but references to them. If you are not familiar with JavaScript\u2019s references check out this <a href=\"https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0\" rel=\"noopener\">article</a>.</p><pre><code>let globalString = 'A'\n\nfunction hello(){\n  const localString = 'C'\n  console.log(globalString, localString);\n}\n\nhello(); // A C\n\nglobalString = \"B\";\n\nhello(); // B C</code></pre><p>The example looks probably very familiar\u200a\u2014\u200ait\u2019s not anything special. This explains why we barely realise how powerful closures can be, as it\u2019s very common to only define functions in the global scope.</p><p>However, when functions are defined within another function\u2019s scope, closures enable powerful techniques and patterns. In an object-oriented architecture, closures offer a simple but efficient way to establish <strong><strong>data privacy</strong></strong>. In more functional architectures, closures are essential to <strong><strong>higher order functions</strong></strong> and <strong><strong>partial application</strong></strong> and <strong><strong>currying</strong></strong>, two more advanced programming techniques.</p><h3 id=\"higher-order-functions\">Higher Order Functions</h3><p>A function that operates on other functions, either by taking them as arguments or by returning them, is called a <strong><strong>higher-order function</strong></strong>.</p><pre><code>function createMultiplier(multiplier){\n  return function(value){\n    return value  multiplier;\n  }\n}\n\nconst multiplyBy2 = createMultiplier(2);\n\nconsole.log(multiplyBy2(5)); //10</code></pre><p>Here we finally can experience the power of closures. Even though <code>createMultiplier</code> has been already successfully completed, we can still access its initial <code>multiplier</code> property.</p><p>This is possible as closures keep the reference of variables. These can even span over multiple scopes and do not get destroyed when the context terminates. That way, we can still access a specific instance of a local variable.</p><h3 id=\"data-privacy\">Data Privacy</h3><pre><code>function privateVariables(){\n  let privateValue = 100;\n  return {\n    get: function(){\n      return privateValue;\n    }\n  }\n}\n\nconsole.log(privateVariables.get()); //100</code></pre><p>How come closures enable us to implement data privacy?</p><p>We can simply enclose variables and only allow functions within the containing (outer) function scope to access them.</p><p>You can\u2019t get at the data from an outside scope except through the object\u2019s privileged methods. This pattern also allows us to program to an interface and not the implementation itself.</p><h3 id=\"coding-challenge-emoji-tone-picker\">Coding Challenge: Emoji Tone Picker</h3><p>Great, that\u2019s all the theory we need for actually building something powerful in VueJS and leveraging the power of closures!</p><p>In fact, higher order functions are the most interesting use case, as we already have a data privacy concept in VueJS.</p><p>Basically, components already offer an interface through properties and the data object which isn\u2019t accessible from outside.</p><p>It is a component to that allows the user to choose the skin tone based an a selection of all available tones, similar to the user experience known from texting on a smart phone.</p><p>Technically, you should try to create a component that receives a single emoji as props and uses higher order functions to create multiple click event handlers to select different tones.</p><p>You can check the <a href=\"https://codesandbox.io/s/pw940vx207?fontsize=14\" rel=\"noopener\">sandbox</a> for the code!</p><h3 id=\"hint\">Hint</h3><p>Emojis can be stored as HTML hex codes in string values. The folded hands emoji is &amp;#x1F64F. To change the tone, attach a colour code to it. You can find the codes <a href=\"https://emojiterra.com/folded-hands/\" rel=\"noopener\">here</a>.</p><blockquote><em><em><em>&amp;#x1F64F + &amp;#x1F3FD = ??</em></em></em></blockquote><h3 id=\"building-challenge-extension\">Building Challenge Extension</h3><p>You want to take it one step further, and really see if you mastered closures? Then pass multiple emojis and make it work so you can change the skin tone of multiple emojis one at a time. ?</p><h3 id=\"conclusion\">Conclusion</h3><p>Closures are the reason why we can access variables of parent scopes while the related functions might have already terminated.</p><p>We can use this behaviour of JavaScript in VueJS to dynamically build methods based on dynamic arguments without polluting our components with a vast variety of variables and methods.</p><p>Thanks for reading ?</p><hr/><p>Originally published on my blog at <a href=\"https://hinsencamp.com/article/closures-vue/\" rel=\"noopener\">https://hinsencamp.com</a>.</p>\n</section>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nBy Fabian HinsenkampToday\u2019s frontend technology landscape requires engineers to know about a wide variety of technologies including frameworks, libraries and packages.No wonder then that vanilla JavaScript skills and in-depth knowledge might start spreading thin. No matter if you are just learning JavaScript, refreshing your basic knowledge or preparing for job interviews \u2192 This tutorial is for you!Here you will learn how powerful plain JavaScript closures are. Be aware, this tutorial comes with a challenge. ? It\u2019s all about building an elegant Emoji Picker in VueJS and leveraging closures by using higher order functions.Let\u2019s dive right into it!Function ScopeEven though closures are one of the most powerful concepts in JavaScript, they are easily overlooked by many.Nevertheless, knowing about closures is fundamental as they define which variables a function has access to during its execution. More precisely, closures define which scopes a function has access to starting from its own, through all parent scopes up to the global scope.To really master closures, it\u2019s essential to have a solid understanding of scopes first. You have probably already experienced the impact of scopes yourself. Every time you execute a function, a scope is created. Whenever you create variables within that function, these are only accessible from within the function itself.At the time a function is completed (by reaching a return statement or } ) all these variables are destroyed. Next time you execute the function, the same procedure is applied.Let\u2019s look at the following example to illustrate the concept.function square(x){\n  const squaredX = x  x;\n  console.log(squaredX); // 25\n  return squaredX;\n}\n\nconst squaredA = square(5);\n\nconsole.log(squaredA); // 25 \nconsole.log(squaredX); // ReferenceError: squaredX is not definedThink about scopes as the temporary context only the code within that function has access to.While scopes have a very limited lifetime, limited by the time a function execution needs to execute, in contrast a function\u2019s closure is already created when a function is initially defined. It also will remain after the execution has been completed.ClosuresAs mentioned before, closures are responsible for defining which variables are accessible in the scope of a function execution. It\u2019s essential to understand that closures do not provide copies of available variables but references to them. If you are not familiar with JavaScript\u2019s references check out this article.let globalString = 'A'\n\nfunction hello(){\n  const localString = 'C'\n  console.log(globalString, localString);\n}\n\nhello(); // A C\n\nglobalString = \"B\";\n\nhello(); // B CThe example looks probably very familiar\u200a\u2014\u200ait\u2019s not anything special. This explains why we barely realise how powerful closures can be, as it\u2019s very common to only define functions in the global scope.However, when functions are defined within another function\u2019s scope, closures enable powerful techniques and patterns. In an object-oriented architecture, closures offer a simple but efficient way to establish data privacy. In more functional architectures, closures are essential to higher order functions and partial application and currying, two more advanced programming techniques.Higher Order FunctionsA function that operates on other functions, either by taking them as arguments or by returning them, is called a higher-order function.function createMultiplier(multiplier){\n  return function(value){\n    return value  multiplier;\n  }\n}\n\nconst multiplyBy2 = createMultiplier(2);\n\nconsole.log(multiplyBy2(5)); //10Here we finally can experience the power of closures. Even though createMultiplier has been already successfully completed, we can still access its initial multiplier property.This is possible as closures keep the reference of variables. These can even span over multiple scopes and do not get destroyed when the context terminates. That way, we can still access a specific instance of a local variable.Data Privacyfunction privateVariables(){\n  let privateValue = 100;\n  return {\n    get: function(){\n      return privateValue;\n    }\n  }\n}\n\nconsole.log(privateVariables.get()); //100How come closures enable us to implement data privacy?We can simply enclose variables and only allow functions within the containing (outer) function scope to access them.You can\u2019t get at the data from an outside scope except through the object\u2019s privileged methods. This pattern also allows us to program to an interface and not the implementation itself.Coding Challenge: Emoji Tone PickerGreat, that\u2019s all the theory we need for actually building something powerful in VueJS and leveraging the power of closures!In fact, higher order functions are the most interesting use case, as we already have a data privacy concept in VueJS.Basically, components already offer an interface through properties and the data object which isn\u2019t accessible from outside.It is a component to that allows the user to choose the skin tone based an a selection of all available tones, similar to the user experience known from texting on a smart phone.Technically, you should try to create a component that receives a single emoji as props and uses higher order functions to create multiple click event handlers to select different tones.You can check the sandbox for the code!HintEmojis can be stored as HTML hex codes in string values. The folded hands emoji is &#x1F64F. To change the tone, attach a colour code to it. You can find the codes here.&#x1F64F + &#x1F3FD = ??Building Challenge ExtensionYou want to take it one step further, and really see if you mastered closures? Then pass multiple emojis and make it work so you can change the skin tone of multiple emojis one at a time. ?ConclusionClosures are the reason why we can access variables of parent scopes while the related functions might have already terminated.We can use this behaviour of JavaScript in VueJS to dynamically build methods based on dynamic arguments without polluting our components with a vast variety of variables and methods.Thanks for reading ?Originally published on my blog at https://hinsencamp.com.\n\n                        \n                    \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 6761, "excerpt": "By Fabian Hinsenkamp\n\nToday\u2019s frontend technology landscape requires engineers to know about a wide\nvariety of technologies including frameworks, libraries and packages.\n\nNo wonder then that vanilla JavaScript skills and in-depth knowledge might start\nspreading thin. No matter if you are just learning JavaScript, refreshing your\nbasic knowledge or preparing for job interviews \u2192 This tutorial is for you!\n\nHere you will learn how powerful plain JavaScript closures are. Be aware, this\ntutorial come", "siteName": "freeCodeCamp.org", "publishedTime": "2019-04-24T21:32:00.000Z", "id": "de165e8c859085fa1e9302f3dbb41c3f29f2b6d8", "url": "https://www.freecodecamp.org/news/closures-vuejs-higher-order-functions-emojipicker-f10d3c249a12/", "domain": "freecodecamp.org", "date": "2023-12-27T18:11:27.226247", "resultUri": "http://localhost:3000/result/de165e8c859085fa1e9302f3dbb41c3f29f2b6d8", "query": {"url": ["https://www.freecodecamp.org/news/closures-vuejs-higher-order-functions-emojipicker-f10d3c249a12/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "Discover the power of closures in VueJS", "description": "By Fabian Hinsenkamp Today\u2019s frontend technology landscape requires engineers to know about a wide variety of technologies including frameworks, libraries and packages. No wonder then that vanilla JavaScript skills and in-depth knowledge might start spreading thin. No matter if you are just learning JavaScript, refreshing your basic knowledge or preparing", "url": "https://www.freecodecamp.org/news/closures-vuejs-higher-order-functions-emojipicker-f10d3c249a12/", "image": "https://s3.amazonaws.com/cdn-media-1.freecodecamp.org/ghost/2019/05/1_pc1Xhd_TAV9H8u8b-ogLPw.png", "image:width": "1440", "image:height": "1024"}, "twitter": {"card": "summary_large_image", "title": "Discover the power of closures in VueJS", "description": "By Fabian Hinsenkamp Today\u2019s frontend technology landscape requires engineers to know about a wide variety of technologies including frameworks, libraries and packages. No wonder then that vanilla JavaScript skills and in-depth knowledge might start spreading thin. No matter if you are just learning JavaScript, refreshing your basic knowledge or preparing", "url": "https://www.freecodecamp.org/news/closures-vuejs-higher-order-functions-emojipicker-f10d3c249a12/", "image": "https://s3.amazonaws.com/cdn-media-1.freecodecamp.org/ghost/2019/05/1_pc1Xhd_TAV9H8u8b-ogLPw.png", "label1": "Written by", "data1": "freeCodeCamp.org", "label2": "Filed under", "data2": "JavaScript, Programming, Vuejs, Front End Development, Tech", "site": "@freecodecamp"}}}