{"title": "How to Know When You've Learned Everything You Can From a Programming Problem", "byline": "Amy Haddad", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>How to Know When You've Learned Everything You Can From a Programming Problem</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>The answer may seem obvious: you\u2019re done with a problem once you\u2019ve solved it. </p><p>That\u2019s how I approached problem-solving when I began learning to code. I was on a problem-solving treadmill: solving as many <a href=\"https://www.freecodecamp.org/news/do-you-solve-programming-problems-or-complete-exercises-the-difference-matters/\">problems</a> as quickly as possible.</p><p>And why not? There\u2019s no shortage of problems to solve. Besides, don\u2019t you get better by solving more problems? More to the point: what else can you do once you have the answer? As it turns out, quite a bit. The fallacy of my approach soon surfaced. </p><p>Although I solved the problem, I didn\u2019t learn much from it. That\u2019s because a few days or weeks later when I tried to re-solve the problem or when I came across a related one, I got really <a href=\"https://www.freecodecamp.org/news/how-to-get-unstuck/\">stuck</a>. Mistakes were made. Concepts were confused. Progress was stalled. </p><p>I now realize that getting the solution is only part of the problem-solving process. Then, in the words of a mathematician named George P\u00f3lya, it\u2019s time to \u201clook back.\u201d</p><h2 id=\"looking-back\">Looking Back</h2><p>P\u00f3lya writes about the problem-solving process in his book, <em>How to Solve It</em>, through the lens of mathematical problem-solving. But his ideas are applicable to programming. What\u2019s particularly interesting to me is his fourth phase: looking back.</p><p>\u201cBy looking back at the completed solution, by reconsidering and reexamining the result and the path that led to it, [students] could consolidate their knowledge and develop their ability to solve problems,\u201d P\u00f3lya writes.</p><p>In some ways, solving a problem is like creating a piece of art. There\u2019s always something more we could do. \u201cWe could improve any solution, and, in any case, we can always improve our understanding of the solution,\u201d explains P\u00f3lya.</p><p>For me, \u201clooking back\u201d is a practice of self-improvement and <a href=\"https://amymhaddad.com/four-ways-to-learn-programming-topics\">learning</a>. The aim is to:</p><ul><li>Learn from my successes: understand what you wrote and why.</li><li>Solidify my learning of new concepts.</li><li>See patterns and understand the context for using a particular data structure or algorithm. </li></ul><p>Consider a basketball player who takes 1,000 shots each day. That sounds admirable. But as he rushes to get the 1,000 shots in, his form gets sloppy. He uses the wrong technique. </p><p>He\u2019d benefit more from taking a few hundred shots, then evaluating his performance: watching a video recording of his form, seeing the flaws, and correcting them. Then, he'd hit the court again. </p><p>Now he\u2019ll be more informed, since he looked back and evaluated his performance. He\u2019ll practice better.</p><p>The same is true with solving problems. The idea isn\u2019t to check a box so you can claim you solved \u201cx\u201d number of problems. Instead it\u2019s doing your best work each time and learning as much as possible along the way. </p><p>There are three reasons why looking back matters.</p><h3 id=\"reason-1-see-the-patterns-and-understand-the-context\">Reason #1: See the Patterns and Understand the Context</h3><p>You\u2019ll see similar patterns over and over again in the problems you solve. </p><p>Understand how to use a particular algorithm, like binary search. Train your eye so you know <em>when </em>and <em>how</em> to apply it. So when you encounter a related problem in the future, you\u2019ll be ready. Doing so will save time (and frustration) in the long run.</p><h3 id=\"reason-2-solidify-your-learning\">Reason #2: Solidify Your Learning</h3><p>Say you used something that\u2019s new to you to solve a problem, like a stack or queue. </p><p>Do you really know how to use it again? Do you feel comfortable using a stack in a related problem? Take the time to understand anything new you used so you can use it again in the future.</p><h3 id=\"reason-3-learn-from-your-successes\">Reason #3: Learn from Your Successes</h3><p>Mathematician Richard Hamming gets to the heart of the matter with this quote from his book, <em>The Art of Doing Science and Engineering.</em></p><p>\u201cI regard the study of successes as being basically more important than the study of failures...there are so many ways of being wrong and so few of being right, studying successes is more efficient.\u201d</p><p>As programmers, we deal with our fair share of errors. And then (many tries later) we run the program and it works. Now is a great time to put Hamming\u2019s words to practice and study your success. </p><p>Do you understand <em>how </em>your program works? Do you understand <em>what</em> you wrote and <em>why </em>you wrote it? </p><p>By looking back\u2060\u2014when the information is still fresh in your mind\u2060\u2014you\u2019re preparing your future self. It\u2019ll help you bridge your understanding and solidify your mental models. It\u2019ll help you improve and prevent repeating the same mistakes over again. In short, it\u2019ll help you get better.</p><h2 id=\"four-ways-to-look-back\">Four Ways to Look Back</h2><p>There are a few ways that I \u201clook back\u201d at problems. Give them a try.</p><h3 id=\"teach-yourself\">Teach Yourself</h3><p>A fantastic way to help solidify your mental models is to teach yourself. After you complete a program or problem, go through your code and explain it line by line. It\u2019s one of the best ways of \u201clooking back\u201d when you\u2019re learning something new.</p><p>I\u2019ve found this process invaluable while learning web development. After I complete a project, I copy my code into a Google Doc. Starting at the top, I make comments throughout to teach myself about important concepts.</p><p>Here\u2019s an example of some code and some of the comments I wrote.</p><!--kg-card-begin: markdown--><pre tabindex=\"0\"><code>export default function ManageTeamMembersPage(props) {\n \n    const [teammate, setTeammate] = useState({\n       name:\"\",\n       email: \"\",\n       role: \"\",\n   })\n   \n   ...\n   \n</code></pre>\n<!--kg-card-end: markdown--><ul><li>Use props to access data passed down from the parent component.</li><li>Add state hook. The hook takes a default, which is an object that contains everything I need for the form: name, email, role.</li></ul><p>This method of \u201clooking back\u201d is about understanding. In this example, I was learning about state, props, and forms in React. </p><p>Writing out comments to explain your code will help you solidify concepts in your mind. If you can\u2019t type a short explanation of it on the spot, then revisit the topic. </p><p>This method is equally useful for future problems and projects. I regularly pull up old problems and programs I\u2019ve notated. I use them as a reference when writing related programs or solving related problems. Doing so reinforces key ideas, and to Hamming\u2019s point, it helps me remember my successes: what to keep doing.</p><h3 id=\"study-solutions-of-great-programmers\">Study Solutions of Great Programmers</h3><p>It\u2019s not only useful to study your own code, but also the code of others who have solved the same problem. There are a lot of <a href=\"https://amymhaddad.com/2-traits-of-great-programmers\">great programmers</a> out there and we can learn from them.</p><p>After I solve a problem, I apply <a href=\"https://amymhaddad.com/how-ben-franklin-can-help-you-become-a-better-programmer.mdx\">a learning technique that Ben Franklin used</a> to become a better writer. His process involved trying to reproduce an article from a publication he admired after he\u2019d forgotten the details of it. </p><p>I follow a similar process to become a better programmer.</p><p>Here\u2019s how it works:</p><ul><li><strong>Solve a problem</strong>.</li><li><strong>Find a programmer who\u2019s better than you and who\u2019s solved the same problem.</strong></li><li><strong>Study their solution</strong>: read each line of code and type a comment in your editor to explain it.</li><li><strong>Re-solve the program </strong>after some time has passed. Use the comments you typed out as hints to guide you along the way.</li><li><strong>Compare your program </strong>to the one you studied.</li></ul><p>To be clear, this practice isn\u2019t about memorizing or copying someone else\u2019s code\u2014far from it. Rather, it\u2019s about learning: get practice <a href=\"https://amymhaddad.com/why-reading-code-matters\">reading</a> code; see another way to solve the same problem; experiment with new parts of a language; and get practice teaching yourself. It\u2019s also about applying what you\u2019ve learned by putting it into your own style.</p><h3 id=\"add-a-constraint\">Add a Constraint</h3><p>See how different techniques apply to the same problem when you add a constraint. For example, you solved the problem using a hash table. Now try solving it using an array.</p><p>The idea is to gain another perspective, and adding a constraint can do just that. It\u2019ll get you out of your comfort zone, forcing you to think creatively. </p><p>As a result, you may find a slicker approach and cut the length of your program in half. Or may realize what data structure <em>not </em>to use, which is equally important. </p><p>Here\u2019s the point: you\u2019ll have another approach at your ready when you\u2019re faced with a related problem in the future.</p><p>The programming website LeetCode is great for many reasons. One is providing similar questions for problems that you solve.</p><p>In one problem on LeetCode you are given an array of integers and a target number. The aim is to find two numbers that add up to the target and return their indices. </p><p>You solve the problem. </p><p>Now solve a related one, which LeetCode provides. This time you\u2019re given an array of integers that\u2019s sorted in ascending order, along with a few additional constraints to differentiate this problem from the previous one.</p><p>Solving a related problem is a great way to get practice using a similar technique, data structure, or algorithm in a different context.</p><p>Looking back focuses on the <em>process</em>, instead of the end result. And revisiting the process matters. It\u2019s getting out of your comfort zone, trying something new whether that\u2019s a data structure or algorithm. It\u2019s realizing there are different ways to solve the same problem. It\u2019s understanding how to write better code. It\u2019s about learning. \u00a0</p><p>Yes, it takes some time to look back. But it\u2019s time well spent: it\u2019s how we get better.</p><p><em><em>I write about the programming skills you need to master and the concepts you need to learn, and the best ways to learn them (</em></em><a href=\"https://amymhaddad.com/\" rel=\"noopener\">amymhaddad.com</a>).</p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nThe answer may seem obvious: you\u2019re done with a problem once you\u2019ve solved it. That\u2019s how I approached problem-solving when I began learning to code. I was on a problem-solving treadmill: solving as many problems as quickly as possible.And why not? There\u2019s no shortage of problems to solve. Besides, don\u2019t you get better by solving more problems? More to the point: what else can you do once you have the answer? As it turns out, quite a bit. The fallacy of my approach soon surfaced. Although I solved the problem, I didn\u2019t learn much from it. That\u2019s because a few days or weeks later when I tried to re-solve the problem or when I came across a related one, I got really stuck. Mistakes were made. Concepts were confused. Progress was stalled. I now realize that getting the solution is only part of the problem-solving process. Then, in the words of a mathematician named George P\u00f3lya, it\u2019s time to \u201clook back.\u201dLooking BackP\u00f3lya writes about the problem-solving process in his book, How to Solve It, through the lens of mathematical problem-solving. But his ideas are applicable to programming. What\u2019s particularly interesting to me is his fourth phase: looking back.\u201cBy looking back at the completed solution, by reconsidering and reexamining the result and the path that led to it, [students] could consolidate their knowledge and develop their ability to solve problems,\u201d P\u00f3lya writes.In some ways, solving a problem is like creating a piece of art. There\u2019s always something more we could do. \u201cWe could improve any solution, and, in any case, we can always improve our understanding of the solution,\u201d explains P\u00f3lya.For me, \u201clooking back\u201d is a practice of self-improvement and learning. The aim is to:Learn from my successes: understand what you wrote and why.Solidify my learning of new concepts.See patterns and understand the context for using a particular data structure or algorithm. Consider a basketball player who takes 1,000 shots each day. That sounds admirable. But as he rushes to get the 1,000 shots in, his form gets sloppy. He uses the wrong technique. He\u2019d benefit more from taking a few hundred shots, then evaluating his performance: watching a video recording of his form, seeing the flaws, and correcting them. Then, he'd hit the court again. Now he\u2019ll be more informed, since he looked back and evaluated his performance. He\u2019ll practice better.The same is true with solving problems. The idea isn\u2019t to check a box so you can claim you solved \u201cx\u201d number of problems. Instead it\u2019s doing your best work each time and learning as much as possible along the way. There are three reasons why looking back matters.Reason #1: See the Patterns and Understand the ContextYou\u2019ll see similar patterns over and over again in the problems you solve. Understand how to use a particular algorithm, like binary search. Train your eye so you know when and how to apply it. So when you encounter a related problem in the future, you\u2019ll be ready. Doing so will save time (and frustration) in the long run.Reason #2: Solidify Your LearningSay you used something that\u2019s new to you to solve a problem, like a stack or queue. Do you really know how to use it again? Do you feel comfortable using a stack in a related problem? Take the time to understand anything new you used so you can use it again in the future.Reason #3: Learn from Your SuccessesMathematician Richard Hamming gets to the heart of the matter with this quote from his book, The Art of Doing Science and Engineering.\u201cI regard the study of successes as being basically more important than the study of failures...there are so many ways of being wrong and so few of being right, studying successes is more efficient.\u201dAs programmers, we deal with our fair share of errors. And then (many tries later) we run the program and it works. Now is a great time to put Hamming\u2019s words to practice and study your success. Do you understand how your program works? Do you understand what you wrote and why you wrote it? By looking back\u2060\u2014when the information is still fresh in your mind\u2060\u2014you\u2019re preparing your future self. It\u2019ll help you bridge your understanding and solidify your mental models. It\u2019ll help you improve and prevent repeating the same mistakes over again. In short, it\u2019ll help you get better.Four Ways to Look BackThere are a few ways that I \u201clook back\u201d at problems. Give them a try.Teach YourselfA fantastic way to help solidify your mental models is to teach yourself. After you complete a program or problem, go through your code and explain it line by line. It\u2019s one of the best ways of \u201clooking back\u201d when you\u2019re learning something new.I\u2019ve found this process invaluable while learning web development. After I complete a project, I copy my code into a Google Doc. Starting at the top, I make comments throughout to teach myself about important concepts.Here\u2019s an example of some code and some of the comments I wrote.export default function ManageTeamMembersPage(props) {\n \n    const [teammate, setTeammate] = useState({\n       name:\"\",\n       email: \"\",\n       role: \"\",\n   })\n   \n   ...\n   \n\nUse props to access data passed down from the parent component.Add state hook. The hook takes a default, which is an object that contains everything I need for the form: name, email, role.This method of \u201clooking back\u201d is about understanding. In this example, I was learning about state, props, and forms in React. Writing out comments to explain your code will help you solidify concepts in your mind. If you can\u2019t type a short explanation of it on the spot, then revisit the topic. This method is equally useful for future problems and projects. I regularly pull up old problems and programs I\u2019ve notated. I use them as a reference when writing related programs or solving related problems. Doing so reinforces key ideas, and to Hamming\u2019s point, it helps me remember my successes: what to keep doing.Study Solutions of Great ProgrammersIt\u2019s not only useful to study your own code, but also the code of others who have solved the same problem. There are a lot of great programmers out there and we can learn from them.After I solve a problem, I apply a learning technique that Ben Franklin used to become a better writer. His process involved trying to reproduce an article from a publication he admired after he\u2019d forgotten the details of it. I follow a similar process to become a better programmer.Here\u2019s how it works:Solve a problem.Find a programmer who\u2019s better than you and who\u2019s solved the same problem.Study their solution: read each line of code and type a comment in your editor to explain it.Re-solve the program after some time has passed. Use the comments you typed out as hints to guide you along the way.Compare your program to the one you studied.To be clear, this practice isn\u2019t about memorizing or copying someone else\u2019s code\u2014far from it. Rather, it\u2019s about learning: get practice reading code; see another way to solve the same problem; experiment with new parts of a language; and get practice teaching yourself. It\u2019s also about applying what you\u2019ve learned by putting it into your own style.Add a ConstraintSee how different techniques apply to the same problem when you add a constraint. For example, you solved the problem using a hash table. Now try solving it using an array.The idea is to gain another perspective, and adding a constraint can do just that. It\u2019ll get you out of your comfort zone, forcing you to think creatively. As a result, you may find a slicker approach and cut the length of your program in half. Or may realize what data structure not to use, which is equally important. Here\u2019s the point: you\u2019ll have another approach at your ready when you\u2019re faced with a related problem in the future.The programming website LeetCode is great for many reasons. One is providing similar questions for problems that you solve.In one problem on LeetCode you are given an array of integers and a target number. The aim is to find two numbers that add up to the target and return their indices. You solve the problem. Now solve a related one, which LeetCode provides. This time you\u2019re given an array of integers that\u2019s sorted in ascending order, along with a few additional constraints to differentiate this problem from the previous one.Solving a related problem is a great way to get practice using a similar technique, data structure, or algorithm in a different context.Looking back focuses on the process, instead of the end result. And revisiting the process matters. It\u2019s getting out of your comfort zone, trying something new whether that\u2019s a data structure or algorithm. It\u2019s realizing there are different ways to solve the same problem. It\u2019s understanding how to write better code. It\u2019s about learning. \u00a0Yes, it takes some time to look back. But it\u2019s time well spent: it\u2019s how we get better.I write about the programming skills you need to master and the concepts you need to learn, and the best ways to learn them (amymhaddad.com).\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 9634, "excerpt": "The answer may seem obvious: you\u2019re done with a problem once you\u2019ve solved it. \n\nThat\u2019s how I approached problem-solving when I began learning to code. I was on\na problem-solving treadmill: solving as many problems\n[/news/do-you-solve-programming-problems-or-complete-exercises-the-difference-matters/] \nas quickly as possible.\n\nAnd why not? There\u2019s no shortage of problems to solve. Besides, don\u2019t you get\nbetter by solving more problems? More to the point: what else can you do once\nyou have the an", "siteName": "freeCodeCamp.org", "publishedTime": "2020-06-22T20:30:26.000Z", "id": "664ef8af51228b0df87d90effca4116544a40b3f", "url": "https://www.freecodecamp.org/news/when-are-you-done-with-a-programming-problem/", "domain": "freecodecamp.org", "date": "2023-12-27T18:06:40.978805", "resultUri": "http://localhost:3000/result/664ef8af51228b0df87d90effca4116544a40b3f", "query": {"url": ["https://www.freecodecamp.org/news/when-are-you-done-with-a-programming-problem/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "How to Know When You've Learned Everything You Can From a Programming Problem", "description": "The answer may seem obvious: you\u2019re done with a problem once you\u2019ve solved it.  That\u2019s how I approached problem-solving when I began learning to code. I was on a problem-solving treadmill: solving as many problems [/news/do-you-solve-programming-problems-or-complete-exercises-the-difference-matters/]  as quickly as possible. And why not? There\u2019s no shortage of problems", "url": "https://www.freecodecamp.org/news/when-are-you-done-with-a-programming-problem/", "image": "https://www.freecodecamp.org/news/content/images/2020/06/ashkan-forouzani-m0l9NBCivuk-unsplash-1.jpg", "image:width": "2000", "image:height": "1333"}, "twitter": {"card": "summary_large_image", "title": "How to Know When You've Learned Everything You Can From a Programming Problem", "description": "The answer may seem obvious: you\u2019re done with a problem once you\u2019ve solved it.  That\u2019s how I approached problem-solving when I began learning to code. I was on a problem-solving treadmill: solving as many problems [/news/do-you-solve-programming-problems-or-complete-exercises-the-difference-matters/]  as quickly as possible. And why not? There\u2019s no shortage of problems", "url": "https://www.freecodecamp.org/news/when-are-you-done-with-a-programming-problem/", "image": "https://www.freecodecamp.org/news/content/images/2020/06/ashkan-forouzani-m0l9NBCivuk-unsplash-1.jpg", "label1": "Written by", "data1": "Amy Haddad", "label2": "Filed under", "data2": "Programming, Learning, Problem Solving, Learn To Code, productivy", "site": "@freecodecamp", "creator": "@amymhaddad"}}}