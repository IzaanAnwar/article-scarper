{"title": "How to Overload Operators in C++", "byline": "Abhilekh Gautam", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>How to Overload Operators in C++</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p><a href=\"https://www.freecodecamp.org/news/how-classes-work-in-cplusplus/\">Classes</a> are user-defined types. They allow us to represent the meaning of various entities. Defining an operator for a class gives us a better way to deal with objects. </p><p>So how can we define operators for our classes, and how should we use such operators? I will show you how in this article.</p><p>Let's begin!</p><h2 id=\"what-are-operators-in-c-\">What are Operators in C++?</h2><p>Operators are symbols which are used to perform operations on various operands. For example:</p><pre tabindex=\"0\"><code>int x = 5;\nint y = 10;\n\nint z = x + y;</code></pre><p>For the above example <code>+</code> is an operator which performs the addition operation on the two operands <code>x</code> and <code>y</code>.</p><h2 id=\"what-is-operator-overloading-in-c-\">What is Operator Overloading in C++?</h2><p>Let's check out an example first.</p><pre tabindex=\"0\"><code>int x=5;\nint y= 10;\n\nint z = x+y;//z==15\n\nstring s1=\"Abhi\";\nstring s2=\"gautam\";\n\nstring s3= s1+s3;//s3==Abhigautam\n</code></pre><p>Have you ever wondered about this type of code <strong>\u2013</strong> why is <code>z== 15</code> and <code>s3== Abhigautam</code>? This is because operators have different meanings for different types of operands. </p><p>For an integer type, the <code>+</code> operator gives the sum of two numbers, and for the string type it concatinates (joins) them.</p><p>So, operator overloading is all about giving new meaning to an operator. But:</p><!--kg-card-begin: html--><ul>\n<li>You cannot set new meaning to an operator for a built-in type.</li>\n<li>You cannot create new operators.</li>\n</ul><!--kg-card-end: html--><p>So, basically what I mean is you cannot redefine an operator and you can't create a new operator, either.</p><p>If you wished to create new operator like <code>**</code> for exponential purposes, you couldn't do it.</p><h3 id=\"how-does-overloading-work\">How does overloading work?</h3><p>So operator overloading lets us define the meaning of an existing operator (note that you cannot overload some operators) for the operands of a user defined type (for example, a class is a user defined type).</p><p>Overloaded operators are just functions (but of a special type) with a special keyword <code>operator</code> followed by the symbol of the operator to be overloaded.</p><pre tabindex=\"0\"><code>/*overloading + for class type object*/\n\nreturn_type operator+(params..){}</code></pre><p>As I already mentioned, overloaded operators are just a special type of functions. They must have a return type, and parameters are always optional (as per their requirements).</p><p>So let's overload some operators for our class now to see how it works:</p><pre tabindex=\"0\"><code>class Complex{\nint real,imag;\npublic:\nComplex(int re,int im):real(re),imag(im){}\nComplex(){\nreal = 0;\nimag = 0;\n}\nvoid display() const;\n//overloading operators\nComplex operator+(const Complex);\nComplex operator-(const Complex);\n};</code></pre><p>Here we have two functions as a member function with the syntax mentioned above. So first let's understand the syntax.</p><pre><code>Complex operator+(const Complex);\nComplex operator-(const Complex);</code></pre><p>Both of the functions here return an object of <code>Complex</code> type. The operator keyword followed by the operators symbol tells us which operator is being overloaded.</p><p>We also have a display function to allow us to see the display of the object's member values. We will substituted this with the overloaded operator (<code>&lt;&lt;</code>) later in the post.</p><pre tabindex=\"0\"><code>void Complex::display(){\nif(imag&lt;0)\ncout&lt;&lt;real&lt;&lt;imag&lt;&lt;\"i\"&lt;&lt;'\\n';\nelse\ncout&lt;&lt;real&lt;&lt;'+'&lt;&lt;imag&lt;&lt;\"i\"&lt;&lt;'\\n';\n}</code></pre><h2 id=\"how-to-overload-the-binary-plus-operator-in-c-\">How to Overload the Binary Plus (+) Operator in C++</h2><p>Let's overload the <code>+</code> operator now.</p><pre tabindex=\"0\"><code>Complex Complex::operator+(const Complex c1){\nComplex temp;\ntemp.real = real + c1.real;\ntemp.imag = imag + c1.imag;\nreturn temp;\n}</code></pre><p>After this definition, if we do the following:</p><pre><code>Complex c1(2,2);\nComplex c2(2,2);\nComplex c3 = c1+c2;\nc3.display();</code></pre><p>It should be clear that c1+c2 is equivalent to this:</p><pre tabindex=\"0\"><code>c1.operator+(c2);\n\n</code></pre><pre tabindex=\"0\"><code>operator(c1,c2);</code></pre><p>After the call to the member function display, the output looks like this:</p><pre><code>4+4i</code></pre><p>So basically we defined the meaning of the <code>+</code> operator for our object of type <code>Complex</code>.</p><h2 id=\"how-to-overload-the-binary-minus-operator-in-c-\">How to Overload the Binary Minus (-) Operator in C++</h2><p>Now let's overload the minus operator.</p><pre tabindex=\"0\"><code>Complex Complex::operator-(const Complex c1){\nComplex temp;\ntemp.real = real - c1.real;\ntemp.imag = imag - c1.imag;\nreturn temp;\n}</code></pre><p>So this is how we overload operators in c++. Let's now discuss the number of parameters that should be passed in the function.</p><p>The number of parameters passed to the function is equal to the number of operands taken by the operator. </p><p>But in case of a (non-static) member function, the number of parameters reduces by one. This is because the (non-static) member function somehow knows the object it was invoked for.</p><p>Isn't that fun? Let's now overload more operators for our class.</p><pre tabindex=\"0\"><code>bool operator!=(const Complex);\nbool operator==(const Complex);</code></pre><h2 id=\"how-to-overload-the-not-equal-to-operator-in-c-\">How to Overload the Not Equal To (!=) Operator in C++</h2><p>So our function definition for the <code>!=</code> operator function will be this:</p><pre tabindex=\"0\"><code>bool Complex::operator!=(const Complex c1){\nif(real!=c1.real || real!=c1.imag){\n    return true;\n}\nelse\nreturn false;\n}</code></pre><p>The return type is a bool, so it returns either true or false.</p><h2 id=\"how-to-overload-the-equal-to-operator-in-c-\">How to Overload the Equal To (==) Operator in C++</h2><p>Similarly for the operator <code>==</code>: </p><pre tabindex=\"0\"><code>bool Complex::operator==(const Complex c1){\n  if(real == c1.real &amp;&amp; imag == c1.imag){\n    return true;\n  }\n  else\n  return false;\n}</code></pre><h3 id=\"how-to-overload-the-get-from-operator-in-c-\">How to Overload the Get From (&lt;&lt;) Operator in C++</h3><p>So let's now overload the <code>&lt;&lt;</code> operator. It will be fun!</p><p>Let's see the function declaration first:</p><pre tabindex=\"0\"><code>friend ostream&amp; operator&lt;&lt;(ostream&amp;,Complex);\n</code></pre><p>There are few changes from the previous functions. Let's understand it more clearly.</p><p>The function is a friend function. This means that it is not within the scope of any class and cannot be invoked by an object. Also the function returns a reference to the ostream object and it takes two arguments as parameters:</p><!--kg-card-begin: html--><ul>\n<li>Reference to an ostream object.</li>\n<li>Reference to an object of class type.</li>\n<ul><!--kg-card-end: html--><p>You might be wondering why a friend function? Let's talk about why we need friend functions now.</p><p>If an operator function is a (non-static) member function, then the left hand side operand will be bound to the <strong><code>this</code> </strong>pointer that refers to the object which is calling the function.</p><p>But we don't want it to be here in the case of the <code>&lt;&lt;</code> operator because the left hand side operand for the <code>&lt;&lt;</code> operator should be <code>cout</code>. And <code>cout</code> is an object of ostream. So to avoid the binding with the object, we used a friend function here.</p><p>We can define the <code>&lt;&lt;</code> operator like this for our class.</p><pre tabindex=\"0\"><code>ostream&amp; operator&lt;&lt;(ostream&amp; os,Complex c1){\nif(c1.imag&lt;0)\nos&lt;&lt;c1.real&lt;&lt;c1.imag&lt;&lt;\"i\";\nelse\nos&lt;&lt;c1.real&lt;&lt;\"+\"&lt;&lt;c1.imag&lt;&lt;\"i\";\n\nreturn os;\n}</code></pre><p>So in this way we can overload most of the operators for our class.</p><h2 id=\"some-operators-can-t-be-overloaded-in-c-\">Some Operators Can't Be Overloaded in C++</h2><p>We cannot overload the following operators in c++:</p><!--kg-card-begin: html--><ul>\n<li>:: (scope resolution operator)</li>\n<li>. (dot operator)</li>\n<li>.* (member selection through pointer)</li>\n</ul><!--kg-card-end: html--><blockquote>They take a name, rather than a value, as their second operand and provide a primary means of referring to members. Allowing them to be overloaded would lead to subtleties. [Stroustroup, 1994]</blockquote><p>Moreover the ternary operator (?:) and the named operators <strong>sizeof </strong>and <strong>typeid</strong> also cannot be overloaded.</p><h3 id=\"errors-to-keep-in-mind\">Errors to Keep in Mind</h3><p>Also remember that the following declaration is an error:</p><pre tabindex=\"0\"><code>int operator+(int,int);\n/*error : cannot redefine operators for built in type.*/</code></pre><p>As mentioned earlier, Redefining an operator for built in type is an error.</p><h3 id=\"one-last-point\">One last point</h3><p>You should not overload operators like <code>&amp;&amp;</code> and <code>||</code> . This is because these operators have a particular order in which an operand is evaluated. Since overloaded operators are just function calls, we cannot guarantee the order of evaluation of the operands.</p><h2 id=\"that-s-it-\">That's it!</h2><p>Happy Coding!</p><p>You can read my other blogs <a href=\"https://abhilekhblogs.blogspot.com/\">here.</a></p></ul></ul>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nClasses are user-defined types. They allow us to represent the meaning of various entities. Defining an operator for a class gives us a better way to deal with objects. So how can we define operators for our classes, and how should we use such operators? I will show you how in this article.Let's begin!What are Operators in C++?Operators are symbols which are used to perform operations on various operands. For example:int x = 5;\nint y = 10;\n\nint z = x + y;For the above example + is an operator which performs the addition operation on the two operands x and y.What is Operator Overloading in C++?Let's check out an example first.int x=5;\nint y= 10;\n\nint z = x+y;//z==15\n\nstring s1=\"Abhi\";\nstring s2=\"gautam\";\n\nstring s3= s1+s3;//s3==Abhigautam\nHave you ever wondered about this type of code \u2013 why is z== 15 and s3== Abhigautam? This is because operators have different meanings for different types of operands. For an integer type, the + operator gives the sum of two numbers, and for the string type it concatinates (joins) them.So, operator overloading is all about giving new meaning to an operator. But:\n    You cannot set new meaning to an operator for a built-in type.\n    You cannot create new operators.\nSo, basically what I mean is you cannot redefine an operator and you can't create a new operator, either.If you wished to create new operator like ** for exponential purposes, you couldn't do it.How does overloading work?So operator overloading lets us define the meaning of an existing operator (note that you cannot overload some operators) for the operands of a user defined type (for example, a class is a user defined type).Overloaded operators are just functions (but of a special type) with a special keyword operator followed by the symbol of the operator to be overloaded./*overloading + for class type object*/\n\nreturn_type operator+(params..){}As I already mentioned, overloaded operators are just a special type of functions. They must have a return type, and parameters are always optional (as per their requirements).So let's overload some operators for our class now to see how it works:class Complex{\nint real,imag;\npublic:\nComplex(int re,int im):real(re),imag(im){}\nComplex(){\nreal = 0;\nimag = 0;\n}\nvoid display() const;\n//overloading operators\nComplex operator+(const Complex);\nComplex operator-(const Complex);\n};Here we have two functions as a member function with the syntax mentioned above. So first let's understand the syntax.Complex operator+(const Complex);\nComplex operator-(const Complex);Both of the functions here return an object of Complex type. The operator keyword followed by the operators symbol tells us which operator is being overloaded.We also have a display function to allow us to see the display of the object's member values. We will substituted this with the overloaded operator (<<) later in the post.void Complex::display(){\nif(imag<0)\ncout<<real<<imag<<\"i\"<<'\\n';\nelse\ncout<<real<<'+'<<imag<<\"i\"<<'\\n';\n}How to Overload the Binary Plus (+) Operator in C++Let's overload the + operator now.Complex Complex::operator+(const Complex c1){\nComplex temp;\ntemp.real = real + c1.real;\ntemp.imag = imag + c1.imag;\nreturn temp;\n}After this definition, if we do the following:Complex c1(2,2);\nComplex c2(2,2);\nComplex c3 = c1+c2;\nc3.display();It should be clear that c1+c2 is equivalent to this:c1.operator+(c2);\n\nandoperator(c1,c2);After the call to the member function display, the output looks like this:4+4iSo basically we defined the meaning of the + operator for our object of type Complex.How to Overload the Binary Minus (-) Operator in C++Now let's overload the minus operator.Complex Complex::operator-(const Complex c1){\nComplex temp;\ntemp.real = real - c1.real;\ntemp.imag = imag - c1.imag;\nreturn temp;\n}So this is how we overload operators in c++. Let's now discuss the number of parameters that should be passed in the function.The number of parameters passed to the function is equal to the number of operands taken by the operator. But in case of a (non-static) member function, the number of parameters reduces by one. This is because the (non-static) member function somehow knows the object it was invoked for.Isn't that fun? Let's now overload more operators for our class.bool operator!=(const Complex);\nbool operator==(const Complex);How to Overload the Not Equal To (!=) Operator in C++So our function definition for the != operator function will be this:bool Complex::operator!=(const Complex c1){\nif(real!=c1.real || real!=c1.imag){\n    return true;\n}\nelse\nreturn false;\n}The return type is a bool, so it returns either true or false.How to Overload the Equal To (==) Operator in C++Similarly for the operator ==: bool Complex::operator==(const Complex c1){\n  if(real == c1.real && imag == c1.imag){\n    return true;\n  }\n  else\n  return false;\n}How to Overload the Get From (<<) Operator in C++So let's now overload the << operator. It will be fun!Let's see the function declaration first:friend ostream& operator<<(ostream&,Complex);\nThere are few changes from the previous functions. Let's understand it more clearly.The function is a friend function. This means that it is not within the scope of any class and cannot be invoked by an object. Also the function returns a reference to the ostream object and it takes two arguments as parameters:\n    Reference to an ostream object.\n    Reference to an object of class type.\n You might be wondering why a friend function? Let's talk about why we need friend functions now.If an operator function is a (non-static) member function, then the left hand side operand will be bound to the this pointer that refers to the object which is calling the function.But we don't want it to be here in the case of the << operator because the left hand side operand for the << operator should be cout. And cout is an object of ostream. So to avoid the binding with the object, we used a friend function here.We can define the << operator like this for our class.ostream& operator<<(ostream& os,Complex c1){\nif(c1.imag<0)\nos<<c1.real<<c1.imag<<\"i\";\nelse\nos<<c1.real<<\"+\"<<c1.imag<<\"i\";\n\nreturn os;\n}So in this way we can overload most of the operators for our class.Some Operators Can't Be Overloaded in C++We cannot overload the following operators in c++:\n    :: (scope resolution operator)\n    . (dot operator)\n    .* (member selection through pointer)\nThey take a name, rather than a value, as their second operand and provide a primary means of referring to members. Allowing them to be overloaded would lead to subtleties. [Stroustroup, 1994]Moreover the ternary operator (?:) and the named operators sizeof and typeid also cannot be overloaded.Errors to Keep in MindAlso remember that the following declaration is an error:int operator+(int,int);\n/*error : cannot redefine operators for built in type.*/As mentioned earlier, Redefining an operator for built in type is an error.One last pointYou should not overload operators like && and || . This is because these operators have a particular order in which an operand is evaluated. Since overloaded operators are just function calls, we cannot guarantee the order of evaluation of the operands.That's it!Happy Coding!You can read my other blogs here.\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 7909, "excerpt": "Classes [/news/how-classes-work-in-cplusplus/] are user-defined types. They\nallow us to represent the meaning of various entities. Defining an operator for\na class gives us a better way to deal with objects. \n\nSo how can we define operators for our classes, and how should we use such\noperators? I will show you how in this article.\n\nLet's begin!\n\nWhat are Operators in C++?\nOperators are symbols which are used to perform operations on various operands.\nFor example:\n\nint x = 5;\nint y = 10;\n\nint z =", "siteName": "freeCodeCamp.org", "publishedTime": "2021-03-15T13:52:01.000Z", "id": "576b0533a1c1bc59b96961437626c71cc4f846ec", "url": "https://www.freecodecamp.org/news/how-to-overload-operators-in-cplusplus/", "domain": "freecodecamp.org", "date": "2023-12-27T18:06:08.404173", "resultUri": "http://localhost:3000/result/576b0533a1c1bc59b96961437626c71cc4f846ec", "query": {"url": ["https://www.freecodecamp.org/news/how-to-overload-operators-in-cplusplus/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "How to Overload Operators in C++", "description": "Classes [/news/how-classes-work-in-cplusplus/] are user-defined types. They allow us to represent the meaning of various entities. Defining an operator for a class gives us a better way to deal with objects.  So how can we define operators for our classes, and how should we use such operators? I will show", "url": "https://www.freecodecamp.org/news/how-to-overload-operators-in-cplusplus/", "image": "https://cdn-media-2.freecodecamp.org/w1280/6043a406a7946308b76830ab.jpg", "image:width": "1280", "image:height": "853"}, "twitter": {"card": "summary_large_image", "title": "How to Overload Operators in C++", "description": "Classes [/news/how-classes-work-in-cplusplus/] are user-defined types. They allow us to represent the meaning of various entities. Defining an operator for a class gives us a better way to deal with objects.  So how can we define operators for our classes, and how should we use such operators? I will show", "url": "https://www.freecodecamp.org/news/how-to-overload-operators-in-cplusplus/", "image": "https://cdn-media-2.freecodecamp.org/w1280/6043a406a7946308b76830ab.jpg", "label1": "Written by", "data1": "Abhilekh Gautam", "label2": "Filed under", "data2": "C++, Programming", "site": "@freecodecamp", "creator": "@abhilekh_gautam"}}}