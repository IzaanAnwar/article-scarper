{"title": "How to deal with nested callbacks and avoid \u201ccallback hell\u201d", "byline": "Zell Liew", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>How to deal with nested callbacks and avoid \u201ccallback hell\u201d</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>JavaScript is a strange language. Once in a while, you have to deal with a callback that\u2019s in another callback that\u2019s in yet another callback.</p><p>People affectionately call this pattern the <em>callback hell</em>.</p><p>It kinda looks like this:</p><pre tabindex=\"0\"><code>firstFunction(args, function() {\n  secondFunction(args, function() {\n    thirdFunction(args, function() {\n      // And so on\u2026\n    });\n  });\n});</code></pre><p>This is JavaScript for you. It\u2019s mind-boggling to see nested callbacks, but I don\u2019t think it\u2019s a \u201chell\u201d. The \u201chell\u201d can be manageable if you know what to do with it.</p><h3 id=\"on-callbacks\">On callbacks</h3><p>I assume you know what callbacks are if you\u2019re reading this article. If you don\u2019t, please read <a href=\"https://zellwk.com/blog/callbacks/\" rel=\"noopener\">this article</a> for an introduction to callbacks before continuing. There, we talk about what callbacks are and why you use them in JavaScript.</p><h3 id=\"solutions-to-callback-hell\">Solutions to callback hell</h3><p>There are four solutions to callback hell:</p><ol><li>Write comments</li><li>Split functions into smaller functions</li><li>Using Promises</li><li>Using Async/await</li></ol><p>Before we dive into the solutions, let\u2019s construct a callback hell together. Why? Because it\u2019s too abstract to see <code>firstFunction</code>, <code>secondFunction</code>, and <code>thirdFunction</code>. We want to make it concrete.</p><h3 id=\"constructing-a-callback-hell\">Constructing a callback hell</h3><p>Let\u2019s imagine we\u2019re trying to make a burger. To make a burger, we need to go through the following steps:</p><ol><li>Get ingredients (we\u2019re gonna assume it\u2019s a beef burger)</li><li>Cook the beef</li><li>Get burger buns</li><li>Put the cooked beef between the buns</li><li>Serve the burger</li></ol><p>If these steps are synchronous, you\u2019ll be looking at a function that resembles this:</p><pre tabindex=\"0\"><code>const makeBurger = () =&gt; {\n  const beef = getBeef();\n  const patty = cookBeef(beef);\n  const buns = getBuns();\n  const burger = putBeefBetweenBuns(buns, beef);\n  return burger;\n};\n\nconst burger = makeBurger();\nserve(burger);</code></pre><p>However, in our scenario, let\u2019s say we can\u2019t make the burger ourselves. We have to instruct a helper on the steps to make the burger. After we instruct the helper, we have to <em>WAIT</em> for the helper to finish before we begin the next step.</p><p>If we want to wait for something in JavaScript, we need to use a callback. To make the burger, we have to get the beef first. We can only cook the beef after we get the beef.</p><pre tabindex=\"0\"><code>const makeBurger = () =&gt; {\n  getBeef(function(beef) {\n    // We can only cook beef after we get it.\n  });\n};</code></pre><p>To cook the beef, we need to pass <code>beef</code> into the <code>cookBeef</code> function. Otherwise, there\u2019s nothing to cook! Then, we have to wait for the beef to get cooked.</p><p>Once the beef gets cooked, we get buns.</p><pre tabindex=\"0\"><code>const makeBurger = () =&gt; {\n  getBeef(function(beef) {\n    cookBeef(beef, function(cookedBeef) {\n      getBuns(function(buns) {\n        // Put patty in bun\n      });\n    });\n  });\n};</code></pre><p>After we get the buns, we need to put the patty between the buns. This is where a burger gets formed.</p><pre tabindex=\"0\"><code>const makeBurger = () =&gt; {\n  getBeef(function(beef) {\n    cookBeef(beef, function(cookedBeef) {\n      getBuns(function(buns) {\n        putBeefBetweenBuns(buns, beef, function(burger) {\n            // Serve the burger\n        });\n      });\n    });\n  });\n};</code></pre><p>Finally, we can serve the burger! But we can\u2019t return <code>burger</code> from <code>makeBurger</code> because it\u2019s asynchronous. We need to accept a callback to serve the burger.</p><pre tabindex=\"0\"><code>const makeBurger = nextStep =&gt; {\n  getBeef(function (beef) {\n    cookBeef(beef, function (cookedBeef) {\n      getBuns(function (buns) {\n        putBeefBetweenBuns(buns, beef, function(burger) {\n          nextStep(burger)\n        })\n      })\n    })\n  })\n}\n\n// Make and serve the burger\nmakeBurger(function (burger) =&gt; {\n  serve(burger)\n})</code></pre><p>(I had fun making this callback hell example ?).</p><p>The <code>makeBurger</code> callback hell is simple to understand. We can read it. It just\u2026 doesn\u2019t look nice.</p><p>If you\u2019re reading <code>makeBurger</code> for the first time, you may think \u201cWhy the hell do we need so many callbacks to make a burger? It doesn\u2019t make sense!\u201d.</p><p>In such a case, you\u2019d want to leave comments to explain your code.</p><pre tabindex=\"0\"><code>// Makes a burger\n// makeBurger contains four steps:\n//   1. Get beef\n//   2. Cook the beef\n//   3. Get buns for the burger\n//   4. Put the cooked beef between the buns\n//   5. Serve the burger (from the callback)\n// We use callbacks here because each step is asynchronous.\n//   We have to wait for the helper to complete the one step\n//   before we can start the next step\n\nconst makeBurger = nextStep =&gt; {\n  getBeef(function(beef) {\n    cookBeef(beef, function(cookedBeef) {\n      getBuns(function(buns) {\n        putBeefBetweenBuns(buns, beef, function(burger) {\n          nextStep(burger);\n        });\n      });\n    });\n  });\n};</code></pre><p>Now, instead of thinking \u201cwtf?!\u201d when you see the callback hell, you get an understanding of why it has to be written this way.</p><h3 id=\"second-solution-to-callback-hell-split-the-callbacks-into-different-functions\">Second solution to callback hell: Split the callbacks into different functions</h3><p>Our callback hell example is already an example of this. Let me show you the step-by-step imperative code and you\u2019ll see why.</p><p>For <code>getBeef</code>, our first callback, we have to go to the fridge to get the beef. There are two fridges in the kitchen. We need to go to the right fridge.</p><pre tabindex=\"0\"><code>const getBeef = nextStep =&gt; {\n  const fridge = leftFright;\n  const beef = getBeefFromFridge(fridge);\n  nextStep(beef);\n};</code></pre><p>To cook beef, we need to put the beef into an oven; turn the oven to 200 degrees, and wait for twenty minutes.</p><pre tabindex=\"0\"><code>const cookBeef = (beef, nextStep) =&gt; {\n  const workInProgress = putBeefinOven(beef);\n  setTimeout(function() {\n    nextStep(workInProgress);\n  }, 1000 * 60 * 20);\n};</code></pre><p>Now imagine if you have to write each of these steps in <code>makeBurger</code>\u2026 you\u2019ll probably faint from the sheer amount of code!</p><p>For a concrete example on splitting callbacks into smaller functions, you can read <a href=\"https://zellwk.com/blog/callbacks#callback-hell\" rel=\"noopener\">this small section</a> in my callback article.</p><h3 id=\"third-solution-to-callback-hell-use-promises\">Third solution to callback hell: Use promises</h3><p>I\u2019m going to assume you know what promises are. If you don\u2019t, please <a href=\"https://zellwk.com/blog/js-promises/\" rel=\"noopener\">read this article</a>.</p><p>Promises can make callback hell much easier to manage. Instead of the nested code you see above, you\u2019ll have this:</p><pre tabindex=\"0\"><code>const makeBurger = () =&gt; {\n  return getBeef()\n    .then(beef =&gt; cookBeef(beef))\n    .then(cookedBeef =&gt; getBuns(beef))\n    .then(bunsAndBeef =&gt; putBeefBetweenBuns(bunsAndBeef));\n};\n\n// Make and serve burger\nmakeBurger().then(burger =&gt; serve(burger));</code></pre><p>If you take advantage of the single-argument style with promises, you can tweak the above to this:</p><pre tabindex=\"0\"><code>const makeBurger = () =&gt; {\n  return getBeef()\n    .then(cookBeef)\n    .then(getBuns)\n    .then(putBeefBetweenBuns);\n};\n\n// Make and serve burger\nmakeBurger().then(serve);</code></pre><p>Much easier to read and manage.</p><p>But the question is how do you convert callback-based code into promise-based code.</p><h4 id=\"converting-callbacks-to-promises\">Converting callbacks to promises</h4><p>To convert callbacks into promises, we need to create a new promise for each callback. We can <code>resolve</code> the promise when the callback is successful. Or we can <code>reject</code> the promise if the callback fails.</p><pre tabindex=\"0\"><code>const getBeefPromise = _ =&gt; {\n  const fridge = leftFright;\n  const beef = getBeefFromFridge(fridge);\n  \n  return new Promise((resolve, reject) =&gt; {\n    if (beef) {\n      resolve(beef);\n    } else {\n      reject(new Error(\u201cNo more beef!\u201d));\n    }\n  });\n};\n\nconst cookBeefPromise = beef =&gt; {\n  const workInProgress = putBeefinOven(beef);\n  \n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(function() {\n      resolve(workInProgress);\n    }, 1000 * 60 * 20);\n  });\n};</code></pre><p>In practice, callbacks would probably be written for you already. If you use Node, each function that contains a callback will have the same syntax:</p><ol><li>The callback would be the last argument</li><li>The callback will always have two arguments. And these arguments are in the same order. (Error first, followed by whatever you\u2019re interested in).</li></ol><pre tabindex=\"0\"><code>// The function that\u2019s defined for you\nconst functionName = (arg1, arg2, callback) =&gt; {\n  // Do stuff here\n  callback(err, stuff);\n};\n\n// How you use the function\nfunctionName(arg1, arg2, (err, stuff) =&gt; {\n  if (err) {\n  console.error(err);\n  }\n  // Do stuff\n});</code></pre><p>If your callback has the same syntax, you can use libraries like <a href=\"https://www.npmjs.com/package/es6-promisify\" rel=\"noopener\">ES6 Promisify </a>or <a href=\"https://www.npmjs.com/package/denodeify\" rel=\"noopener\">Denodeify</a> (de-node-ify) that callback into a promise. If you use Node v8.0 and above, you can use <a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/util.html#util_util_promisify_original\" rel=\"noopener\">util.promisify</a>.</p><p>All three of them work. You can choose any library to work with. There are slight nuances between each method, though. I\u2019ll leave you to check their documentation for how-tos.</p><h3 id=\"fourth-solution-to-callback-hell-use-asynchronous-functions\">Fourth solution to callback hell: Use asynchronous functions</h3><p>To use asynchronous functions, you need to know two things first:</p><ol><li>How to convert callbacks into promises (read above)</li><li>How to use asynchronous functions (<a href=\"https://zellwk.com/blog/async-await\" rel=\"noopener\">read this</a> if you need help).</li></ol><p>With asynchronous functions, you can write <code>makeBurger</code> as if it\u2019s synchronous again!</p><pre tabindex=\"0\"><code>const makeBurger = async () =&gt; {\n  const beef = await getBeef();\n  const cookedBeef = await cookBeef(beef);\n  const buns = await getBuns();\n  const burger = await putBeefBetweenBuns(cookedBeef, buns);\n  return burger;\n};\n\n// Make and serve burger\nmakeBurger().then(serve);</code></pre><p>There\u2019s one improvement we can make to the <code>makeBurger</code> here. You can probably get two helpers to <code>getBuns</code> and <code>getBeef</code> at the same time. This means you can <code>await</code> them both with <code>Promise.all</code>.</p><pre tabindex=\"0\"><code>const makeBurger = async () =&gt; {\n  const [beef, buns] = await Promise.all(getBeef, getBuns);\n  const cookedBeef = await cookBeef(beef);\n  const burger = await putBeefBetweenBuns(cookedBeef, buns);\n  return burger;\n};\n\n// Make and serve burger\nmakeBurger().then(serve);</code></pre><p>(Note: You can do the same with Promises\u2026 but the syntax isn\u2019t as nice and as clear as async/await functions).</p><h3 id=\"wrapping-up\">Wrapping up</h3><p>Callback hell isn\u2019t as hellish as you think. There are four easy ways to manage callback hell:</p><ol><li>Write comments</li><li>Split functions into smaller functions</li><li>Using Promises</li><li>Using Async/await</li></ol><p>This article was originally posted on<em> <a href=\"https://zellwk.com/blog/nested-callbacks\" rel=\"noopener\">my blog</a>.</em><br/>Sign up for my<a href=\"https://zellwk.com/\" rel=\"noopener\"> newsletter</a> if you want more articles to help you become a better frontend developer.</p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nJavaScript is a strange language. Once in a while, you have to deal with a callback that\u2019s in another callback that\u2019s in yet another callback.People affectionately call this pattern the callback hell.It kinda looks like this:firstFunction(args, function() {\n  secondFunction(args, function() {\n    thirdFunction(args, function() {\n      // And so on\u2026\n    });\n  });\n});This is JavaScript for you. It\u2019s mind-boggling to see nested callbacks, but I don\u2019t think it\u2019s a \u201chell\u201d. The \u201chell\u201d can be manageable if you know what to do with it.On callbacksI assume you know what callbacks are if you\u2019re reading this article. If you don\u2019t, please read this article for an introduction to callbacks before continuing. There, we talk about what callbacks are and why you use them in JavaScript.Solutions to callback hellThere are four solutions to callback hell:Write commentsSplit functions into smaller functionsUsing PromisesUsing Async/awaitBefore we dive into the solutions, let\u2019s construct a callback hell together. Why? Because it\u2019s too abstract to see firstFunction, secondFunction, and thirdFunction. We want to make it concrete.Constructing a callback hellLet\u2019s imagine we\u2019re trying to make a burger. To make a burger, we need to go through the following steps:Get ingredients (we\u2019re gonna assume it\u2019s a beef burger)Cook the beefGet burger bunsPut the cooked beef between the bunsServe the burgerIf these steps are synchronous, you\u2019ll be looking at a function that resembles this:const makeBurger = () => {\n  const beef = getBeef();\n  const patty = cookBeef(beef);\n  const buns = getBuns();\n  const burger = putBeefBetweenBuns(buns, beef);\n  return burger;\n};\n\nconst burger = makeBurger();\nserve(burger);However, in our scenario, let\u2019s say we can\u2019t make the burger ourselves. We have to instruct a helper on the steps to make the burger. After we instruct the helper, we have to WAIT for the helper to finish before we begin the next step.If we want to wait for something in JavaScript, we need to use a callback. To make the burger, we have to get the beef first. We can only cook the beef after we get the beef.const makeBurger = () => {\n  getBeef(function(beef) {\n    // We can only cook beef after we get it.\n  });\n};To cook the beef, we need to pass beef into the cookBeef function. Otherwise, there\u2019s nothing to cook! Then, we have to wait for the beef to get cooked.Once the beef gets cooked, we get buns.const makeBurger = () => {\n  getBeef(function(beef) {\n    cookBeef(beef, function(cookedBeef) {\n      getBuns(function(buns) {\n        // Put patty in bun\n      });\n    });\n  });\n};After we get the buns, we need to put the patty between the buns. This is where a burger gets formed.const makeBurger = () => {\n  getBeef(function(beef) {\n    cookBeef(beef, function(cookedBeef) {\n      getBuns(function(buns) {\n        putBeefBetweenBuns(buns, beef, function(burger) {\n            // Serve the burger\n        });\n      });\n    });\n  });\n};Finally, we can serve the burger! But we can\u2019t return burger from makeBurger because it\u2019s asynchronous. We need to accept a callback to serve the burger.const makeBurger = nextStep => {\n  getBeef(function (beef) {\n    cookBeef(beef, function (cookedBeef) {\n      getBuns(function (buns) {\n        putBeefBetweenBuns(buns, beef, function(burger) {\n          nextStep(burger)\n        })\n      })\n    })\n  })\n}\n\n// Make and serve the burger\nmakeBurger(function (burger) => {\n  serve(burger)\n})(I had fun making this callback hell example ?).The makeBurger callback hell is simple to understand. We can read it. It just\u2026 doesn\u2019t look nice.If you\u2019re reading makeBurger for the first time, you may think \u201cWhy the hell do we need so many callbacks to make a burger? It doesn\u2019t make sense!\u201d.In such a case, you\u2019d want to leave comments to explain your code.// Makes a burger\n// makeBurger contains four steps:\n//   1. Get beef\n//   2. Cook the beef\n//   3. Get buns for the burger\n//   4. Put the cooked beef between the buns\n//   5. Serve the burger (from the callback)\n// We use callbacks here because each step is asynchronous.\n//   We have to wait for the helper to complete the one step\n//   before we can start the next step\n\nconst makeBurger = nextStep => {\n  getBeef(function(beef) {\n    cookBeef(beef, function(cookedBeef) {\n      getBuns(function(buns) {\n        putBeefBetweenBuns(buns, beef, function(burger) {\n          nextStep(burger);\n        });\n      });\n    });\n  });\n};Now, instead of thinking \u201cwtf?!\u201d when you see the callback hell, you get an understanding of why it has to be written this way.Second solution to callback hell: Split the callbacks into different functionsOur callback hell example is already an example of this. Let me show you the step-by-step imperative code and you\u2019ll see why.For getBeef, our first callback, we have to go to the fridge to get the beef. There are two fridges in the kitchen. We need to go to the right fridge.const getBeef = nextStep => {\n  const fridge = leftFright;\n  const beef = getBeefFromFridge(fridge);\n  nextStep(beef);\n};To cook beef, we need to put the beef into an oven; turn the oven to 200 degrees, and wait for twenty minutes.const cookBeef = (beef, nextStep) => {\n  const workInProgress = putBeefinOven(beef);\n  setTimeout(function() {\n    nextStep(workInProgress);\n  }, 1000 * 60 * 20);\n};Now imagine if you have to write each of these steps in makeBurger\u2026 you\u2019ll probably faint from the sheer amount of code!For a concrete example on splitting callbacks into smaller functions, you can read this small section in my callback article.Third solution to callback hell: Use promisesI\u2019m going to assume you know what promises are. If you don\u2019t, please read this article.Promises can make callback hell much easier to manage. Instead of the nested code you see above, you\u2019ll have this:const makeBurger = () => {\n  return getBeef()\n    .then(beef => cookBeef(beef))\n    .then(cookedBeef => getBuns(beef))\n    .then(bunsAndBeef => putBeefBetweenBuns(bunsAndBeef));\n};\n\n// Make and serve burger\nmakeBurger().then(burger => serve(burger));If you take advantage of the single-argument style with promises, you can tweak the above to this:const makeBurger = () => {\n  return getBeef()\n    .then(cookBeef)\n    .then(getBuns)\n    .then(putBeefBetweenBuns);\n};\n\n// Make and serve burger\nmakeBurger().then(serve);Much easier to read and manage.But the question is how do you convert callback-based code into promise-based code.Converting callbacks to promisesTo convert callbacks into promises, we need to create a new promise for each callback. We can resolve the promise when the callback is successful. Or we can reject the promise if the callback fails.const getBeefPromise = _ => {\n  const fridge = leftFright;\n  const beef = getBeefFromFridge(fridge);\n  \n  return new Promise((resolve, reject) => {\n    if (beef) {\n      resolve(beef);\n    } else {\n      reject(new Error(\u201cNo more beef!\u201d));\n    }\n  });\n};\n\nconst cookBeefPromise = beef => {\n  const workInProgress = putBeefinOven(beef);\n  \n  return new Promise((resolve, reject) => {\n    setTimeout(function() {\n      resolve(workInProgress);\n    }, 1000 * 60 * 20);\n  });\n};In practice, callbacks would probably be written for you already. If you use Node, each function that contains a callback will have the same syntax:The callback would be the last argumentThe callback will always have two arguments. And these arguments are in the same order. (Error first, followed by whatever you\u2019re interested in).// The function that\u2019s defined for you\nconst functionName = (arg1, arg2, callback) => {\n  // Do stuff here\n  callback(err, stuff);\n};\n\n// How you use the function\nfunctionName(arg1, arg2, (err, stuff) => {\n  if (err) {\n  console.error(err);\n  }\n  // Do stuff\n});If your callback has the same syntax, you can use libraries like ES6 Promisify or Denodeify (de-node-ify) that callback into a promise. If you use Node v8.0 and above, you can use util.promisify.All three of them work. You can choose any library to work with. There are slight nuances between each method, though. I\u2019ll leave you to check their documentation for how-tos.Fourth solution to callback hell: Use asynchronous functionsTo use asynchronous functions, you need to know two things first:How to convert callbacks into promises (read above)How to use asynchronous functions (read this if you need help).With asynchronous functions, you can write makeBurger as if it\u2019s synchronous again!const makeBurger = async () => {\n  const beef = await getBeef();\n  const cookedBeef = await cookBeef(beef);\n  const buns = await getBuns();\n  const burger = await putBeefBetweenBuns(cookedBeef, buns);\n  return burger;\n};\n\n// Make and serve burger\nmakeBurger().then(serve);There\u2019s one improvement we can make to the makeBurger here. You can probably get two helpers to getBuns and getBeef at the same time. This means you can await them both with Promise.all.const makeBurger = async () => {\n  const [beef, buns] = await Promise.all(getBeef, getBuns);\n  const cookedBeef = await cookBeef(beef);\n  const burger = await putBeefBetweenBuns(cookedBeef, buns);\n  return burger;\n};\n\n// Make and serve burger\nmakeBurger().then(serve);(Note: You can do the same with Promises\u2026 but the syntax isn\u2019t as nice and as clear as async/await functions).Wrapping upCallback hell isn\u2019t as hellish as you think. There are four easy ways to manage callback hell:Write commentsSplit functions into smaller functionsUsing PromisesUsing Async/awaitThis article was originally posted on my blog.Sign up for my newsletter if you want more articles to help you become a better frontend developer.\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 10272, "excerpt": "JavaScript is a strange language. Once in a while, you have to deal with a\ncallback that\u2019s in another callback that\u2019s in yet another callback.\n\nPeople affectionately call this pattern the callback hell.\n\nIt kinda looks like this:\n\nfirstFunction(args, function() {\n  secondFunction(args, function() {\n    thirdFunction(args, function() {\n      // And so on\u2026\n    });\n  });\n});\n\nThis is JavaScript for you. It\u2019s mind-boggling to see nested callbacks, but I\ndon\u2019t think it\u2019s a \u201chell\u201d. The \u201chell\u201d can be m", "siteName": "freeCodeCamp.org", "publishedTime": "2019-05-23T15:22:38.000Z", "id": "03ffd0c17a78f3f4a798de76189f7c5afd5e6bc3", "url": "https://www.freecodecamp.org/news/how-to-deal-with-nested-callbacks-and-avoid-callback-hell-1bc8dc4a2012/", "domain": "freecodecamp.org", "date": "2023-12-27T18:09:22.645956", "resultUri": "http://localhost:3000/result/03ffd0c17a78f3f4a798de76189f7c5afd5e6bc3", "query": {"url": ["https://www.freecodecamp.org/news/how-to-deal-with-nested-callbacks-and-avoid-callback-hell-1bc8dc4a2012/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "How to deal with nested callbacks and avoid \u201ccallback hell\u201d", "description": "JavaScript is a strange language. Once in a while, you have to deal with a callback that\u2019s in another callback that\u2019s in yet another callback. People affectionately call this pattern the callback hell. It kinda looks like this: firstFunction(args, function() {   secondFunction(args, function() {    ", "url": "https://www.freecodecamp.org/news/how-to-deal-with-nested-callbacks-and-avoid-callback-hell-1bc8dc4a2012/", "image": "https://cdn-media-1.freecodecamp.org/images/1*csqpgoE3UUyh-aUsqycOfw.jpeg", "image:width": "800", "image:height": "533"}, "twitter": {"card": "summary_large_image", "title": "How to deal with nested callbacks and avoid \u201ccallback hell\u201d", "description": "JavaScript is a strange language. Once in a while, you have to deal with a callback that\u2019s in another callback that\u2019s in yet another callback. People affectionately call this pattern the callback hell. It kinda looks like this: firstFunction(args, function() {   secondFunction(args, function() {    ", "url": "https://www.freecodecamp.org/news/how-to-deal-with-nested-callbacks-and-avoid-callback-hell-1bc8dc4a2012/", "image": "https://cdn-media-1.freecodecamp.org/images/1*csqpgoE3UUyh-aUsqycOfw.jpeg", "label1": "Written by", "data1": "Zell Liew", "label2": "Filed under", "data2": "JavaScript, Tech, Programming, Productivity, Technology", "site": "@freecodecamp"}}}