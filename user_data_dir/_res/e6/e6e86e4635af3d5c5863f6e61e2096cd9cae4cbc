{"title": "Recursion Might Seem Scary \u2013 But it Doesn't Have to Be", "byline": "Dave Gray", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>Recursion Might Seem Scary \u2013 But it Doesn't Have to Be</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>Any concept that we don't fully understand can be scary at first.</p><p>Recursion is a topic that programming students don't learn right away. But that doesn't mean it needs to be scary or cause anxiety.</p><p>In fact, recursion is a concept that we can define rather simply.</p><p>According to <a href=\"https://en.wikipedia.org/wiki/Recursion_(computer_science)\">Wikipedia</a>:</p><blockquote>In computer science, recursion is a method of solving a problem where the solution depends on solutions to smaller instances of the same problem.</blockquote><p>And you can apply recursion in your code by creating a function that calls itself.</p><h2 id=\"any-function-with-a-loop-can-be-recursive-instead\">Any function with a loop can be recursive instead</h2><p>Here is a function called <code>countToTen</code> that uses a while loop to log every number from one to ten:</p><pre tabindex=\"0\"><code>const countToTen = (num = 1) =&gt; {\n    while (num &lt;= 10) {\n        console.log(num);\n        num++;\n    }\n}\n\ncountToTen();\n</code></pre><p>We can write the same function with recursion instead of a loop.</p><p>Notice that recursive functions have two parts:</p><ol><li>The function calls itself (also known as the recursive call)</li><li>At least one condition to exit the recursion (also known as the base case)</li></ol><pre tabindex=\"0\"><code>const countToTen = (num = 1) =&gt; {\n    if (num &gt; 10) return; //base case\n    console.log(num);\n    num++;\n    countToTen(num); //recursive call\n}\n\ncountToTen();\n</code></pre><p>That's not to say we <strong>should</strong> <strong>always</strong> replace loops with recursion.</p><p>There are instances where using recursion is the best choice \u2013 and likewise, there are instances where it is not the best choice.</p><h2 id=\"why-use-recursion\">Why Use Recursion</h2><p>Let's look at some reasons to use recursion. We'll see some examples below.</p><h3 id=\"fewer-lines-of-code\">Fewer Lines of Code</h3><p>Applying recursion usually results in a solution with fewer lines of code than a solution that does not utilize recursion.</p><h3 id=\"more-elegant-code\">More Elegant Code</h3><p>In addition to fewer lines of code, recursive solutions are typically more pleasing to look at. In other words, recursive solutions are usually considered to be elegant.</p><h3 id=\"increased-readability\">Increased Readability</h3><p>Reasons 1 and 2 typically combine to create reason 3 which is the increased readability of your code. Remember, we do not write code just for ourselves. We write code for the developers that follow us and must understand our code.</p><h2 id=\"reasons-not-to-use-recursion\">Reasons NOT to Use Recursion</h2><h3 id=\"performance-losses\">Performance losses</h3><p>Repeating function calls is not as efficient or performant as applying a loop. We do not want to simply choose recursion because we can.</p><h3 id=\"debugging-issues\">Debugging Issues</h3><p>The logic of recursion is not always easy to follow. Utilizing recursion may make your code more difficult to debug.</p><h3 id=\"is-the-readability-improved\">Is the Readability Improved?</h3><p>Increased readability is not guaranteed through the use of recursion. In fact, this may by opinionated and/or situational. You should evaluate the readability, and if it's not improved recursion may not be the best answer.</p><h2 id=\"recursion-examples\">Recursion Examples</h2><p>Recursion problems are interview favorites.</p><p>One such problem asks for a function that returns <code>x</code> numbers of the Fibonacci sequence.</p><p>The Fibonacci sequence adds the two previous numbers of the sequence to create the next number in the sequence. Here are the first ten numbers of the sequence:<br/><code>[0,1,1,2,3,5,8,13,21,34]</code></p><p>We can write this function without recursion:</p><pre tabindex=\"0\"><code>const fibonacci = (num = 2, array = [0, 1]) =&gt; {\n    while (num &gt; 2) {\n        const [nextToLast, last] = array.slice(-2);\n        array.push(nextToLast + last);\n        num -= 1;\n    }\n    return array;\n}\n\nconsole.log(fibonacci(10));\n</code></pre><p>And here is a recursive version of the same function:</p><pre tabindex=\"0\"><code>const fibonacci = (num = 2, array = [0, 1]) =&gt; {\n    if (num &lt; 2) return array.slice(0, array.length - 1);\n    const [nextToLast, last] = array.slice(-2);\n    return fibonacci(num - 1, [...array, nextToLast + last]);\n}\n\nconsole.log(fibonacci(10));\n</code></pre><p>The recursive function does have fewer lines of code. But I am not sure if we can confidently say it is has increased elegance or readability.</p><p>Let's look at another problem where recursion has a greater impact.</p><p>Another interview favorite is asking for a function that returns the nth number in the Fibonacci sequence. Therefore, if the function receives <code>10</code> as a parameter, it should return <code>34</code>.</p><p>Without the use of recursion, a possible solution looks like this:</p><pre tabindex=\"0\"><code>const fibonacciPos = (pos = 1) =&gt; {\n    if (pos &lt; 2) return pos;\n    const seq = [0, 1];\n    for (let i = 2; i &lt;= pos; i++) {\n        const [nextToLast, last] = seq.slice(-2);\n        seq.push(nextToLast + last);\n    }\n    return seq[pos];\n}\n\nconsole.log(fibonacciPos(10));\n</code></pre><p>However, with recursion, the solution is much smaller and arguably more elegant:</p><pre tabindex=\"0\"><code>const fibonacciPos = (pos = 1) =&gt; {\n    if (pos &lt; 2) return pos;\n    return fibonacciPos(pos - 1) + fibonacciPos(pos - 2);\n}\n\nconsole.log(fibonacciPos(10));\n</code></pre><p>Wow! That made a huge difference.</p><p>Notice how the return line actually calls the function twice.</p><p>Do you understand the logic in these recursive functions? If not, spend some time experimenting with them to understand how they work. After you do, you will likely agree that the readability is improved as well.</p><p>To highlight how improved readability is opinionated, let's look at the same recursive function from above written in one line (the line may wrap in your browser, but it is one line of code):</p><pre tabindex=\"0\"><code>const fibonacciPos= pos =&gt; pos &lt; 2 ? pos : fibonacciPos(pos - 1) + fibonacciPos(pos - 2);\n\nconsole.log(fibonacciPos(10));\n</code></pre><p>Our original recursive solution went from four lines of code to just one!</p><p>Is it more readable to you? Do you still follow the logic behind it?</p><p>Your response will depend on your current level of understanding. The one line solution utilizes a ternary statement, features an arrow function without parentheses which also implies a return statement, and applies recursion as before.</p><p>I do not usually write functions like the one line solution above because I frequently teach beginning web development courses. Therefore, I often break my code into deliberate steps that are easier to follow.</p><p>That's not to say there is anything wrong with the one line solution above.</p><p>In fact, the function is elegant, readable, and highly efficient if you understand the logic behind it.</p><p>If you are working on a team, your team might have a style guide. If a one line function is preferred when possible, go for it! If a more deliberate, step-by-step style is preferred, follow your guide. These decisions are completely situational.</p><h2 id=\"conclusion\">Conclusion</h2><p>Recursion can seem scary, but it doesn't have to be.</p><p>We can break the concept of recursion down to a simple definition.</p><p>Do not wield the power of recursion just because you can.</p><p>You should base the decision to use recursion in your code upon efficiency, performance, elegance, and readability.</p><p>You may be wondering where recursion might be applied in the \"real world\" instead of just answering Fibonacci sequence interview questions.</p><p>I'll leave you with a tutorial from my Youtube channel. I not only take a deeper look at the examples above, but I also reveal some \"real world\" instances where applying recursion is the best choice:</p><figure data-test-label=\"fitted\">\n\n</figure>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nAny concept that we don't fully understand can be scary at first.Recursion is a topic that programming students don't learn right away. But that doesn't mean it needs to be scary or cause anxiety.In fact, recursion is a concept that we can define rather simply.According to Wikipedia:In computer science, recursion is a method of solving a problem where the solution depends on solutions to smaller instances of the same problem.And you can apply recursion in your code by creating a function that calls itself.Any function with a loop can be recursive insteadHere is a function called countToTen that uses a while loop to log every number from one to ten:const countToTen = (num = 1) => {\n    while (num <= 10) {\n        console.log(num);\n        num++;\n    }\n}\n\ncountToTen();\nWe can write the same function with recursion instead of a loop.Notice that recursive functions have two parts:The function calls itself (also known as the recursive call)At least one condition to exit the recursion (also known as the base case)const countToTen = (num = 1) => {\n    if (num > 10) return; //base case\n    console.log(num);\n    num++;\n    countToTen(num); //recursive call\n}\n\ncountToTen();\nThat's not to say we should always replace loops with recursion.There are instances where using recursion is the best choice \u2013 and likewise, there are instances where it is not the best choice.Why Use RecursionLet's look at some reasons to use recursion. We'll see some examples below.Fewer Lines of CodeApplying recursion usually results in a solution with fewer lines of code than a solution that does not utilize recursion.More Elegant CodeIn addition to fewer lines of code, recursive solutions are typically more pleasing to look at. In other words, recursive solutions are usually considered to be elegant.Increased ReadabilityReasons 1 and 2 typically combine to create reason 3 which is the increased readability of your code. Remember, we do not write code just for ourselves. We write code for the developers that follow us and must understand our code.Reasons NOT to Use RecursionPerformance lossesRepeating function calls is not as efficient or performant as applying a loop. We do not want to simply choose recursion because we can.Debugging IssuesThe logic of recursion is not always easy to follow. Utilizing recursion may make your code more difficult to debug.Is the Readability Improved?Increased readability is not guaranteed through the use of recursion. In fact, this may by opinionated and/or situational. You should evaluate the readability, and if it's not improved recursion may not be the best answer.Recursion ExamplesRecursion problems are interview favorites.One such problem asks for a function that returns x numbers of the Fibonacci sequence.The Fibonacci sequence adds the two previous numbers of the sequence to create the next number in the sequence. Here are the first ten numbers of the sequence:[0,1,1,2,3,5,8,13,21,34]We can write this function without recursion:const fibonacci = (num = 2, array = [0, 1]) => {\n    while (num > 2) {\n        const [nextToLast, last] = array.slice(-2);\n        array.push(nextToLast + last);\n        num -= 1;\n    }\n    return array;\n}\n\nconsole.log(fibonacci(10));\nAnd here is a recursive version of the same function:const fibonacci = (num = 2, array = [0, 1]) => {\n    if (num < 2) return array.slice(0, array.length - 1);\n    const [nextToLast, last] = array.slice(-2);\n    return fibonacci(num - 1, [...array, nextToLast + last]);\n}\n\nconsole.log(fibonacci(10));\nThe recursive function does have fewer lines of code. But I am not sure if we can confidently say it is has increased elegance or readability.Let's look at another problem where recursion has a greater impact.Another interview favorite is asking for a function that returns the nth number in the Fibonacci sequence. Therefore, if the function receives 10 as a parameter, it should return 34.Without the use of recursion, a possible solution looks like this:const fibonacciPos = (pos = 1) => {\n    if (pos < 2) return pos;\n    const seq = [0, 1];\n    for (let i = 2; i <= pos; i++) {\n        const [nextToLast, last] = seq.slice(-2);\n        seq.push(nextToLast + last);\n    }\n    return seq[pos];\n}\n\nconsole.log(fibonacciPos(10));\nHowever, with recursion, the solution is much smaller and arguably more elegant:const fibonacciPos = (pos = 1) => {\n    if (pos < 2) return pos;\n    return fibonacciPos(pos - 1) + fibonacciPos(pos - 2);\n}\n\nconsole.log(fibonacciPos(10));\nWow! That made a huge difference.Notice how the return line actually calls the function twice.Do you understand the logic in these recursive functions? If not, spend some time experimenting with them to understand how they work. After you do, you will likely agree that the readability is improved as well.To highlight how improved readability is opinionated, let's look at the same recursive function from above written in one line (the line may wrap in your browser, but it is one line of code):const fibonacciPos= pos => pos < 2 ? pos : fibonacciPos(pos - 1) + fibonacciPos(pos - 2);\n\nconsole.log(fibonacciPos(10));\nOur original recursive solution went from four lines of code to just one!Is it more readable to you? Do you still follow the logic behind it?Your response will depend on your current level of understanding. The one line solution utilizes a ternary statement, features an arrow function without parentheses which also implies a return statement, and applies recursion as before.I do not usually write functions like the one line solution above because I frequently teach beginning web development courses. Therefore, I often break my code into deliberate steps that are easier to follow.That's not to say there is anything wrong with the one line solution above.In fact, the function is elegant, readable, and highly efficient if you understand the logic behind it.If you are working on a team, your team might have a style guide. If a one line function is preferred when possible, go for it! If a more deliberate, step-by-step style is preferred, follow your guide. These decisions are completely situational.ConclusionRecursion can seem scary, but it doesn't have to be.We can break the concept of recursion down to a simple definition.Do not wield the power of recursion just because you can.You should base the decision to use recursion in your code upon efficiency, performance, elegance, and readability.You may be wondering where recursion might be applied in the \"real world\" instead of just answering Fibonacci sequence interview questions.I'll leave you with a tutorial from my Youtube channel. I not only take a deeper look at the examples above, but I also reveal some \"real world\" instances where applying recursion is the best choice:\n        \n          \n            \n          \n        \n      \n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 7503, "excerpt": "Any concept that we don't fully understand can be scary at first.\n\nRecursion is a topic that programming students don't learn right away. But that\ndoesn't mean it needs to be scary or cause anxiety.\n\nIn fact, recursion is a concept that we can define rather simply.\n\nAccording to Wikipedia\n[https://en.wikipedia.org/wiki/Recursion_(computer_science)]:\n\n> In computer science, recursion is a method of solving a problem where the\nsolution depends on solutions to smaller instances of the same problem.", "siteName": "freeCodeCamp.org", "publishedTime": "2021-05-07T16:59:53.000Z", "id": "e6e86e4635af3d5c5863f6e61e2096cd9cae4cbc", "url": "https://www.freecodecamp.org/news/recursion-doesnt-have-to-be-scary/", "domain": "freecodecamp.org", "date": "2023-12-27T18:06:01.454508", "resultUri": "http://localhost:3000/result/e6e86e4635af3d5c5863f6e61e2096cd9cae4cbc", "query": {"url": ["https://www.freecodecamp.org/news/recursion-doesnt-have-to-be-scary/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "Recursion Might Seem Scary \u2013 But it Doesn't Have to Be", "description": "Any concept that we don't fully understand can be scary at first. Recursion is a topic that programming students don't learn right away. But that doesn't mean it needs to be scary or cause anxiety. In fact, recursion is a concept that we can define rather simply. According to Wikipedia", "url": "https://www.freecodecamp.org/news/recursion-doesnt-have-to-be-scary/", "image": "https://www.freecodecamp.org/news/content/images/2021/05/recursion-image.jpeg", "image:width": "2000", "image:height": "1333"}, "twitter": {"card": "summary_large_image", "title": "Recursion Might Seem Scary \u2013 But it Doesn't Have to Be", "description": "Any concept that we don't fully understand can be scary at first. Recursion is a topic that programming students don't learn right away. But that doesn't mean it needs to be scary or cause anxiety. In fact, recursion is a concept that we can define rather simply. According to Wikipedia", "url": "https://www.freecodecamp.org/news/recursion-doesnt-have-to-be-scary/", "image": "https://www.freecodecamp.org/news/content/images/2021/05/recursion-image.jpeg", "label1": "Written by", "data1": "Dave Gray", "label2": "Filed under", "data2": "JavaScript, Programming, Web Development, Recursion, Software Development, Coding", "site": "@freecodecamp", "creator": "@yesdavidgray"}}}