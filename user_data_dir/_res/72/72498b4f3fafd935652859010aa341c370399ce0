{"title": "Idempotence in HTTP Methods \u2013 Explained with CRUD Examples", "byline": "Yemi Ojedapo", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>Idempotence in HTTP Methods \u2013 Explained with CRUD Examples</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>Idempotence refers to a program's ability to maintain a particular result even after repeated actions. </p><p>For example, let's say you have a button that only opens a door when pressed. This button does not have the ability to close the door, so it stays open even when it's pressed repeatedly. It simply remains in the state it was changed to by the first press.</p><p>This same logic applies to HTTP methods that are idempotent. Operating on idempotent HTTP methods repeatedly won't have any additional effect beyond the initial execution. </p><p>Understanding idempotence is important for maintaining the consistency of HTTP methods and API design. Idempotence has a significant impact on API design, as it influences how API endpoints should behave when processing requests from clients. </p><p>In this tutorial, I'll explain the concept of idempotence and the role it plays<strong> </strong>in building robust and functional APIs. You'll also learn about what safe methods are, how they relate to idempotence, and how to implement idempotency in non-idempotent methods. </p><h2 id=\"prerequisites\">Prerequisites</h2><p>Before understanding and implementing idempotence in API design, it's essential to have a solid foundation in the following areas:</p><ul><li>RESTful Principles</li><li>Fundamentals of HTTP methods</li><li>API Development </li><li>HTTP Status codes</li><li>Basics of Web development.</li></ul><h2 id=\"idempotence-example\">Idempotence Example \u00a0</h2><p>Let's start off with an example of idempotence in action. We'll create a function that uses the DELETE method to delete data from a web page:</p><pre tabindex=\"0\"><code>\n<span>from</span> flask <span>import</span> Flask<span>,</span> jsonify<span>,</span> abort\n\napp <span>=</span> Flask<span>(</span>__name__<span>)</span>\n\nweb_page_data <span>=</span> <span>[</span>\n   <span>{</span><span>\"id\"</span><span>:</span> <span>1</span><span>,</span> <span>\"content\"</span><span>:</span> <span>\"Row 1 data\"</span><span>}</span><span>,</span>\n   <span>{</span><span>\"id\"</span><span>:</span> <span>2</span><span>,</span> <span>\"content\"</span><span>:</span> <span>\"Row 2 data\"</span><span>}</span><span>,</span>\n   <span># Add more rows as needed</span>\n<span>]</span>\n\n<span>@app<span>.</span>route</span><span>(</span><span>'/delete_row/&lt;int:row_id&gt;'</span><span>,</span> methods<span>=</span><span>[</span><span>'DELETE'</span><span>]</span><span>)</span>\n<span>def</span> <span>delete_row</span><span>(</span>row_id<span>)</span><span>:</span>\n   <span># Find the row to delete</span>\n   row_to_delete <span>=</span> <span>next</span><span>(</span><span>(</span>row <span>for</span> row <span>in</span> web_page_data <span>if</span> row<span>[</span><span>\"id\"</span><span>]</span> <span>==</span> row_id<span>)</span><span>,</span> <span>None</span><span>)</span>\n   \n   <span>if</span> row_to_delete<span>:</span>\n       <span># Simulate deletion</span>\n       web_page_data<span>.</span>remove<span>(</span>row_to_delete<span>)</span>\n       <span>return</span> jsonify<span>(</span><span>{</span><span>\"message\"</span><span>:</span> <span><span>f\"Row </span><span><span>{</span>row_id<span>}</span></span><span> deleted successfully.\"</span></span><span>}</span><span>)</span><span>,</span> <span>200</span>\n   <span>else</span><span>:</span>\n       abort<span>(</span><span>404</span><span>,</span> description<span>=</span><span><span>f\"Row </span><span><span>{</span>row_id<span>}</span></span><span> not found.\"</span></span><span>)</span>\n\n<span>if</span> __name__ <span>==</span> <span>'__main__'</span><span>:</span>\n   app<span>.</span>run<span>(</span>debug<span>=</span><span>True</span><span>)</span>\n</code></pre><p>This function is expected to delete the rows chosen by the user. Now because of the idempotent nature of the DELETE method, the data will be deleted once, even when called repeatedly. But subsequent calls will return a 404 error since the data has already been deleted by the first call. \u00a0</p><p>Let\u2019s look at another example with the GET method. The GET method is used to retrieve data from a resource. Let\u2019s create a function that uses the GET method to retrieve a username:</p><pre tabindex=\"0\"><code><span>import</span> requests\n\n<span>def</span> <span>get_username</span><span>(</span><span>)</span><span>:</span>\n    url <span>=</span> <span>'https://api.example.com/get_username'</span>\n    <span>try</span><span>:</span>\n        response <span>=</span> requests<span>.</span>get<span>(</span>url<span>)</span>\n        <span>if</span> response<span>.</span>status_code <span>==</span> <span>200</span><span>:</span>\n            <span>return</span> response<span>.</span>json<span>(</span><span>)</span><span>[</span><span>'username'</span><span>]</span>\n        <span>else</span><span>:</span>\n            <span>return</span> <span>None</span>\n    <span>except</span> requests<span>.</span>RequestException <span>as</span> e<span>:</span>\n        <span>print</span><span>(</span><span><span>f\"Error occurred: </span><span><span>{</span>e<span>}</span></span><span>\"</span></span><span>)</span>\n        <span>return</span> <span>None</span>\n\n<span># Usage</span>\nusername <span>=</span> get_username<span>(</span><span>)</span>\n<span>if</span> username<span>:</span>\n    <span>print</span><span>(</span><span><span>f\"The username is: </span><span><span>{</span>username<span>}</span></span><span>\"</span></span><span>)</span>\n<span>else</span><span>:</span>\n    <span>print</span><span>(</span><span>\"Failed to retrieve the username.\"</span><span>)</span>\n</code></pre><p>In this example, we define the <code>get_username()</code> function, which sends a GET request to the API endpoint to retrieve the username. If the request is successful, we extract the username from the JSON response and return it. But if any error occurs during the request, we handle it and return <code>None</code>.</p><p>Now the idempotent nature of the GET method ensures that even if you call <code>get_username()</code> multiple times, the same username will be fetched from the API each time. The result will always be the same which is to fetch the username from the resource.</p><h3 id=\"idempotent-vs-non-idempotent-http-methods-\">Idempotent vs. Non-Idempotent HTTP Methods:</h3><p>HTTP methods play crucial roles in determining how data is fetched, modified, or created when interacting with APIs. And Idempotency is one of the important concepts that influences data consistency and reliability in the methods used . </p><p>Here's a breakdown of the different methods based on their idempotency.</p><h4 id=\"idempotent-methods-\">Idempotent methods:</h4><ul><li>GET</li><li>HEAD</li><li>PUT</li><li>DELETE</li><li>OPTIONS</li><li>TRACE</li></ul><h4 id=\"non-idempotent-methods-\">Non-idempotent methods:</h4><ul><li>POST</li><li>PATCH</li><li>CONNECT</li></ul><h2 id=\"safe-methods\">Safe Methods</h2><p>In our previous example, we used the GET method to retrieve a username and this had no side effect on the server. This is because it is a safe method. </p><p>A safe method is a type of method that doesn\u2019t modify the server\u2019s state or the resource being accessed. In other words, they perform read-only operations used to retrieve data or for resource representation.</p><p>When you make a request using a safe method, the server does not perform any operations that modify the resource's state. Like in our previous example, we retrieved the username from the webpage which is the resource without changing anything in the server. </p><p>All safe methods are automatically idempotent, but not all idempotent methods are safe. This is because while idempotent methods produce consistent results when called repeatedly, some of them may still modify the server's state or the resource being accessed.</p><p>Like in our first example, the DELETE method is idempotent, because deleting a resource multiple times will have the same effect. But it's not safe, as it changes the server's state by removing the resource.</p><p>Here\u2019s a classification of HTTP methods based on their safe status:</p><h4 id=\"safe-methods-\">Safe methods:</h4><ul><li>GET</li><li>OPTIONS</li><li>HEAD</li></ul><h4 id=\"unsafe-methods-\">Unsafe methods:</h4><ul><li>DELETE</li><li>POST</li><li>PUT</li><li>PATCH</li></ul><h3 id=\"why-is-post-not-idempotent\">Why is POST not idempotent?</h3><p>POST is an HTTP method that sends information to a server. When you make a POST request, you typically submit data to create a new resource or trigger a server-side action. Therefore, making the same request multiple times can result in different outcomes and side effects on the server. This can lead to duplicated data, starting server resources, and reducing performance because of the repeated action.</p><p>Unlike idempotent methods like GET, PUT, and DELETE, which have consistent results regardless of repetition, POST requests can cause changes to the server's state with each invocation. </p><p>POST requests often create new resources on the server. Repeating the same POST request will generate multiple identical resources, potentially leading to duplication.</p><p>This is similar to DELETE which is an idempotent method but not a safe method. Deleting the last entry in a collection using a single DELETE request would be considered idempotent. But if a developer creates a function that deletes the last entry, that would trigger DELETE multiple times. Subsequent DELETE calls would have different effects, as each one removes a unique entry. This would be considered non-idempotent.</p><h2 id=\"how-to-achieve-idempotency-with-non-idempotent-methods\">How to Achieve Idempotency with Non-Idempotent Methods</h2><p>Idempotency isn't only a property inherent to certain methods \u2013 it can also be implemented as a feature of a non-idempotent method. \u00a0</p><p>Here are some techniques to achieve idempotency even with non-idempotent methods.</p><h3 id=\"unique-identifiers\">Unique Identifiers</h3><p>Adding unique identifiers to every request is one of the most common techniques used to implement idempotency. It works by tracking whether the operation has already been performed or not. If it's a duplicate (a repeat request), the server knows it's already dealt with that request and simply ignores it, ensuring that no side effects occur. </p><p>Here's an example of how it works:</p><pre tabindex=\"0\"><code><span>from</span> uuid <span>import</span> uuid4\n \n<span>def</span> <span>process_order</span><span>(</span>unique_id<span>,</span> order_data<span>)</span><span>:</span>\n    <span>if</span> Order<span>.</span>objects<span>.</span><span>filter</span><span>(</span>unique_id<span>=</span>unique_id<span>)</span><span>.</span>exists<span>(</span><span>)</span><span>:</span>\n        <span>return</span> HttpResponse<span>(</span>status<span>=</span><span>409</span><span>)</span>  <span># Conflict</span>\n    order <span>=</span> Order<span>.</span>objects<span>.</span>create<span>(</span>unique_id<span>=</span>unique_id<span>,</span> <span>**</span>order_data<span>)</span>\n    <span>return</span> HttpResponse<span>(</span>status<span>=</span><span>201</span><span>,</span> content_type<span>=</span><span>\"application/json\"</span><span>)</span>\n\n<span># Example usage</span>\npost_data <span>=</span> <span>{</span><span>\"products\"</span><span>:</span> <span>[</span><span>.</span><span>.</span><span>.</span><span>]</span><span>}</span>\nheaders <span>=</span> <span>{</span><span>\"X-Unique-ID\"</span><span>:</span> <span>str</span><span>(</span>uuid4<span>(</span><span>)</span><span>)</span><span>}</span>\nrequests<span>.</span>post<span>(</span><span>\"https://api.example.com/orders\"</span><span>,</span> data<span>=</span>post_data<span>,</span> headers<span>=</span>headers<span>)</span>\n</code></pre><p>In this code snippet, we define a function called <code>process_order</code> that creates orders in an API, using unique identifiers to implement idempotency. </p><p>Here's a breakdown of the code:</p><h4 id=\"importing-the-unique-identifier-generator-\">Importing the Unique Identifier Generator:</h4><p><code>from uuid import uuid4</code>: The code snippet starts by importing the <code>uuid4</code> function from the <code>uuid</code> module. This function generates unique identifiers, which are used to achieve idempotency in this code.</p><h4 id=\"defining-the-process_order-function-\">Defining the <code>process_order</code> Function:</h4><p><code>def process_order(unique_id, order_data)</code>: This line defines a function named process_order that takes two arguments:</p><ul><li><code>unique_id</code>: This is a string representing a unique identifier for the request. This ensures no duplicate orders are created with the same identifier.</li><li><code>order_data</code>: This is a dictionary containing the actual order data, like product information and customer details.</li></ul><h4 id=\"checking-for-existing-orders-\">Checking for Existing Orders:</h4><p><code>if Order.objects.filter(unique_id=unique_id).exists()</code>: This line checks if an order with the same unique_id already exists in the database.</p><p><code>Order.objects.filter(unique_id=unique_id).exists()</code> queries the Order model for orders with the matching unique_id and checks if any orders were found in the query result. If an order is found, it means the same request was already processed.</p><h4 id=\"handling-existing-orders-\">Handling existing orders:</h4><p><code>return HttpResponse(status=409)</code>: If an order with the same unique_id already exists, the function immediately returns an HTTP response with status code 409 indicating a conflict. This prevents duplicate orders from being created.</p><h4 id=\"creating-a-new-order-if-unique-\">Creating a new order (if unique):</h4><p><code>order = Order.objects.create(unique_id=unique_id, **order_data )</code>: This line only runs if no existing order is found.</p><p><code>Order.objects.create:</code> creates a new object in the Order model.</p><p><code>unique_id=unique_id</code> sets the unique_id attribute of the new order to the provided unique_id.</p><p><code>order_data</code>: spreads the dictionary order_data as keyword arguments to the order model's constructor, setting other relevant attributes like products and customer information.</p><h4 id=\"sending-a-success-response-\">Sending a success response:</h4><p><code>return HttpResponse(status=201, content_type=\"application/json\")</code>: If the order creation is successful, the function will return an HTTP response with status code 201 which shows a successful creation. It also specifies the response content type as JSON, assuming the order data might be returned in JSON format.</p><p><code>post_data = {\"products\": [...]}</code>: an example request, defines a dictionary containing the actual order data, like a list of products.</p><p><code>headers = {\"X-Unique-ID\": str(uuid4())}</code>: This line creates a dictionary containing a custom header named X-Unique-ID. It generates a unique identifier string using uuid4() and adds it to the header.</p><p><code>requests.post(\"https://api.example.com/orders\", data=post_data, headers=headers</code>): This line sends a POST request to the API endpoint <code>https://api.example.com/orders</code> \u00a0with the provided <code>post_data</code> and headers.</p><h4 id=\"how-does-this-implement-idempotence\">How does this implement idempotence?</h4><p>It does so by using a unique identifier <code>(unique_id)</code> for each order. </p><p>It checks if an order with the same identifier already exists in the database. If it returns true, it returns a 409 Conflict status. Otherwise, it creates a new order and responds with a 201 Created status. The unique identifier prevents duplicate orders, making the system idempotent.</p><h3 id=\"token-based-authorization\">Token-based Authorization</h3><p>Token-based authorization is a form of authorization that assigns temporary tokens for each non-idempotent action. Once the action is completed, the token is invalidated. If the same request comes again with the same token, the server recognizes it as invalid and refuses the request, thereby preventing duplicate actions.</p><pre tabindex=\"0\"><code>// Generate a unique token for this action\nconst token = generateToken();\n\nfetch(\"https://api.example.com/create-user\", {\n    method: \"POST\",\n    body: JSON.stringify({ username, password }),\n    headers: {\n        Authorization: `Bearer ${token}`,\n        \"Content-Type\": \"application/json\",\n    },\n})\n    .then(response =&gt; {\n        // Handle successful response\n        if (response.ok) {\n            // Do something with the successful response\n        } else {\n            // Handle non-successful response\n        }\n    })\n    .catch(error =&gt; {\n        // Handle error\n        console.error(\"Error occurred:\", error);\n    })\n    .finally(() =&gt; {\n        // Invalidate token after successful action or in case of an error\n        invalidateToken(token);\n    });\n\n// Simple implementation for generating a token\nfunction generateToken() {\n    return Math.random().toString(36).substr(2);\n}\n\n// Simple implementation for invalidating a token\nfunction invalidateToken(token) {\n    // Add your logic to invalidate the token, e.g., remove it from storage\n}\n</code></pre><p>Here's a breakdown of the code:</p><h4 id=\"generating-a-unique-token-\">Generating a unique token:</h4><p><code>const token = generateToken()</code>: This line calls a function named <code>generateToken()</code> (which is assumed to be defined elsewhere) that generates a unique token string. This token will be used for authorization and idempotency.</p><h4 id=\"sending-the-post-request-\">Sending the <code>POST</code> request:</h4><p><code>fetch(\"https://api.example.com/create-user\", { ... })</code>: This line uses the fetch API to send a POST request to the API endpoint <code>https://api.example.com/create-user</code>. </p><p><code>method: \"POST\"</code>: This specifies the HTTP method as POST, indicating the intention to create a new user.</p><p><code>body: JSON.stringify({ username, password })</code>: This defines the request body with user details like username and password. The data is converted to JSON format before sending.</p><p><code>headers: { Authorization:Bearer ${token}}</code>: This sets the Authorization header in the request. The header value includes the generated token prefixed with \"Bearer \".</p><h4 id=\"handling-the-response-\">Handling the Response:</h4><p><code>.then(response =&gt; { ... })</code>: This block defines the code to execute if the request is successful. You would handle things like storing user information or redirecting the user upon successful user creation.</p><p><code>.catch(error =&gt; { ... }):</code> This block defines the code to execute if the request encounters an error. You would handle any error messages or handle specific error scenarios here.</p><h4 id=\"invalidating-the-token-\">Invalidating the Token:</h4><p><code>invalidateToken(token)</code>: This line calls a function named <code>invalidateToken(token)</code> ( which is assumed to be defined elsewhere) which would likely mark the used token as invalid. This ensures the same token cannot be used for subsequent requests, adding to the idempotency guarantee.</p><h4 id=\"how-does-this-implement-idempotence-1\">How does this implement Idempotence?</h4><p>This code snippet uses token-based authorization to implement idempotency in a POST request to create a user on an API. If a user creation request is accidentally sent multiple times, a new unique token is generated each time and used in the Authorization header.</p><p>The API server can recognize and verify the unique token, and since the user creation action has already been performed (assuming it's successful the first time), it won't create duplicate users due to subsequent identical requests.</p><p>An ETag header (Entity Tag) is an HTTP header used for web cache validation and conditional requests. It is mainly used for \u00a0PUT requests, that only update resources if they haven't changed since the last check.</p><p>When you want to update a resource, the server sends you its ETag which is then included in your PUT request along with the updated data. If the ETag hasn't changed (meaning the resource remains the same), the server accepts the update. But if the ETag has changed, the server rejects the update, preventing it from overwriting someone else's changes.</p><pre tabindex=\"0\"><code><span>def</span> <span>update_article</span><span>(</span>article_id<span>,</span> content<span>)</span><span>:</span>\n    <span># Get existing article and its ETag</span>\n    article <span>=</span> Article<span>.</span>objects<span>.</span>get<span>(</span>pk<span>=</span>article_id<span>)</span>\n    etag <span>=</span> article<span>.</span>etag\n    \n    <span># Check if ETag matches with request header</span>\n    <span>if</span> request<span>.</span>headers<span>.</span>get<span>(</span><span>\"If-Match\"</span><span>)</span> <span>!=</span> etag<span>:</span>\n        <span>return</span> HttpResponse<span>(</span>status<span>=</span><span>409</span><span>)</span>  <span># Conflict</span>\n    \n    <span># Update article content and generate new ETag</span>\n    article<span>.</span>content <span>=</span> content\n    article<span>.</span>save<span>(</span><span>)</span>\n    new_etag <span>=</span> article<span>.</span>etag\n    \n    <span># Return success response with updated ETag</span>\n    <span>return</span> HttpResponse<span>(</span>status<span>=</span><span>200</span><span>,</span> content_type<span>=</span><span>\"text/plain\"</span><span>,</span> content<span>=</span>new_etag<span>)</span>\n</code></pre><p>In this code snippet, we define a function called <code>update_article</code> that allows you to update the content of an existing article based on its ID and new content. It implements idempotency using the ETag header technique.</p><p>Here's a step-by-step explanation of how it works;</p><h4 id=\"getting-the-existing-article-and-its-etag-\">Getting the Existing Article and its ETag:</h4><p><code>article = Article.objects.get(pk=article_id):</code> This line fetches the article with the provided article_id from the database using the Article model.</p><p><code>etag = article.etag:</code> This line extracts the ETag value from the retrieved article object. The ETag serves as a unique identifier for the article's current state.</p><h4 id=\"checking-for-a-match-\">Checking for a Match:</h4><p><code>if request.headers.get(\"If-Match\") != etag:</code> This line checks if the ETag header provided in the request matches the ETag of the retrieved article.</p><p><code>return HttpResponse(status=409)</code>: If the ETag doesn't match, it indicates that the article might have been updated by another request since the client retrieved its information. The function returns a 409 Conflict response, which prevents accidental data corruption.</p><h4 id=\"updating-the-article-content-and-generating-a-new-etag-\">Updating the Article Content and generating a new ETag:</h4><p><code>article.content = content:</code> This line updates the article's content with the new content received in the request.</p><p><code>article.save():</code> This line saves the updated article back to the database.</p><p><code>new_etag = article.etag:</code> This line retrieves the new ETag generated for the updated article after saving it.</p><h4 id=\"returning-the-success-response-with-the-new-etag-\">Returning the Success Response with the new ETag:</h4><p><code>return HttpResponse(status=200, content_type=\"text/plain\", content=new_etag)</code>: returns a successful 200 OK response, including the content type (\"text/plain\") and the updated ETag of the article in the response body.</p><h4 id=\"how-does-this-implement-idempotence-2\">How does this implement idempotence?</h4><p>This code ensures that if the same update request is sent multiple times with the same ETag, the update will only be performed once, preventing duplicate updates and maintaining data consistency. The new ETag is then provided in the response to help the client keep track of the article's state for future interactions.</p><h2 id=\"conclusion\">Conclusion</h2><p>In this tutorial, we highlighted the difference between safe methods like GET, which retrieves data without side effects, and non-idempotent methods like POST, which can have different outcomes with each repetition. </p><p>We also explored techniques you can apply to achieve idempotence in non-idempotent methods, emphasizing the importance of designing APIs that prioritize consistency and reliability.</p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nIdempotence refers to a program's ability to maintain a particular result even after repeated actions. For example, let's say you have a button that only opens a door when pressed. This button does not have the ability to close the door, so it stays open even when it's pressed repeatedly. It simply remains in the state it was changed to by the first press.This same logic applies to HTTP methods that are idempotent. Operating on idempotent HTTP methods repeatedly won't have any additional effect beyond the initial execution. Understanding idempotence is important for maintaining the consistency of HTTP methods and API design. Idempotence has a significant impact on API design, as it influences how API endpoints should behave when processing requests from clients. In this tutorial, I'll explain the concept of idempotence and the role it plays in building robust and functional APIs. You'll also learn about what safe methods are, how they relate to idempotence, and how to implement idempotency in non-idempotent methods. PrerequisitesBefore understanding and implementing idempotence in API design, it's essential to have a solid foundation in the following areas:RESTful PrinciplesFundamentals of HTTP methodsAPI Development HTTP Status codesBasics of Web development.Idempotence Example \u00a0Let's start off with an example of idempotence in action. We'll create a function that uses the DELETE method to delete data from a web page:\nfrom flask import Flask, jsonify, abort\n\napp = Flask(__name__)\n\nweb_page_data = [\n   {\"id\": 1, \"content\": \"Row 1 data\"},\n   {\"id\": 2, \"content\": \"Row 2 data\"},\n   # Add more rows as needed\n]\n\n@app.route('/delete_row/<int:row_id>', methods=['DELETE'])\ndef delete_row(row_id):\n   # Find the row to delete\n   row_to_delete = next((row for row in web_page_data if row[\"id\"] == row_id), None)\n   \n   if row_to_delete:\n       # Simulate deletion\n       web_page_data.remove(row_to_delete)\n       return jsonify({\"message\": f\"Row {row_id} deleted successfully.\"}), 200\n   else:\n       abort(404, description=f\"Row {row_id} not found.\")\n\nif __name__ == '__main__':\n   app.run(debug=True)\nThis function is expected to delete the rows chosen by the user. Now because of the idempotent nature of the DELETE method, the data will be deleted once, even when called repeatedly. But subsequent calls will return a 404 error since the data has already been deleted by the first call. \u00a0Let\u2019s look at another example with the GET method. The GET method is used to retrieve data from a resource. Let\u2019s create a function that uses the GET method to retrieve a username:import requests\n\ndef get_username():\n    url = 'https://api.example.com/get_username'\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            return response.json()['username']\n        else:\n            return None\n    except requests.RequestException as e:\n        print(f\"Error occurred: {e}\")\n        return None\n\n# Usage\nusername = get_username()\nif username:\n    print(f\"The username is: {username}\")\nelse:\n    print(\"Failed to retrieve the username.\")\nIn this example, we define the get_username() function, which sends a GET request to the API endpoint to retrieve the username. If the request is successful, we extract the username from the JSON response and return it. But if any error occurs during the request, we handle it and return None.Now the idempotent nature of the GET method ensures that even if you call get_username() multiple times, the same username will be fetched from the API each time. The result will always be the same which is to fetch the username from the resource.Idempotent vs. Non-Idempotent HTTP Methods:HTTP methods play crucial roles in determining how data is fetched, modified, or created when interacting with APIs. And Idempotency is one of the important concepts that influences data consistency and reliability in the methods used . Here's a breakdown of the different methods based on their idempotency.Idempotent methods:GETHEADPUTDELETEOPTIONSTRACENon-idempotent methods:POSTPATCHCONNECTSafe MethodsIn our previous example, we used the GET method to retrieve a username and this had no side effect on the server. This is because it is a safe method. A safe method is a type of method that doesn\u2019t modify the server\u2019s state or the resource being accessed. In other words, they perform read-only operations used to retrieve data or for resource representation.When you make a request using a safe method, the server does not perform any operations that modify the resource's state. Like in our previous example, we retrieved the username from the webpage which is the resource without changing anything in the server. All safe methods are automatically idempotent, but not all idempotent methods are safe. This is because while idempotent methods produce consistent results when called repeatedly, some of them may still modify the server's state or the resource being accessed.Like in our first example, the DELETE method is idempotent, because deleting a resource multiple times will have the same effect. But it's not safe, as it changes the server's state by removing the resource.Here\u2019s a classification of HTTP methods based on their safe status:Safe methods:GETOPTIONSHEADUnsafe methods:DELETEPOSTPUTPATCHWhy is POST not idempotent?POST is an HTTP method that sends information to a server. When you make a POST request, you typically submit data to create a new resource or trigger a server-side action. Therefore, making the same request multiple times can result in different outcomes and side effects on the server. This can lead to duplicated data, starting server resources, and reducing performance because of the repeated action.Unlike idempotent methods like GET, PUT, and DELETE, which have consistent results regardless of repetition, POST requests can cause changes to the server's state with each invocation. POST requests often create new resources on the server. Repeating the same POST request will generate multiple identical resources, potentially leading to duplication.This is similar to DELETE which is an idempotent method but not a safe method. Deleting the last entry in a collection using a single DELETE request would be considered idempotent. But if a developer creates a function that deletes the last entry, that would trigger DELETE multiple times. Subsequent DELETE calls would have different effects, as each one removes a unique entry. This would be considered non-idempotent.How to Achieve Idempotency with Non-Idempotent MethodsIdempotency isn't only a property inherent to certain methods \u2013 it can also be implemented as a feature of a non-idempotent method. \u00a0Here are some techniques to achieve idempotency even with non-idempotent methods.Unique IdentifiersAdding unique identifiers to every request is one of the most common techniques used to implement idempotency. It works by tracking whether the operation has already been performed or not. If it's a duplicate (a repeat request), the server knows it's already dealt with that request and simply ignores it, ensuring that no side effects occur. Here's an example of how it works:from uuid import uuid4\n \ndef process_order(unique_id, order_data):\n    if Order.objects.filter(unique_id=unique_id).exists():\n        return HttpResponse(status=409)  # Conflict\n    order = Order.objects.create(unique_id=unique_id, **order_data)\n    return HttpResponse(status=201, content_type=\"application/json\")\n\n# Example usage\npost_data = {\"products\": [...]}\nheaders = {\"X-Unique-ID\": str(uuid4())}\nrequests.post(\"https://api.example.com/orders\", data=post_data, headers=headers)\nIn this code snippet, we define a function called process_order that creates orders in an API, using unique identifiers to implement idempotency. Here's a breakdown of the code:Importing the Unique Identifier Generator:from uuid import uuid4: The code snippet starts by importing the uuid4 function from the uuid module. This function generates unique identifiers, which are used to achieve idempotency in this code.Defining the process_order Function:def process_order(unique_id, order_data): This line defines a function named process_order that takes two arguments:unique_id: This is a string representing a unique identifier for the request. This ensures no duplicate orders are created with the same identifier.order_data: This is a dictionary containing the actual order data, like product information and customer details.Checking for Existing Orders:if Order.objects.filter(unique_id=unique_id).exists(): This line checks if an order with the same unique_id already exists in the database.Order.objects.filter(unique_id=unique_id).exists() queries the Order model for orders with the matching unique_id and checks if any orders were found in the query result. If an order is found, it means the same request was already processed.Handling existing orders:return HttpResponse(status=409): If an order with the same unique_id already exists, the function immediately returns an HTTP response with status code 409 indicating a conflict. This prevents duplicate orders from being created.Creating a new order (if unique):order = Order.objects.create(unique_id=unique_id, **order_data ): This line only runs if no existing order is found.Order.objects.create: creates a new object in the Order model.unique_id=unique_id sets the unique_id attribute of the new order to the provided unique_id.order_data: spreads the dictionary order_data as keyword arguments to the order model's constructor, setting other relevant attributes like products and customer information.Sending a success response:return HttpResponse(status=201, content_type=\"application/json\"): If the order creation is successful, the function will return an HTTP response with status code 201 which shows a successful creation. It also specifies the response content type as JSON, assuming the order data might be returned in JSON format.post_data = {\"products\": [...]}: an example request, defines a dictionary containing the actual order data, like a list of products.headers = {\"X-Unique-ID\": str(uuid4())}: This line creates a dictionary containing a custom header named X-Unique-ID. It generates a unique identifier string using uuid4() and adds it to the header.requests.post(\"https://api.example.com/orders\", data=post_data, headers=headers): This line sends a POST request to the API endpoint https://api.example.com/orders \u00a0with the provided post_data and headers.How does this implement idempotence?It does so by using a unique identifier (unique_id) for each order. It checks if an order with the same identifier already exists in the database. If it returns true, it returns a 409 Conflict status. Otherwise, it creates a new order and responds with a 201 Created status. The unique identifier prevents duplicate orders, making the system idempotent.Token-based AuthorizationToken-based authorization is a form of authorization that assigns temporary tokens for each non-idempotent action. Once the action is completed, the token is invalidated. If the same request comes again with the same token, the server recognizes it as invalid and refuses the request, thereby preventing duplicate actions.// Generate a unique token for this action\nconst token = generateToken();\n\nfetch(\"https://api.example.com/create-user\", {\n    method: \"POST\",\n    body: JSON.stringify({ username, password }),\n    headers: {\n        Authorization: `Bearer ${token}`,\n        \"Content-Type\": \"application/json\",\n    },\n})\n    .then(response => {\n        // Handle successful response\n        if (response.ok) {\n            // Do something with the successful response\n        } else {\n            // Handle non-successful response\n        }\n    })\n    .catch(error => {\n        // Handle error\n        console.error(\"Error occurred:\", error);\n    })\n    .finally(() => {\n        // Invalidate token after successful action or in case of an error\n        invalidateToken(token);\n    });\n\n// Simple implementation for generating a token\nfunction generateToken() {\n    return Math.random().toString(36).substr(2);\n}\n\n// Simple implementation for invalidating a token\nfunction invalidateToken(token) {\n    // Add your logic to invalidate the token, e.g., remove it from storage\n}\nHere's a breakdown of the code:Generating a unique token:const token = generateToken(): This line calls a function named generateToken() (which is assumed to be defined elsewhere) that generates a unique token string. This token will be used for authorization and idempotency.Sending the POST request:fetch(\"https://api.example.com/create-user\", { ... }): This line uses the fetch API to send a POST request to the API endpoint https://api.example.com/create-user. method: \"POST\": This specifies the HTTP method as POST, indicating the intention to create a new user.body: JSON.stringify({ username, password }): This defines the request body with user details like username and password. The data is converted to JSON format before sending.headers: { Authorization:Bearer ${token}}: This sets the Authorization header in the request. The header value includes the generated token prefixed with \"Bearer \".Handling the Response:.then(response => { ... }): This block defines the code to execute if the request is successful. You would handle things like storing user information or redirecting the user upon successful user creation..catch(error => { ... }): This block defines the code to execute if the request encounters an error. You would handle any error messages or handle specific error scenarios here.Invalidating the Token:invalidateToken(token): This line calls a function named invalidateToken(token) ( which is assumed to be defined elsewhere) which would likely mark the used token as invalid. This ensures the same token cannot be used for subsequent requests, adding to the idempotency guarantee.How does this implement Idempotence?This code snippet uses token-based authorization to implement idempotency in a POST request to create a user on an API. If a user creation request is accidentally sent multiple times, a new unique token is generated each time and used in the Authorization header.The API server can recognize and verify the unique token, and since the user creation action has already been performed (assuming it's successful the first time), it won't create duplicate users due to subsequent identical requests.An ETag header (Entity Tag) is an HTTP header used for web cache validation and conditional requests. It is mainly used for \u00a0PUT requests, that only update resources if they haven't changed since the last check.When you want to update a resource, the server sends you its ETag which is then included in your PUT request along with the updated data. If the ETag hasn't changed (meaning the resource remains the same), the server accepts the update. But if the ETag has changed, the server rejects the update, preventing it from overwriting someone else's changes.def update_article(article_id, content):\n    # Get existing article and its ETag\n    article = Article.objects.get(pk=article_id)\n    etag = article.etag\n    \n    # Check if ETag matches with request header\n    if request.headers.get(\"If-Match\") != etag:\n        return HttpResponse(status=409)  # Conflict\n    \n    # Update article content and generate new ETag\n    article.content = content\n    article.save()\n    new_etag = article.etag\n    \n    # Return success response with updated ETag\n    return HttpResponse(status=200, content_type=\"text/plain\", content=new_etag)\nIn this code snippet, we define a function called update_article that allows you to update the content of an existing article based on its ID and new content. It implements idempotency using the ETag header technique.Here's a step-by-step explanation of how it works;Getting the Existing Article and its ETag:article = Article.objects.get(pk=article_id): This line fetches the article with the provided article_id from the database using the Article model.etag = article.etag: This line extracts the ETag value from the retrieved article object. The ETag serves as a unique identifier for the article's current state.Checking for a Match:if request.headers.get(\"If-Match\") != etag: This line checks if the ETag header provided in the request matches the ETag of the retrieved article.return HttpResponse(status=409): If the ETag doesn't match, it indicates that the article might have been updated by another request since the client retrieved its information. The function returns a 409 Conflict response, which prevents accidental data corruption.Updating the Article Content and generating a new ETag:article.content = content: This line updates the article's content with the new content received in the request.article.save(): This line saves the updated article back to the database.new_etag = article.etag: This line retrieves the new ETag generated for the updated article after saving it.Returning the Success Response with the new ETag:return HttpResponse(status=200, content_type=\"text/plain\", content=new_etag): returns a successful 200 OK response, including the content type (\"text/plain\") and the updated ETag of the article in the response body.How does this implement idempotence?This code ensures that if the same update request is sent multiple times with the same ETag, the update will only be performed once, preventing duplicate updates and maintaining data consistency. The new ETag is then provided in the response to help the client keep track of the article's state for future interactions.ConclusionIn this tutorial, we highlighted the difference between safe methods like GET, which retrieves data without side effects, and non-idempotent methods like POST, which can have different outcomes with each repetition. We also explored techniques you can apply to achieve idempotence in non-idempotent methods, emphasizing the importance of designing APIs that prioritize consistency and reliability.\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 18668, "excerpt": "Idempotence refers to a program's ability to maintain a particular result even\nafter repeated actions. \n\nFor example, let's say you have a button that only opens a door when pressed.\nThis button does not have the ability to close the door, so it stays open even\nwhen it's pressed repeatedly. It simply remains in the state it was changed to\nby the first press.\n\nThis same logic applies to HTTP methods that are idempotent. Operating on\nidempotent HTTP methods repeatedly won't have any additional eff", "siteName": "freeCodeCamp.org", "publishedTime": "2023-12-22T21:19:43.000Z", "id": "72498b4f3fafd935652859010aa341c370399ce0", "url": "https://www.freecodecamp.org/news/idempotency-in-http-methods/", "domain": "freecodecamp.org", "date": "2023-12-27T18:04:53.682574", "resultUri": "http://localhost:3000/result/72498b4f3fafd935652859010aa341c370399ce0", "query": {"url": ["https://www.freecodecamp.org/news/idempotency-in-http-methods/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "Idempotence in HTTP Methods \u2013 Explained with CRUD Examples", "description": "Idempotence refers to a program's ability to maintain a particular result even after repeated actions.  For example, let's say you have a button that only opens a door when pressed. This button does not have the ability to close the door, so it stays open even when it's pressed", "url": "https://www.freecodecamp.org/news/idempotency-in-http-methods/", "image": "https://www.freecodecamp.org/news/content/images/2023/12/pexels-robert-lens-10382808.jpg", "image:width": "2000", "image:height": "1335"}, "twitter": {"card": "summary_large_image", "title": "Idempotence in HTTP Methods \u2013 Explained with CRUD Examples", "description": "Idempotence refers to a program's ability to maintain a particular result even after repeated actions.  For example, let's say you have a button that only opens a door when pressed. This button does not have the ability to close the door, so it stays open even when it's pressed", "url": "https://www.freecodecamp.org/news/idempotency-in-http-methods/", "image": "https://www.freecodecamp.org/news/content/images/2023/12/pexels-robert-lens-10382808.jpg", "label1": "Written by", "data1": "Yemi Ojedapo", "label2": "Filed under", "data2": "Web Development, HTTP, Programming", "site": "@freecodecamp"}}}