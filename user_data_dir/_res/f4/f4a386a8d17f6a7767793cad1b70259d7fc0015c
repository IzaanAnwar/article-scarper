{"title": "Mutable vs Immutable Objects in Python \u2013 A Visual and Hands-On Guide", "byline": "Omer Rosenbaum", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>Mutable vs Immutable Objects in Python \u2013 A Visual and Hands-On Guide</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>Python is an awesome language. Because of its simplicity, many people choose it as their first programming language. </p><p>Experienced programmers use Python all the time as well, thanks to its wide community, abundance of packages, and clear syntax.</p><p>But there's one issue that seems to confuse beginners as well as some experienced developers: Python objects. Specifically, the difference between <strong>mutable </strong>and <strong>immutable</strong> objects.</p><p>In this post we will deepen our knowledge of Python objects, learn the difference between <strong>mutable </strong>and <strong>immutable </strong>objects, and see how we can use the <strong>interpreter </strong>to better understand how Python operates. </p><p>We will use important functions and keywords such as <code>id</code> and <code>is</code>, and we'll understand the difference between <code>x == y</code> and <code>x is y</code>.</p><p>Are you up for it? Let's get started.</p><h2 id=\"in-python-everything-is-an-object\">In Python, everything is an object</h2><p>Unlike other programming languages where the language <em>supports</em> objects, in Python really <strong>everything</strong> is an object \u2013 including integers, lists, and even functions.</p><p>We can use our interpreter to verify that:</p><figure><pre tabindex=\"0\"><code>&gt;&gt;&gt; isinstance(1, object)\nTrue\n\n&gt;&gt;&gt; isinstance(False, object)\nTrue\n\ndef my_func():\n   return \"hello\"\n   \n&gt;&gt;&gt; isinstance(my_func, object)\nTrue</code></pre><figcaption>Everything in Python is an object</figcaption></figure><p>Python has a built-in function, <code>id</code>, which returns the address of an object in memory. For example:</p><figure><pre tabindex=\"0\"><code>&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; id(x)\n1470416816</code></pre><figcaption>The function <code>id(obj)</code> returns the address of <code>obj</code> in memory</figcaption></figure><p>Above, we created an <strong>object</strong> by the name of <code>x</code>, and assigned it the value of <code>1</code>. We then used <code>id(x)</code> and discovered that this object is found at the address <code>1470416816</code> in memory.</p><p>This allows us to check interesting things about Python. Let's say we create two variables in Python \u2013 one by the name of <code>x</code>, and one by the name of <code>y</code> \u2013 and assign them the same value. For example, here:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; x = \"I love Python!\"\n&gt;&gt;&gt; y = \"I love Python!\"</code></pre><p>We can use the equality operator (<code>==</code>) to verify that they indeed have the same value in Python's eyes:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; x == y\nTrue</code></pre><p>But are these the same object in memory? In theory, there can be two very different scenarios here. </p><p>According to scenario <strong>(1)</strong>, we really have two different objects, one by the name of <code>x</code>, and another by the name of <code>y</code>, that just happen to have the same value. </p><p>Yet, it could also be the case that Python actually stores here only one object, which has two names that reference it \u2013 as shown in scenario <strong>(2)</strong>:</p><figure><img alt=\"image-19\" height=\"549\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2020/10/image-19.png\" width=\"905\"/></figure><p>We can use the <code>id</code> function introduced above to check this:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; x = \"I love Python!\"\n&gt;&gt;&gt; y = \"I love Python!\"\n&gt;&gt;&gt; x == y\nTrue\n\n&gt;&gt;&gt; id(x)\n52889984\n\n&gt;&gt;&gt; id(y)\n52889384</code></pre><p>So as we can see, Python's behavior matches scenario (1) described above. Even though <code>x == y</code> in this example (that is, <code>x</code> and <code>y</code> have the same <em>values</em>), they are different objects in memory. This is because <code>id(x) != id(y)</code>, as we can verify explicitly:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; id(x) == id(y)\nFalse</code></pre><p>There is a shorter way to make the comparison above, and that is to use Python's <code>is</code> operator. Checking whether <code>x is y</code> is the same as checking <code>id(x) == id(y)</code>, which means whether <code>x</code> and <code>y</code> are the same object in memory:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; x == y\nTrue\n\n&gt;&gt;&gt; id(x) == id(y)\nFalse\n\n&gt;&gt;&gt; x is y\nFalse</code></pre><p>This sheds light on the important difference between the equality operator <code>==</code> and the identity operator <code>is</code>. </p><p>As you can see in the example above, it is completely possible for two names in Python (<code>x</code> and <code>y</code>) to be bound to two different objects (and thus, <code>x is y</code> is <code>False</code>), where these two objects have the same value (so <code>x == y</code> is <code>True</code>).</p><p>How can we create another variable that points to the same object that <code>x</code> is pointing to? We can simply use the assignment operator <code>=</code>, like so:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; x = \"I love Python!\"\n&gt;&gt;&gt; z = x</code></pre><p>To verify that they indeed point to the same object, we can use the <code>is</code> operator:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; x is z\nTrue</code></pre><p>Of course, this means they have the same address in memory, as we can verify explicitly by using <code>id</code>:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; id(x)\n54221824\n\n&gt;&gt;&gt; id(z)\n54221824</code></pre><p>And, of course, they have the same value, so we expect <code>x == z</code> to return <code>True</code> as well:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; x == z\nTrue</code></pre><p>We have said that everything in Python is an object, yet there is an important distinction between objects. Some objects are <strong>mutable</strong> while some are <strong>immutable</strong>. </p><p>As I mentioned before, this fact causes confusion for many people who are new to Python, so we are going to make sure it's clear.</p><h2 id=\"immutable-objects-in-python\">Immutable objects in Python</h2><p>For some types in Python, once we have created instances of those types, they never change. They are <strong>immutable</strong>. </p><p>For example, <code>int</code> objects are immutable in Python. What will happen if we try to change the value of an <code>int</code> object?</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; x = 24601\n&gt;&gt;&gt; x\n24601\n\n&gt;&gt;&gt; x = 24602\n&gt;&gt;&gt; x\n24602</code></pre><p>Well, it seems that we changed <code>x</code> successfully. This is exactly where many people get confused. What exactly happened under the hood here? Let's use <code>id</code> to further investigate:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; x = 24601\n&gt;&gt;&gt; x\n24601\n\n&gt;&gt;&gt; id(x)\n1470416816\n\n&gt;&gt;&gt; x = 24602\n&gt;&gt;&gt; x\n24602\n\n&gt;&gt;&gt; id(x)\n1470416832</code></pre><p>So we can see that by assigning <code>x = 24602</code>, we didn't change the value of the object that <code>x</code> had been bound to before. Rather, we created a new object, and bound the name <code>x</code> to it. </p><p>So after assigning <code>24601</code> to <code>x</code> by using <code>x = 24601</code>, we had the following state:</p><figure><img alt=\"image-46\" height=\"87\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2020/10/image-46.png\" width=\"270\"/></figure><p>And after using <code>x = 24602</code>, we created a new object, and bound the name <code>x</code> to this new object. The other object with the value of <code>24601</code> is no longer reachable by <code>x</code> (or any other name in this case):</p><figure><img alt=\"image-47\" height=\"180\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2020/10/image-47.png\" width=\"311\"/></figure><p>Whenever we assign a new value to a name (in the above example - <code>x</code>) that is bound to an <code>int</code> object, we actually change the binding of that name to another object. </p><p>The same applies for <code>tuple</code>s, strings (<code>str</code> objects), and <code>bool</code>s as well. In other words, <code>int</code> (and other number types such as <code>float</code>), <code>tuple</code>, <code>bool</code>, and <code>str</code> objects are<strong> immutable</strong>.</p><p>Let's test this hypothesis. What happens if we create a <code>tuple</code> object, and then give it a different value? </p><pre tabindex=\"0\"><code>&gt;&gt;&gt; my_tuple = (1, 2, 3)\n&gt;&gt;&gt; id(my_tuple)\n54263304\n\n&gt;&gt;&gt; my_tuple = (3, 4, 5)\n&gt;&gt;&gt; id(my_tuple)\n56898184</code></pre><p>Just like an <code>int</code> object, we can see that our assignment actually changed the object that the name <code>my_tuple</code> is bound to.</p><p>What happens if we try to change one of the <code>tuple</code>'s elements?</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; my_tuple[0] = 'a new value'\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment</code></pre><p>As we can see, Python doesn't allow us to modify <code>my_tuple</code>'s contents, as it is immutable.</p><h2 id=\"mutable-objects-in-python\">Mutable objects in Python</h2><p>Some types in Python can be modified after creation, and they are called <strong>mutable</strong>. For example, we know that we can modify the contents of a <code>list</code> object:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; my_list = [1, 2, 3]\n&gt;&gt;&gt; my_list[0] = 'a new value'\n&gt;&gt;&gt; my_list\n['a new value', 2, 3]</code></pre><p>Does that mean we actually created a new object when assigning a new value to the first element of <code>my_list</code>? Again, we can use <code>id</code> to check:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; my_list = [1, 2, 3]\n&gt;&gt;&gt; id(my_list)\n55834760\n\n&gt;&gt;&gt; my_list\n[1, 2, 3]\n\n&gt;&gt;&gt; my_list[0] = 'a new value'\n&gt;&gt;&gt; id(my_list)\n55834760\n\n&gt;&gt;&gt; my_list\n['a new value', 2, 3]</code></pre><p>So our first assignment <code>my_list = [1, 2, 3]</code> created an object in the address <code>55834760</code>, with the values of <code>1</code>, <code>2</code>, and <code>3</code>:</p><figure><img alt=\"image-22\" height=\"164\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2020/10/image-22.png\" width=\"839\"/></figure><p>We then modified the first element of this <code>list</code> object using <code>my_list[0] = 'a new value'</code>, that is - without creating a new <code>list</code> object:</p><figure><img alt=\"image-23\" height=\"172\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2020/10/image-23.png\" width=\"862\"/></figure><p>Now, let us create two names \u2013 <code>x</code> and <code>y</code>, both bound to the same <code>list</code> object. We can verify that either by using <code>is</code>, or by explicitly checking their <code>id</code>s:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; x = y = [1, 2]\n&gt;&gt;&gt; x is y\nTrue\n\n&gt;&gt;&gt; id(x)\n18349096\n\n&gt;&gt;&gt; id(y)\n18349096\n\n&gt;&gt;&gt; id(x) == id(y)\nTrue</code></pre><p>What happens now if we use <code>x.append(3)</code>? That is, if we add a new element (<code>3</code>) to the object by the name of <code>x</code>?</p><p>Will <code>x</code> by changed? Will <code>y</code>?</p><p>Well, as we already know, they are basically two names of the same object:</p><figure><img alt=\"image-28\" height=\"183\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2020/10/image-28.png\" width=\"540\"/></figure><p>Since this object is changed, when we check its names we can see the new value:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; x.append(3)\n&gt;&gt;&gt; x\n[1, 2, 3]\n\n&gt;&gt;&gt; y\n[1, 2, 3]</code></pre><p>Note that <code>x</code> and <code>y</code> have the same <code>id</code> as before \u2013 as they are still bound to the same <code>list</code> object:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; id(x)\n18349096\n\n&gt;&gt;&gt; id(y)\n18349096</code></pre><figure><img alt=\"image-27\" height=\"189\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2020/10/image-27.png\" width=\"549\"/></figure><p>In addition to <code>list</code>s, other Python types that are mutable include <code>set</code>s and <code>dict</code>s.</p><h2 id=\"implications-for-dictionary-keys-in-python\">Implications for dictionary keys in Python</h2><p>Dictionaries (<code>dict</code> objects) are commonly used in Python. As a quick reminder, we define them like so:</p><pre tabindex=\"0\"><code>my_dict = {\"name\": \"Omer\", \"number_of_pets\": 1}</code></pre><p>We can then access a specific element by its key name:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; my_dict[\"name\"]\n'Omer'</code></pre><p>Dictionaries are <strong>mutable</strong>, so we can change their content after creation. At any given moment, a key in the dictionary can point to one element only:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; my_dict[\"name\"] = \"John\"\n&gt;&gt;&gt; my_dict[\"name\"]\n'John'</code></pre><p>It is interesting to note that a <strong>dictionary's keys must be immutable</strong>:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; my_dict = {[1,2]: \"Hello\"}\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'</code></pre><p>Why is that so? </p><p>Let's consider the following hypothetical scenario (note: the snippet below can't really be run in Python):</p><figure><pre tabindex=\"0\"><code>&gt;&gt;&gt; x = [1, 2]\n&gt;&gt;&gt; y = [1, 2, 3]\n&gt;&gt;&gt; my_dict = {x: 'a', y: 'b'}</code></pre><figcaption>This is a hypothetic case that cannot really be run in Python</figcaption></figure><p>So far, things don't seem that bad. We'd assume that if we access <code>my_dict</code> with the key of <code>[1, 2]</code>, we will get the corresponding value of <code>'a'</code>, and if we access the key <code>[1, 2, 3]</code>, we will get the value <code>'b'</code>. </p><p>Now, what would happen if we attempted to use:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; x.append(3)</code></pre><p>In this case, <code>x</code> would have the value of <code>[1, 2, 3]</code>, and <code>y</code> would also have the value of <code>[1, 2, 3]</code>. What should we get when we ask for <code>my_dict[[1, 2, 3]]</code>? Will it be <code>'a'</code> or <code>'b'</code>? To avoid such cases, Python simply doesn't allow dictionary keys to be mutable.</p><h2 id=\"taking-things-a-bit-further\">Taking things a bit further</h2><p>Let's try to apply our knowledge to a case that is a bit more interesting.</p><p>Below, we define a <code>list</code> (a <strong>mutable</strong> object) and a <code>tuple</code> (an <strong>immutable</strong> object). The <code>list</code> includes a <code>tuple</code>, and the <code>tuple</code> includes a <code>list</code>:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; my_list = [(1, 1), 2, 3]\n&gt;&gt;&gt; my_tuple = ([1, 1], 2, 3)\n&gt;&gt;&gt; type(my_list)\n&lt;class 'list'&gt;\n\n&gt;&gt;&gt; type(my_list[0])\n&lt;class 'tuple'&gt;\n\n&gt;&gt;&gt; type(my_tuple)\n&lt;class 'tuple'&gt;\n\n&gt;&gt;&gt; type(my_tuple[0])\n&lt;class 'list'&gt;</code></pre><p>So far so good. Now, try to think for yourself \u2013 what will happen when we try to execute each of the following statements?</p><p>(1) <code>&gt;&gt;&gt; my_list[0][0] = 'Changed!'</code></p><p>(2) <code>&gt;&gt;&gt; my_tuple[0][0] = 'Changed!'</code></p><p>In statement (1), what we are trying to do is change <code>my_list</code>'s first element, that is, a <code>tuple</code>. Since a <code>tuple</code> is <strong>immutable</strong>, this attempt is destined to fail:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; my_list[0][0] = 'Changed!'\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment</code></pre><p>Note that what we were trying to do is <em>not </em>change the list, but rather \u2013 change the contents of its first element. </p><p>Let's consider statement (2). In this case, we are accessing <code>my_tuple</code>'s first element, which happens to be a <code>list</code>, and modify it. Let's further investigate this case and look at the addresses of these elements:</p><pre tabindex=\"0\"><code>&gt;&gt;&gt; my_tuple = ([1, 1], 2, 3)\n&gt;&gt;&gt; id(my_tuple)\n20551816\n\n&gt;&gt;&gt; type(my_tuple[0])\n&lt;class 'list'&gt;\n\n&gt;&gt;&gt; id(my_tuple[0])\n20446248</code></pre><figure><img alt=\"image-29\" height=\"199\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2020/10/image-29.png\" width=\"868\"/></figure><p>When we change <code>my_tuple[0][0]</code>, we do not really change <code>my_tuple</code> at all! Indeed, after the change, <code>my_tuple</code>'s first element will still be the object whose address in memory is <code>20446248</code>. We do, however, change the value of that object:</p><figure><pre tabindex=\"0\"><code>&gt;&gt;&gt; my_tuple[0][0] = 'Changed!'\n&gt;&gt;&gt; id(my_tuple)\n20551816\n\n&gt;&gt;&gt; id(my_tuple[0])\n20446248\n\n&gt;&gt;&gt; my_tuple\n(['Changed!', 1], 2, 3)</code></pre><figcaption>Both <code>id(my_tuple)</code> and <code>id(my_tuple[0])</code> remain the same after the change</figcaption></figure><figure><img alt=\"image-48\" height=\"160\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2020/10/image-48.png\" width=\"759\"/></figure><p>Since we only modified the value of <code>my_tuple[0]</code>, which is a mutable <code>list</code> object, this operation was indeed allowed by Python.</p><h2 id=\"recap\">Recap</h2><p>In this post we learned about Python objects. We said that in Python <strong>everything is an object</strong>, and got to use <code>id</code> and <code>is</code> to deepen our understanding of what's happening under the hood when using Python to create and modify objects.</p><p>We also learned the difference between <strong>mutable </strong>objects, that can be modified after creation, and <strong>immutable</strong> objects, which cannot. </p><p>We saw that when we ask Python to modify an immutable object that is bound to a certain name, we actually create a new object and bind that name to it.</p><p>We then learned why dictionary keys have to be <strong>immutable </strong>in Python.</p><p>Understanding how Python \"sees\" objects is a key to becoming a better Python programmer. I hope this post has helped you on your journey to mastering Python.</p><p><a href=\"https://www.linkedin.com/in/omer-rosenbaum-034a08b9/\" rel=\"noopener\"><em><em>Omer Rosenbaum</em></em></a><em><em>, </em></em><a href=\"https://swimm.io/\" rel=\"noopener\"><em><em>Swimm</em></em></a><em><em>\u2019s Chief Technology Officer. Cyber training expert and Founder of Checkpoint Security Academy. Author of </em></em><a href=\"https://data.cyber.org.il/networks/networks.pdf\" rel=\"noopener nofollow noopener\"><em><em>Computer Networks (in Hebrew)</em></em></a><em><em>. Visit My </em></em><a href=\"https://www.youtube.com/watch?v=79jlgESHzKQ&amp;list=PL9lx0DXCC4BMS7dB7vsrKI5wzFyVIk2Kg\" rel=\"noopener nofollow noopener\"><em><em>YouTube Channel</em></em></a><em><em>.</em></em></p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nPython is an awesome language. Because of its simplicity, many people choose it as their first programming language. Experienced programmers use Python all the time as well, thanks to its wide community, abundance of packages, and clear syntax.But there's one issue that seems to confuse beginners as well as some experienced developers: Python objects. Specifically, the difference between mutable and immutable objects.In this post we will deepen our knowledge of Python objects, learn the difference between mutable and immutable objects, and see how we can use the interpreter to better understand how Python operates. We will use important functions and keywords such as id and is, and we'll understand the difference between x == y and x is y.Are you up for it? Let's get started.In Python, everything is an objectUnlike other programming languages where the language supports objects, in Python really everything is an object \u2013 including integers, lists, and even functions.We can use our interpreter to verify that:>>> isinstance(1, object)\nTrue\n\n>>> isinstance(False, object)\nTrue\n\ndef my_func():\n   return \"hello\"\n   \n>>> isinstance(my_func, object)\nTrueEverything in Python is an objectPython has a built-in function, id, which returns the address of an object in memory. For example:>>> x = 1\n>>> id(x)\n1470416816The function id(obj) returns the address of obj in memoryAbove, we created an object by the name of x, and assigned it the value of 1. We then used id(x) and discovered that this object is found at the address 1470416816 in memory.This allows us to check interesting things about Python. Let's say we create two variables in Python \u2013 one by the name of x, and one by the name of y \u2013 and assign them the same value. For example, here:>>> x = \"I love Python!\"\n>>> y = \"I love Python!\"We can use the equality operator (==) to verify that they indeed have the same value in Python's eyes:>>> x == y\nTrueBut are these the same object in memory? In theory, there can be two very different scenarios here. According to scenario (1), we really have two different objects, one by the name of x, and another by the name of y, that just happen to have the same value. Yet, it could also be the case that Python actually stores here only one object, which has two names that reference it \u2013 as shown in scenario (2):We can use the id function introduced above to check this:>>> x = \"I love Python!\"\n>>> y = \"I love Python!\"\n>>> x == y\nTrue\n\n>>> id(x)\n52889984\n\n>>> id(y)\n52889384So as we can see, Python's behavior matches scenario (1) described above. Even though x == y in this example (that is, x and y have the same values), they are different objects in memory. This is because id(x) != id(y), as we can verify explicitly:>>> id(x) == id(y)\nFalseThere is a shorter way to make the comparison above, and that is to use Python's is operator. Checking whether x is y is the same as checking id(x) == id(y), which means whether x and y are the same object in memory:>>> x == y\nTrue\n\n>>> id(x) == id(y)\nFalse\n\n>>> x is y\nFalseThis sheds light on the important difference between the equality operator == and the identity operator is. As you can see in the example above, it is completely possible for two names in Python (x and y) to be bound to two different objects (and thus, x is y is False), where these two objects have the same value (so x == y is True).How can we create another variable that points to the same object that x is pointing to? We can simply use the assignment operator =, like so:>>> x = \"I love Python!\"\n>>> z = xTo verify that they indeed point to the same object, we can use the is operator:>>> x is z\nTrueOf course, this means they have the same address in memory, as we can verify explicitly by using id:>>> id(x)\n54221824\n\n>>> id(z)\n54221824And, of course, they have the same value, so we expect x == z to return True as well:>>> x == z\nTrueWe have said that everything in Python is an object, yet there is an important distinction between objects. Some objects are mutable while some are immutable. As I mentioned before, this fact causes confusion for many people who are new to Python, so we are going to make sure it's clear.Immutable objects in PythonFor some types in Python, once we have created instances of those types, they never change. They are immutable. For example, int objects are immutable in Python. What will happen if we try to change the value of an int object?>>> x = 24601\n>>> x\n24601\n\n>>> x = 24602\n>>> x\n24602Well, it seems that we changed x successfully. This is exactly where many people get confused. What exactly happened under the hood here? Let's use id to further investigate:>>> x = 24601\n>>> x\n24601\n\n>>> id(x)\n1470416816\n\n>>> x = 24602\n>>> x\n24602\n\n>>> id(x)\n1470416832So we can see that by assigning x = 24602, we didn't change the value of the object that x had been bound to before. Rather, we created a new object, and bound the name x to it. So after assigning 24601 to x by using x = 24601, we had the following state:And after using x = 24602, we created a new object, and bound the name x to this new object. The other object with the value of 24601 is no longer reachable by x (or any other name in this case):Whenever we assign a new value to a name (in the above example - x) that is bound to an int object, we actually change the binding of that name to another object. The same applies for tuples, strings (str objects), and bools as well. In other words, int (and other number types such as float), tuple, bool, and str objects are immutable.Let's test this hypothesis. What happens if we create a tuple object, and then give it a different value? >>> my_tuple = (1, 2, 3)\n>>> id(my_tuple)\n54263304\n\n>>> my_tuple = (3, 4, 5)\n>>> id(my_tuple)\n56898184Just like an int object, we can see that our assignment actually changed the object that the name my_tuple is bound to.What happens if we try to change one of the tuple's elements?>>> my_tuple[0] = 'a new value'\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignmentAs we can see, Python doesn't allow us to modify my_tuple's contents, as it is immutable.Mutable objects in PythonSome types in Python can be modified after creation, and they are called mutable. For example, we know that we can modify the contents of a list object:>>> my_list = [1, 2, 3]\n>>> my_list[0] = 'a new value'\n>>> my_list\n['a new value', 2, 3]Does that mean we actually created a new object when assigning a new value to the first element of my_list? Again, we can use id to check:>>> my_list = [1, 2, 3]\n>>> id(my_list)\n55834760\n\n>>> my_list\n[1, 2, 3]\n\n>>> my_list[0] = 'a new value'\n>>> id(my_list)\n55834760\n\n>>> my_list\n['a new value', 2, 3]So our first assignment my_list = [1, 2, 3] created an object in the address 55834760, with the values of 1, 2, and 3:We then modified the first element of this list object using my_list[0] = 'a new value', that is - without creating a new list object:Now, let us create two names \u2013 x and y, both bound to the same list object. We can verify that either by using is, or by explicitly checking their ids:>>> x = y = [1, 2]\n>>> x is y\nTrue\n\n>>> id(x)\n18349096\n\n>>> id(y)\n18349096\n\n>>> id(x) == id(y)\nTrueWhat happens now if we use x.append(3)? That is, if we add a new element (3) to the object by the name of x?Will x by changed? Will y?Well, as we already know, they are basically two names of the same object:Since this object is changed, when we check its names we can see the new value:>>> x.append(3)\n>>> x\n[1, 2, 3]\n\n>>> y\n[1, 2, 3]Note that x and y have the same id as before \u2013 as they are still bound to the same list object:>>> id(x)\n18349096\n\n>>> id(y)\n18349096In addition to lists, other Python types that are mutable include sets and dicts.Implications for dictionary keys in PythonDictionaries (dict objects) are commonly used in Python. As a quick reminder, we define them like so:my_dict = {\"name\": \"Omer\", \"number_of_pets\": 1}We can then access a specific element by its key name:>>> my_dict[\"name\"]\n'Omer'Dictionaries are mutable, so we can change their content after creation. At any given moment, a key in the dictionary can point to one element only:>>> my_dict[\"name\"] = \"John\"\n>>> my_dict[\"name\"]\n'John'It is interesting to note that a dictionary's keys must be immutable:>>> my_dict = {[1,2]: \"Hello\"}\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unhashable type: 'list'Why is that so? Let's consider the following hypothetical scenario (note: the snippet below can't really be run in Python):>>> x = [1, 2]\n>>> y = [1, 2, 3]\n>>> my_dict = {x: 'a', y: 'b'}This is a hypothetic case that cannot really be run in PythonSo far, things don't seem that bad. We'd assume that if we access my_dict with the key of [1, 2], we will get the corresponding value of 'a', and if we access the key [1, 2, 3], we will get the value 'b'. Now, what would happen if we attempted to use:>>> x.append(3)In this case, x would have the value of [1, 2, 3], and y would also have the value of [1, 2, 3]. What should we get when we ask for my_dict[[1, 2, 3]]? Will it be 'a' or 'b'? To avoid such cases, Python simply doesn't allow dictionary keys to be mutable.Taking things a bit furtherLet's try to apply our knowledge to a case that is a bit more interesting.Below, we define a list (a mutable object) and a tuple (an immutable object). The list includes a tuple, and the tuple includes a list:>>> my_list = [(1, 1), 2, 3]\n>>> my_tuple = ([1, 1], 2, 3)\n>>> type(my_list)\n<class 'list'>\n\n>>> type(my_list[0])\n<class 'tuple'>\n\n>>> type(my_tuple)\n<class 'tuple'>\n\n>>> type(my_tuple[0])\n<class 'list'>So far so good. Now, try to think for yourself \u2013 what will happen when we try to execute each of the following statements?(1) >>> my_list[0][0] = 'Changed!'(2) >>> my_tuple[0][0] = 'Changed!'In statement (1), what we are trying to do is change my_list's first element, that is, a tuple. Since a tuple is immutable, this attempt is destined to fail:>>> my_list[0][0] = 'Changed!'\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignmentNote that what we were trying to do is not change the list, but rather \u2013 change the contents of its first element. Let's consider statement (2). In this case, we are accessing my_tuple's first element, which happens to be a list, and modify it. Let's further investigate this case and look at the addresses of these elements:>>> my_tuple = ([1, 1], 2, 3)\n>>> id(my_tuple)\n20551816\n\n>>> type(my_tuple[0])\n<class 'list'>\n\n>>> id(my_tuple[0])\n20446248When we change my_tuple[0][0], we do not really change my_tuple at all! Indeed, after the change, my_tuple's first element will still be the object whose address in memory is 20446248. We do, however, change the value of that object:>>> my_tuple[0][0] = 'Changed!'\n>>> id(my_tuple)\n20551816\n\n>>> id(my_tuple[0])\n20446248\n\n>>> my_tuple\n(['Changed!', 1], 2, 3)Both id(my_tuple) and id(my_tuple[0]) remain the same after the changeSince we only modified the value of my_tuple[0], which is a mutable list object, this operation was indeed allowed by Python.RecapIn this post we learned about Python objects. We said that in Python everything is an object, and got to use id and is to deepen our understanding of what's happening under the hood when using Python to create and modify objects.We also learned the difference between mutable objects, that can be modified after creation, and immutable objects, which cannot. We saw that when we ask Python to modify an immutable object that is bound to a certain name, we actually create a new object and bind that name to it.We then learned why dictionary keys have to be immutable in Python.Understanding how Python \"sees\" objects is a key to becoming a better Python programmer. I hope this post has helped you on your journey to mastering Python.Omer Rosenbaum, Swimm\u2019s Chief Technology Officer. Cyber training expert and Founder of Checkpoint Security Academy. Author of Computer Networks (in Hebrew). Visit My YouTube Channel.\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 12795, "excerpt": "Python is an awesome language. Because of its simplicity, many people choose it\nas their first programming language. \n\nExperienced programmers use Python all the time as well, thanks to its wide\ncommunity, abundance of packages, and clear syntax.\n\nBut there's one issue that seems to confuse beginners as well as some\nexperienced developers: Python objects. Specifically, the difference between \nmutable and immutable objects.\n\nIn this post we will deepen our knowledge of Python objects, learn the\nd", "siteName": "freeCodeCamp.org", "publishedTime": "2020-11-11T19:01:31.000Z", "id": "f4a386a8d17f6a7767793cad1b70259d7fc0015c", "url": "https://www.freecodecamp.org/news/mutable-vs-immutable-objects-python/", "domain": "freecodecamp.org", "date": "2023-12-27T18:06:28.711786", "resultUri": "http://localhost:3000/result/f4a386a8d17f6a7767793cad1b70259d7fc0015c", "query": {"url": ["https://www.freecodecamp.org/news/mutable-vs-immutable-objects-python/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "Mutable vs Immutable Objects in Python \u2013 A Visual and Hands-On Guide", "description": "Python is an awesome language. Because of its simplicity, many people choose it as their first programming language.  Experienced programmers use Python all the time as well, thanks to its wide community, abundance of packages, and clear syntax. But there's one issue that seems to confuse beginners as well", "url": "https://www.freecodecamp.org/news/mutable-vs-immutable-objects-python/", "image": "https://cdn-media-2.freecodecamp.org/w1280/5f9c95a1740569d1a4ca0dd3.jpg", "image:width": "1280", "image:height": "855"}, "twitter": {"card": "summary_large_image", "title": "Mutable vs Immutable Objects in Python \u2013 A Visual and Hands-On Guide", "description": "Python is an awesome language. Because of its simplicity, many people choose it as their first programming language.  Experienced programmers use Python all the time as well, thanks to its wide community, abundance of packages, and clear syntax. But there's one issue that seems to confuse beginners as well", "url": "https://www.freecodecamp.org/news/mutable-vs-immutable-objects-python/", "image": "https://cdn-media-2.freecodecamp.org/w1280/5f9c95a1740569d1a4ca0dd3.jpg", "label1": "Written by", "data1": "Omer Rosenbaum", "label2": "Filed under", "data2": "Python, Programming, Immutability, Object, pythonic programming, mutable", "site": "@freecodecamp", "creator": "@omer_ros"}}}