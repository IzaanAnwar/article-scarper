{"title": "How to build a blazing fast GraphQL API with Node.js, MongoDB and Fastify", "byline": "Siegfried Grimbeek", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>How to build a blazing fast GraphQL API with Node.js, MongoDB and Fastify</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>This tutorial is part two of a four part series, which aims to take you from scratch to deploying a fully <strong>functional full stack application.</strong></p><ul><li>Part 1: How to build blazing fast REST APIs with Node.js, MongoDB, Fastify and Swagger</li><li><strong>Part 2: How to build a blazing fast GraphQL API with Node.js, MongoDB, Fastify and GraphQL! (You are here.)</strong></li><li>Part 3: Coupling <strong>Vue.js </strong>with a <strong>GraphQL API</strong>.</li><li>Part 4: Deploying a <strong>GraphQL API </strong>and <strong>Vue.js </strong>frontend application<strong>.</strong></li></ul><p>The first part of the series is available <a href=\"https://medium.freecodecamp.org/how-to-build-blazing-fast-rest-apis-with-node-js-mongodb-fastify-and-swagger-114e062db0c9\" rel=\"noopener\">here</a> and the source code for the application can be found <a href=\"https://github.com/siegfriedgrimbeek/fastify-graphql-api\" rel=\"noopener\">here</a>.</p><p>In this part we will revisit the <strong>models</strong>, <strong>controllers</strong> and <strong>routes</strong> from part one and then integrate <a href=\"https://graphql.org/\" rel=\"noopener\"><strong>GraphQL</strong></a> into the application. As a bonus we will also use <a href=\"https://github.com/marak/Faker.js/\" rel=\"noopener\"><strong>Faker.js</strong></a><strong> </strong>to create some fake data and seed <strong>the database</strong>.</p><h3 id=\"introduction-\">Introduction:</h3><p><strong>GraphQL</strong> is a query language for APIs and a runtime for fulfilling those queries with your existing data.</p><p>Every <strong>GraphQL</strong> query goes through three phases: the queries are parsed, validated and executed.</p><p><strong>GraphQL</strong> provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need, makes it easier to evolve APIs over time, and enables powerful developer tools. <a href=\"https://graphql.org/\" rel=\"noopener\">Learn More</a>.</p><figure data-test-label=\"fitted\">\n\n</figure><h3 id=\"prerequisites-\">Prerequisites\u2026</h3><p>If you have completed the first part of this series, you should be up to speed with beginner/intermediate <strong>JavaScript </strong>knowledge, <strong>Node.js, Fastify.JS </strong>and <strong>MongoDB (Mongoose).</strong></p><p>To follow along, you will need to complete <a href=\"https://medium.freecodecamp.org/how-to-build-blazing-fast-rest-apis-with-node-js-mongodb-fastify-and-swagger-114e062db0c9\" rel=\"noopener\">part one</a> of this series or grab the code from <a href=\"https://github.com/siegfriedgrimbeek/fastify-api\" rel=\"noopener\">Git</a>, although I would highly recommend at least skimming through <a href=\"https://medium.freecodecamp.org/how-to-build-blazing-fast-rest-apis-with-node-js-mongodb-fastify-and-swagger-114e062db0c9\" rel=\"noopener\">part one</a>.</p><h3 id=\"let-s-get-started-\">Let\u2019s get started!</h3><p>Clone the repo for part one (skip this step if you followed part one and you are continuing with your own code) by opening your <strong>terminal, </strong>navigating to your project directory and<strong> </strong>executing each of the following lines of code:</p><pre tabindex=\"0\"><code>git clone https://github.com/siegfriedgrimbeek/fastify-api.git\ncd fastify-api</code></pre><p>So now that we have a copy of the codebase we will <a href=\"https://www.npmjs.com/package/npm-check-updates\" rel=\"noopener\">update our packages</a> and <code>package.json</code> file by running the following code:</p><pre tabindex=\"0\"><code>sudo npm i -g npm-check-updates\nncu -u\nnpm install</code></pre><p>First we globally install the <a href=\"https://docs.npmjs.com/about-npm/\" rel=\"noopener\">npm</a> package \u201c<a href=\"https://www.npmjs.com/package/npm-check-updates\" rel=\"noopener\"><strong>npm-check-updates</strong></a>\u201d and then we use this package to automatically update our <code>package.json</code> file with the latest package versions and then we install/update all our <strong>npm modules</strong> by running <code>npm install</code>.</p><p>This is done to ensure that everyone completing the tutorial is working with the same package versions.</p><h3 id=\"refactor-our-server-and-start-the-app-\">Refactor our server and start the app!</h3><figure><img alt=\"svTzrRuMRcyj062XemIBJuZUZl95QoIdF2KL\" height=\"245\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/svTzrRuMRcyj062XemIBJuZUZl95QoIdF2KL\" width=\"800\"/></figure><p>As with all software solutions, as the solution grows, developers often need to <strong>revisit</strong> and <a href=\"https://en.wikipedia.org/wiki/Code_refactoring\" rel=\"noopener\"><strong>refactor</strong></a> the code.</p><p>In the <code>src</code> directory we will create a new file called <code>server.js</code>:</p><pre tabindex=\"0\"><code>cd src\ntouch server.js</code></pre><p>Add the following code code to the <code>server.js</code> file:</p><figure><pre tabindex=\"0\"><code>// Require the fastify framework and instantiate it\nconst fastify = require('fastify')({\n\tlogger: true\n})\n\n// Require external modules\nconst mongoose = require('mongoose')\n\n// Connect to DB\nmongoose\n\t.connect('mongodb://localhost/mycargarage')\n\t.then(() =&gt; console.log('MongoDB connected...'))\n\t.catch(err =&gt; console.log(err))\n\nmodule.exports = fastify</code></pre><figcaption>server.js</figcaption></figure><p>We have now extracted the logic that starts the <strong>server</strong> to the <code>server.js</code> file, allowing us to reuse this code throughout the project.</p><p>Next we need to update our <code>index.js</code> file in the <code>src</code> directory:</p><figure><pre tabindex=\"0\"><code>\n// Import Server\nconst fastify = require('./server.js')\n\n// Import Routes\nconst routes = require('./routes')\n\n// Import Swagger Options\nconst swagger = require('./config/swagger')\n\n// Register Swagger\nfastify.register(require('fastify-swagger'), swagger.options)\n\n// Loop over each route\nroutes.forEach((route, index) =&gt; {\n\tfastify.route(route)\n})\n\n// Run the server!\nconst start = async () =&gt; {\n\ttry {\n\t\tawait fastify.listen(3000, '0.0.0.0')\n\t\tfastify.swagger()\n\t\tfastify.log.info(`server listening on ${fastify.server.address().port}`)\n\t} catch (err) {\n\t\tfastify.log.error(err)\n\t\tprocess.exit(1)\n\t}\n}\nstart()</code></pre><figcaption>index.js</figcaption></figure><p>We will revisit the <code>index.js</code> file, once we setup and configure <strong>GraphQL.</strong></p><p>Start the <strong>Fastify </strong>server by running the following code in your <strong>terminal</strong>:</p><pre tabindex=\"0\"><code>npm start</code></pre><p>Note that there is no default route setup so for now, navigating to <a href=\"http://localhost:3000/\" rel=\"noopener\">http://localhost:3000/</a> will result in the server returning a 404 error which is correct.</p><h3 id=\"start-mongodb-and-update-the-models\">Start MongoDB and update the models</h3><figure><img alt=\"qfSA-X4Bk-VbUgwx8mdQxWCdP2FD1gNTbFyd\" height=\"217\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/qfSA-X4Bk-VbUgwx8mdQxWCdP2FD1gNTbFyd\" width=\"800\"/></figure><p>Let\u2019s extend the existing model to also include <strong>Services</strong> and <strong>Owners.</strong> The below diagram below demonstrates the relationships between the collections:</p><figure><img alt=\"ScuP0r5uq0smEYWhcz75s2R-waOSiv7BVFLn\" height=\"391\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/ScuP0r5uq0smEYWhcz75s2R-waOSiv7BVFLn\" width=\"442\"/><figcaption>Data models</figcaption></figure><ul><li>One car can have one owner.</li><li>One owner can have many cars.</li><li>One car can have many services.</li></ul><p>Revisit the <code>Car.js</code> file in the <code>models</code> directory and update it as follows:</p><figure><pre tabindex=\"0\"><code>// External Dependancies\nconst mongoose = require(\"mongoose\")\nconst ObjectId = mongoose.Schema.Types.ObjectId\n\nconst carSchema = new mongoose.Schema({\n  title: String,\n  brand: String,\n  price: String,\n  age: Number,\n  owner_id: ObjectId\n})\n\nmodule.exports = mongoose.model(\"Car\", carSchema)</code></pre><figcaption>Car.js</figcaption></figure><p>Create two new files in the <code>models</code> directory, <code>Owner.js </code>and <code>Service.js</code> and add the following code to the files respectively:</p><figure><pre tabindex=\"0\"><code>// External Dependancies\nconst mongoose = require('mongoose')\n\nconst ownerSchema = new mongoose.Schema({\n\tfirstName: String,\n\tlastName: String,\n\temail: String\n})\n\nmodule.exports = mongoose.model('Owner', ownerSchema)</code></pre><figcaption>Owner.js</figcaption></figure><pre tabindex=\"0\"><code>// External Dependancies\nconst mongoose = require(\"mongoose\")\nconst ObjectId = mongoose.Schema.Types.ObjectId\n\nconst serviceSchema = new mongoose.Schema({\n  car_id: ObjectId,\n  name: String,\n  date: String\n})\n\nmodule.exports = mongoose.model(\"Service\", serviceSchema)\nview rawService.js hosted with \u2764 by GitHub</code></pre><p>There are no new concepts used in the above code. We have just created standard <a href=\"https://mongoosejs.com/docs/guide.html\" rel=\"noopener\">Mongoose Schemas</a>, as with the <code>Car.js</code> model.</p><h3 id=\"revisit-the-car-controller-and-create-the-additional-controllers\">Revisit the Car Controller and create the additional controllers</h3><p>There are some slight changes to the <code>carController.js</code> so navigate to the <code>controllers</code> directory and update your file as per below:</p><figure><pre tabindex=\"0\"><code>// External Dependancies\nconst boom = require('boom')\n\n// Get Data Models\nconst Car = require('../models/Car')\n\n// Get all cars\nexports.getCars = async () =&gt; {\n\ttry {\n\t\tconst cars = await Car.find()\n\t\treturn cars\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}\n\n// Get single car by ID\nexports.getSingleCar = async req =&gt; {\n\ttry {\n\t\tconst id = req.params === undefined ? req.id : req.params.id\n\t\tconst car = await Car.findById(id)\n\t\treturn car\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}\n\n// Add a new car\nexports.addCar = async req =&gt; {\n\ttry {\n\t\tconst car = new Car(req)\n\t\tconst newCar = await car.save()\n\t\treturn newCar\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}\n\n// Update an existing car\nexports.updateCar = async req =&gt; {\n\ttry {\n\t\tconst id = req.params === undefined ? req.id : req.params.id\n\t\tconst updateData = req.params === undefined ? req : req.params\n\t\tconst update = await Car.findByIdAndUpdate(id, updateData, { new: true })\n\t\treturn update\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}\n\n// Delete a car\nexports.deleteCar = async req =&gt; {\n\ttry {\n\t\tconst id = req.params === undefined ? req.id : req.params.id\n\t\tconst car = await Car.findByIdAndRemove(id)\n\t\treturn car\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}</code></pre><figcaption>carController.js</figcaption></figure><p>Create two new files in the <code>controllers</code> directory, <code>serviceController.js</code> and <code>ownerController.js</code>, and add the following code to the files respectively:</p><figure><pre tabindex=\"0\"><code>// External Dependancies\nconst boom = require('boom')\n\n// Get Data Models\nconst Service = require('../models/Service')\n\n// Get single service ID\nexports.getSingleService = async req =&gt; {\n\ttry {\n\t\tconst id = req.params === undefined ? req.id : req.params.id\n\t\tconst service = await Service.findById(id)\n\t\treturn service\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}\n\n// Get single car's services\nexports.getCarsServices = async req =&gt; {\n\ttry {\n\t\tconst id = req.params === undefined ? req.id : req.params.id\n\t\tconst services = await Service.find({ car_id: id })\n\t\treturn services\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}</code></pre><figcaption>serviceController.js</figcaption></figure><figure><pre tabindex=\"0\"><code>// External Dependancies\nconst boom = require('boom')\n\n// Get Data Models\nconst Owner = require('../models/Owner')\nconst Car = require('../models/Car')\n\n// Get all owners\nexports.getOwner = async () =&gt; {\n\ttry {\n\t\tconst owners = await Owner.find()\n\t\treturn owners\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}\n\n// Get single owner by ID\nexports.getSingleOwner = async req =&gt; {\n\ttry {\n\t\tconst id = req.params === undefined ? req.id : req.params.id\n\t\tconst owner = await Owner.findById(id)\n\t\treturn owner\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}\n\n// Get single owner's cars\nexports.getOwnersCars = async req =&gt; {\n\ttry {\n\t\tconst id = req.params === undefined ? req.id : req.params.id\n\t\tconst cars = await Car.find({ owner_id: id })\n\t\treturn cars\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}</code></pre><figcaption>ownerController.js</figcaption></figure><p>The biggest change to the controllers is how we get the parameters:</p><pre tabindex=\"0\"><code>const id = req.params === undefined ? req.id : req.params.id\nconst updateData = req.params === undefined ? req : req.params</code></pre><p>The above code is called a \u201c<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\" rel=\"noopener\"><strong>conditional (ternary) operator</strong></a><strong>\u201d </strong>and is used as shorthand for the following if statement:</p><pre tabindex=\"0\"><code>let id\n\nif (req.params === undefined) {\n\nid = req.id\n\n} else {\n\nid = req.params.id\n\n}</code></pre><p>We are using the <strong>ternary operator </strong>to accommodate requests from both the <strong>REST API</strong> and the <strong>GraphQL API</strong>, as they have a slightly different implementation.</p><h3 id=\"time-to-seed-the-database-with-some-fake-data-\">Time to seed the database with some fake data!</h3><figure><img alt=\"XzVSE6N-ig-vdYK9FxnvuuZGv6Dvg0zH9gmJ\" height=\"128\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/XzVSE6N-ig-vdYK9FxnvuuZGv6Dvg0zH9gmJ\" width=\"394\"/></figure><p>In the <code>src</code> directory let\u2019s create a new directory and file by running the following code:</p><pre tabindex=\"0\"><code>mkdir helpers\ntouch seed.js</code></pre><p>Add the following code to the <code>seed.js</code> file:</p><figure><pre tabindex=\"0\"><code>\n// Import external dependancies\nconst faker = require('faker')\nconst boom = require('boom')\n\n// Import internal dependancies\nconst fastify = require('../server.js')\n\n// Fake data\nconst cars = [\n\t{\n\t\tname: 'Tesla',\n\t\tmodels: ['S', 'E', 'X', 'Y']\n\t},\n\t{\n\t\tname: 'Mercedes',\n\t\tmodels: ['GLA', 'GLC', 'GLE', 'GLS']\n\t},\n\t{\n\t\tname: 'BMW',\n\t\tmodels: ['X4', 'Z3', 'M2', '7']\n\t},\n\t{\n\t\tname: 'Audi',\n\t\tmodels: ['A1', 'A3', 'A4', 'A5']\n\t},\n\t{\n\t\tname: 'Ford',\n\t\tmodels: ['Fiesta', 'Focus', 'Fusion', 'Mustang']\n\t}\n]\nconst serviceGarages = ['A++ Auto Services', \"Gary's Garage\", 'Super Service', 'iGarage', 'Best Service']\n\n// Get Data Models\nconst Car = require('../models/Car')\nconst Owner = require('../models/Owner')\nconst Service = require('../models/Service')\n\n// Fake data generation functions\nconst generateOwnerData = () =&gt; {\n\tlet ownerData = []\n\tlet i = 0\n\n\twhile (i &lt; 50) {\n\t\tconst firstName = faker.fake('{{name.firstName}}')\n\t\tconst lastName = faker.fake('{{name.lastName}}')\n\t\tconst email = faker.fake(`${firstName.toLowerCase()}.${lastName.toLowerCase()}@gmail.com`)\n\n\t\tconst owner = {\n\t\t\tfirstName,\n\t\t\tlastName,\n\t\t\temail\n\t\t}\n\n\t\townerData.push(owner)\n\t\ti++\n\t}\n\n\treturn ownerData\n}\n\nconst generateCarData = ownersIds =&gt; {\n\tlet carData = []\n\tlet i = 0\n\n\twhile (i &lt; 1000) {\n\t\tconst owner_id = faker.random.arrayElement(ownersIds)\n\t\tconst carObject = faker.random.arrayElement(cars)\n\t\tconst title = faker.random.arrayElement(carObject.models)\n\t\tconst price = faker.random.number({ min: 5000, max: 30000 })\n\t\tconst age = faker.random.number({ min: 2, max: 10 })\n\n\t\tconst car = {\n\t\t\towner_id,\n\t\t\tbrand: carObject.name,\n\t\t\ttitle,\n\t\t\tprice,\n\t\t\tage\n\t\t}\n\n\t\tcarData.push(car)\n\t\ti++\n\t}\n\n\treturn carData\n}\n\nconst generateServiceData = carsIds =&gt; {\n\tlet serviceData = []\n\tlet i = 0\n\n\twhile (i &lt; 5000) {\n\t\tconst car_id = faker.random.arrayElement(carsIds)\n\t\tconst name = faker.random.arrayElement(serviceGarages)\n\t\tconst date = faker.fake('{{date.past}}')\n\n\t\tconst service = {\n\t\t\tcar_id,\n\t\t\tname,\n\t\t\tdate\n\t\t}\n\n\t\tserviceData.push(service)\n\t\ti++\n\t}\n\n\treturn serviceData\n}\n\nfastify.ready().then(\n\tasync () =&gt; {\n\t\ttry {\n\t\t\tconst owners = await Owner.insertMany(generateOwnerData())\n\t\t\tconst ownersIds = owners.map(x =&gt; x._id)\n\n\t\t\tconst cars = await Car.insertMany(generateCarData(ownersIds))\n\t\t\tconst carsIds = cars.map(x =&gt; x._id)\n\n\t\t\tconst services = await Service.insertMany(generateServiceData(carsIds))\n\n\t\t\tconsole.log(`\n      Data successfully added:\n        - ${owners.length} owners added.\n        - ${cars.length} cars added.\n        - ${services.length} services added.\n      `)\n\t\t} catch (err) {\n\t\t\tthrow boom.boomify(err)\n\t\t}\n\t\tprocess.exit()\n\t},\n\terr =&gt; {\n\t\tconsole.log('An error occured: ', err)\n\t\tprocess.exit()\n\t}\n)</code></pre><figcaption>seed.js</figcaption></figure><p>Let\u2019s break down this mountain of code:</p><p>First we import two external libraries, <a href=\"https://github.com/marak/Faker.js/\" rel=\"noopener\"><strong>Faker.js</strong></a><strong> </strong>which is used to generate fake data and <a href=\"https://github.com/hapijs/boom\" rel=\"noopener\"><strong>Boom</strong></a>, which is used to throw http friendly error objects.</p><p>Then we import the <code>server.js</code> file which will spin up an instance of our server allowing us to interact with the <strong>models</strong>.</p><p>We then declare two arrays with fake data, <code>cars</code> and <code>serviceGarages</code>.</p><p>Then we import the <code>models</code> and declare three functions (<code>generateOwnerData</code>, <code>generateCarData</code>, <code>generateServiceData</code>) which each return an array of objects with the <strong>owner</strong>, <strong>car</strong> and <strong>service</strong> data respectively.</p><p>Once the <strong>Fastify.js </strong>instance is ready we use the <a href=\"https://mongoosejs.com/docs/api.html#model_Model.insertMany\" rel=\"noopener\"><strong>Mongoose </strong><code>insertMany()</code> function</a> to insert the generated arrays into the database. The function then returns an array of objects containing the original object data and <code>ids</code> of the each record.</p><p>We use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\" rel=\"noopener\"><strong>JavaScript Map</strong></a> function to create an array of <code>ids</code> <strong>owners</strong> and <strong>cars</strong> arrays. We use the <code>ownersIDs</code> array for when generating car data and we use the <code>carsIds</code> array when generating service data, they are passed into the respective functions and then values are randomly selected from them.</p><p>Lastly we need to install the <strong>Faker.js</strong> package and add the seed task to our <code>package.json</code> file.</p><p>We can add the <strong>Faker.js </strong>package by navigating to the <strong>root directory</strong> and running the following code:</p><pre tabindex=\"0\"><code>npm i faker -D</code></pre><p>We then add the following to the <code>package.json</code> file:</p><pre tabindex=\"0\"><code>...\n\n\"scripts\": {\n\n...\n\n\"seed\": \"node ./src/helpers/seed.js\"\n\n},\n\n...</code></pre><p>That\u2019s it! We can now run our seeding script from the project root directory with the following code:</p><pre tabindex=\"0\"><code>npm run seed</code></pre><p>If you are using <a href=\"https://www.mongodb.com/products/compass\" rel=\"noopener\">MongoDB Compass</a> (you should), you will see the data in your database:</p><figure><img alt=\"hLUq7STJYtprAMW0fDIVlAj3s-u4FulWVUlZ\" height=\"131\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/hLUq7STJYtprAMW0fDIVlAj3s-u4FulWVUlZ\" width=\"800\"/><figcaption>\u201cmycargarage\u201d database viewed in MongoDB Compass</figcaption></figure><h3 id=\"graphql-installation-setup-and-testing\">GraphQL installation, setup and testing</h3><figure><img alt=\"tPZMxs0WHzOis6DPoX-T6Jo3RhAlLeBFXYR-\" height=\"280\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/tPZMxs0WHzOis6DPoX-T6Jo3RhAlLeBFXYR-\" width=\"800\"/></figure><p>Let\u2019s get started by navigating to the <strong>root directory</strong> and running the following code:</p><pre tabindex=\"0\"><code>npm i fastify-gql graphql</code></pre><p>The above installs <strong>GraphQL</strong> and the <strong>Fastify barebone GraphQL</strong> adapter.</p><p>Navigate to the <code>src</code> directory and run the following code:</p><pre tabindex=\"0\"><code>mkdir schema\ncd shema\ntouch index.js</code></pre><p>Navigate to the <code>src</code> directory update the <code>index.js</code> file with the following:</p><pre tabindex=\"0\"><code>// Import Server\nconst fastify = require('./server.js')\n\n// Import external dependancies\nconst gql = require('fastify-gql')\n\n// Import GraphQL Schema\nconst schema = require('./schema')\n\n// Register Fastify GraphQL\nfastify.register(gql, {\n   schema,\n   graphiql: true\n})\n\n... end here\n\n// Import Routes\nconst routes = require('./routes')</code></pre><p>With the above code we require the <strong>Fastify GraphQL Adapter, </strong>import the <strong>schema </strong>and register the <strong>GraphQl Adapter </strong>with <strong>Fastify.</strong></p><p>We register the <strong>schema </strong>and enable <strong>GraphiQL, </strong>an in-browser <a href=\"https://en.wikipedia.org/wiki/Integrated_development_environment\" rel=\"noopener\"><strong>IDE</strong></a> for exploring <strong>GraphQL</strong>.</p><p>Navigate to the <code>schema</code> directory and open the <code>index.js</code> file and add the following boilerplate code:</p><figure><pre tabindex=\"0\"><code>// Import External Dependancies\nconst graphql = require('graphql')\n\n// Destructure GraphQL functions\nconst {\n\tGraphQLSchema,\n\tGraphQLObjectType,\n\tGraphQLString,\n\tGraphQLInt,\n\tGraphQLID,\n\tGraphQLList,\n\tGraphQLNonNull\n} = graphql\n\n// Import Controllers\nconst carController = require('../controllers/carController')\nconst ownerController = require('../controllers/ownerController')\nconst serviceController = require('../controllers/serviceController')\n\n// Define Object Types\nconst carType = new GraphQLObjectType({\n\tname: 'Car',\n\tfields: () =&gt; ({})\n})\n\nconst ownerType = new GraphQLObjectType({\n\tname: 'Owner',\n\tfields: () =&gt; ({})\n})\n\nconst serviceType = new GraphQLObjectType({\n\tname: 'Service',\n\tfields: () =&gt; ({})\n})\n\n// Define Root Query\nconst RootQuery = new GraphQLObjectType({\n\tname: 'RootQueryType',\n\tfields: {\n\t\tcar: {},\n\t\tcars: {},\n\t\towner: {},\n\t\tservice: {}\n\t}\n})\n\n// Define Mutations\nconst Mutations = new GraphQLObjectType({\n\tname: 'Mutations',\n\tfields: {\n\t\taddCar: {\n\t\t\ttype: carType,\n\t\t\targs: {},\n\t\t\tasync resolve(args) {\n\t\t\t\treturn ''\n\t\t\t}\n\t\t},\n\t\teditCar: {\n\t\t\ttype: carType,\n\t\t\targs: {},\n\t\t\tasync resolve(args) {\n\t\t\t\treturn ''\n\t\t\t}\n\t\t},\n\t\tdeleteCar: {\n\t\t\ttype: carType,\n\t\t\targs: {},\n\t\t\tasync resolve(args) {\n\t\t\t\treturn ''\n\t\t\t}\n\t\t}\n\t}\n})\n\n// Export the schema\nmodule.exports = new GraphQLSchema({\n\tquery: RootQuery,\n\tmutation: Mutations\n})</code></pre><figcaption>index.js</figcaption></figure><p>Let\u2019s run through the above code:</p><p>We require the main <strong>GraphQL </strong>package and use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\" rel=\"noopener\">JavaScript Destructuring</a> to get the necessary <strong>GraphQL </strong>functions(<code>GraphQLSchema</code>, <code>GraphQLObjectType</code>, <code>GraphQLString</code>, <code>GraphQLInt</code>, <code>GraphQLID</code>, <code>GraphQLList</code> and <code>GraphQLNonNull</code>).</p><p>We import our three <code>controllers</code> (<code>carController</code>, <code>ownerController</code> and <code>serviceController</code>).</p><p>We declare the <code>carType</code>, <code>ownerType</code> and <code>serviceType</code> <a href=\"https://graphql.org/graphql-js/object-types/\" rel=\"noopener\"><strong>GraphQL Object Types</strong></a><strong>, </strong>which are functions that accept an object as a parameter, with a <code>name</code> and a <code>fields</code> key.</p><p>These functions are used to define our <strong>GraphQL </strong>schema, similar to the <strong>Mongoose </strong>models defined earlier.</p><p>The fields can return a particular <strong>type</strong>, and <strong>methods</strong> that take arguments. <a href=\"https://graphql.org/graphql-js/object-types/\" rel=\"noopener\">Learn More about Object Types</a>.</p><p>Then we declare the <code>RootQuery</code> which is also a <strong>GraphQL Object Type</strong> and is found at the top level of every <strong>GraphQL</strong> server. It represents all of the possible entry points into the <strong>GraphQL API. </strong><a href=\"https://graphql.org/learn/execution/\" rel=\"noopener\">Learn More about root fields and resolvers</a>.</p><p>We then declare our <code>Mutations</code>, which are used to <strong>change data.</strong> Although any query could be implemented to change data, operations that cause changes should be sent explicitly <strong>via a mutation</strong>. <a href=\"https://graphql.org/learn/queries/#mutations\" rel=\"noopener\">Learn More about Mutations</a>.</p><p>Lastly we export the <code>GraphQLSchema.</code></p><p>Now that we have our template setup we can start populating the <strong>Object Types</strong>, <strong>Root Query</strong> and <strong>Mutations</strong>.</p><p>Note that there are <a href=\"https://github.com/sarkistlt/mongoose-schema-to-graphql\" rel=\"noopener\">Mongoose to GraphQL</a> schema generators available, but for the tutorial purposes we will manually create the schema.</p><p>Let\u2019s update the <code>carType</code> <strong>Object Type</strong> as follows:</p><figure><pre tabindex=\"0\"><code>const carType = new GraphQLObjectType({\n\tname: 'Car',\n\tfields: () =&gt; ({\n\t\t_id: { type: GraphQLID },\n\t\ttitle: { type: GraphQLString },\n\t\tbrand: { type: GraphQLString },\n\t\tprice: { type: GraphQLString },\n\t\tage: { type: GraphQLInt },\n\t\towner_id: { type: GraphQLID },\n\t\towner: {\n\t\t\ttype: ownerType,\n\t\t\tasync resolve(parent, args) {\n\t\t\t\treturn await ownerController.getSingleOwner({ id: parent.owner_id })\n\t\t\t}\n\t\t},\n\t\tservices: {\n\t\t\ttype: new GraphQLList(serviceType),\n\t\t\tasync resolve(parent, args) {\n\t\t\t\treturn await serviceController.getCarsServices({ id: parent._id })\n\t\t\t}\n\t\t}\n\t})\n})</code></pre><figcaption>carType Object Type</figcaption></figure><p>Let\u2019s dive deeper into the <strong>GraphQL </strong>functions, starting with the <a href=\"https://softwareengineering.stackexchange.com/questions/238033/what-does-it-mean-when-data-is-scalar\" rel=\"noopener\">Scalars</a> types in <strong>GraphQL</strong>:</p><p><strong>GraphQL</strong> comes with a set of default scalar types out of the box:</p><ul><li><code>Int</code>: A signed 32\u2010bit integer. <code>GraphQLInt</code></li><li><code>Float</code>: A signed double-precision floating-point value. <code>GraphQLFloat</code></li><li><code>String</code>: A UTF\u20108 character sequence. <code>GraphQLString</code></li><li><code>Boolean</code>: <code>true</code> or <code>false</code>. <code>GraphQLBoolean</code></li><li><code>ID</code>: The ID scalar type represents a unique identifier, often used to refetch an object or as the key for a cache. The ID type is serialised in the same way as a String; however, defining it as an <code>ID</code> signifies that it is not intended to be human\u2010readable. <code>GraphQLID</code></li></ul><p>The <code>owner</code> and <code>service</code> fields are where it gets interesting. These fields are not defined as <strong>Scalar types</strong> like the rest \u2014 instead, their <code>type</code> is referencing the <code>ownerType</code> and <code>serviceType</code> that we have created and are yet to populate.</p><p>The second argument that we pass into the <code>owner</code> and <code>service</code> fields are <a href=\"https://graphql.org/learn/execution/\" rel=\"noopener\">resolver</a> functions.</p><p>Resolver functions or methods are functions that <strong>resolves a value</strong> for a type or field in a schema</p><p>Resolvers can be asynchronous too! They can resolve values from another <strong>REST API, database, cache, constant, etc.</strong></p><blockquote>You can think of each field in a GraphQL query as a function or method of the previous type which returns the next type. In fact, this is exactly how GraphQL works. Each field on each type is backed by a function called the <em>resolver</em> which is provided by the GraphQL server developer. When a field is executed, the corresponding <em>resolver</em> is called to produce the next value.<p>If a field produces a scalar value like a string or number, then the execution completes. However if a field produces an object value then the query will contain another selection of fields which apply to that object. This continues until scalar values are reached. GraphQL queries always end at scalar values.</p></blockquote><p>In order to create the relationship between the different types we pass the <code>_id</code> and the <code>owner_id</code> values into the respective controller functions.</p><p>So essentially we are requesting the owner details along with the car details:</p><pre tabindex=\"0\"><code>return await userController.getSingleOwner({ id: parent.owner_id })</code></pre><p>and the details of all the services related to the car:</p><pre tabindex=\"0\"><code>return await serviceController.getCarsServices({ id: parent._id })</code></pre><p>To return a list or array from with <strong>GraphQL, </strong>we use the <code>GraphQLList</code>. <a href=\"https://graphqlmastery.com/blog/graphql-list-how-to-use-arrays-in-graphql-schema\" rel=\"noopener\">Here</a> is a great in depth tutorial about using arrays in <strong>GraphQL</strong> Schema, but it is really simple: whenever we need an array we will use the <code>GraphQLList</code> function.</p><p>Let\u2019s update the <code>ownerType</code> and <code>serviceType</code> with the following code:</p><figure><pre tabindex=\"0\"><code>const ownerType = new GraphQLObjectType({\n\tname: 'Owner',\n\tfields: () =&gt; ({\n\t\t_id: { type: GraphQLID },\n\t\tfirstName: { type: GraphQLString },\n\t\tlastName: { type: GraphQLString },\n\t\temail: { type: GraphQLString },\n\t\tcars: {\n\t\t\ttype: new GraphQLList(carType),\n\t\t\tasync resolve(parent, args) {\n\t\t\t\treturn await ownerController.getOwnersCars({ id: parent._id })\n\t\t\t}\n\t\t}\n\t})\n})</code></pre><figcaption>ownerType Object Type</figcaption></figure><figure><pre tabindex=\"0\"><code>const serviceType = new GraphQLObjectType({\n\tname: 'Service',\n\tfields: () =&gt; ({\n\t\t_id: { type: GraphQLID },\n\t\tcar_id: { type: GraphQLID },\n\t\tname: { type: GraphQLString },\n\t\tdate: { type: GraphQLString },\n\t\tcar: {\n\t\t\ttype: carType,\n\t\t\tasync resolve(parent, args) {\n\t\t\t\treturn await carController.getSingleCar({ id: parent.car_id })\n\t\t\t}\n\t\t}\n\t})\n})</code></pre><figcaption>serviceType Object Type</figcaption></figure><p>The above two <strong>Object Types</strong> are very similar to the <code>carType</code>. You can notice a pattern between the different <strong>Object Types</strong> and their relationships.</p><p>We can now populate the <code>RootQuery</code> root with the following code:</p><figure><pre tabindex=\"0\"><code>const RootQuery = new GraphQLObjectType({\n\tname: 'RootQueryType',\n\tfields: {\n\t\tcar: {\n\t\t\ttype: carType,\n\t\t\targs: { id: { type: GraphQLID } },\n\t\t\tasync resolve(parent, args) {\n\t\t\t\treturn await carController.getSingleCar(args)\n\t\t\t}\n\t\t},\n\t\tcars: {\n\t\t\ttype: new GraphQLList(carType),\n\t\t\tasync resolve(parent, args) {\n\t\t\t\treturn await carController.getCars()\n\t\t\t}\n\t\t},\n\t\towner: {\n\t\t\ttype: ownerType,\n\t\t\targs: { id: { type: GraphQLID } },\n\t\t\tasync resolve(parent, args) {\n\t\t\t\treturn await ownerController.getSingleOwner(args)\n\t\t\t}\n\t\t},\n\t\tservice: {\n\t\t\ttype: serviceType,\n\t\t\targs: { id: { type: GraphQLID } },\n\t\t\tasync resolve(parent, args) {\n\t\t\t\treturn await serviceController.getSingleService(args)\n\t\t\t}\n\t\t}\n\t}\n})</code></pre><figcaption>rootQuery Object Type</figcaption></figure><p>There are no new concepts in the above code, but keep in mind that the <code>RootQuery</code> query is the entry point to all queries on the <strong>GraphQL API.</strong> So from the above we can see that we can run the following queries directly:</p><ul><li>Get all the Cars</li><li>Get a single Car</li><li>Get a single Owner</li><li>Get a single Service</li></ul><p>Let\u2019s open the <strong>GraphiQL </strong>user interface and build some queries: <a href=\"http://localhost:3000/graphiql.html\" rel=\"noopener\">http://localhost:3000/graphiql.html</a></p><figure><img alt=\"uu6PQdqiUejeUuFsO1KdXl2v7PYpF6KsOGOJ\" height=\"497\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/uu6PQdqiUejeUuFsO1KdXl2v7PYpF6KsOGOJ\" width=\"800\"/></figure><p>Queries are entered on the left, results are in the middle, and the documentation explorer is on the right.</p><p>The documentation explorer can be used to explore the entire graph down to Scalar level. This is very helpful when building queries.</p><p>The language used to build the queries resembles JSON. This <a href=\"https://devhints.io/graphql\" rel=\"noopener\">cheat sheet</a> is a great a reference.</p><p>Below demonstrates why <strong>GraphQL </strong>is so awesome<strong>:</strong></p><figure><img alt=\"vCpUlnX-63eB2nXol3wNb7bb7MpNkUz8jFXm\" height=\"470\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/vCpUlnX-63eB2nXol3wNb7bb7MpNkUz8jFXm\" width=\"800\"/><figcaption>GraphiQL IDE</figcaption></figure><p>In the above example, we are using the <code>cars</code> root query to display a list of all the cars, their owners, and their services.</p><figure><img alt=\"5-b6eyxOlNA5SsgL89U85EkJXmr6IRMCpLtT\" height=\"451\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/5-b6eyxOlNA5SsgL89U85EkJXmr6IRMCpLtT\" width=\"800\"/><figcaption>Get a single car \u2014 car root query</figcaption></figure><figure><img alt=\"zvztPdLyGRN-Sha3ZkZ9QhyjGRrZjC2dhfyw\" height=\"247\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/zvztPdLyGRN-Sha3ZkZ9QhyjGRrZjC2dhfyw\" width=\"800\"/><figcaption>Get a single owner \u2014 owner root query</figcaption></figure><figure><img alt=\"sX3N-8B8PUkpqlWpOwLBFCAymL3U8A7pHHtS\" height=\"234\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/sX3N-8B8PUkpqlWpOwLBFCAymL3U8A7pHHtS\" width=\"800\"/><figcaption>Get a single service \u2014 service root query</figcaption></figure><p>We have one final topic to address, and that is <code>mutations</code>. Let\u2019s update the <code>mutations</code> with the following code:</p><figure><pre tabindex=\"0\"><code>const Mutations = new GraphQLObjectType({\n\tname: 'Mutations',\n\tfields: {\n\t\taddCar: {\n\t\t\ttype: carType,\n\t\t\targs: {\n\t\t\t\ttitle: { type: new GraphQLNonNull(GraphQLString) },\n\t\t\t\tbrand: { type: new GraphQLNonNull(GraphQLString) },\n\t\t\t\tprice: { type: GraphQLString },\n\t\t\t\tage: { type: GraphQLInt },\n\t\t\t\towner_id: { type: GraphQLID }\n\t\t\t},\n\t\t\tasync resolve(parent, args) {\n\t\t\t\tconst data = await carController.addCar(args)\n\t\t\t\treturn data\n\t\t\t}\n\t\t},\n\t\teditCar: {\n\t\t\ttype: carType,\n\t\t\targs: {\n\t\t\t\tid: { type: new GraphQLNonNull(GraphQLID) },\n\t\t\t\ttitle: { type: new GraphQLNonNull(GraphQLString) },\n\t\t\t\tbrand: { type: new GraphQLNonNull(GraphQLString) },\n\t\t\t\tprice: { type: new GraphQLNonNull(GraphQLString) },\n\t\t\t\tage: { type: new GraphQLNonNull(GraphQLInt) },\n\t\t\t\towner_id: { type: GraphQLID }\n\t\t\t},\n\t\t\tasync resolve(parent, args) {\n\t\t\t\tconst data = await carController.updateCar(args)\n\t\t\t\treturn data\n\t\t\t}\n\t\t},\n\t\tdeleteCar: {\n\t\t\ttype: carType,\n\t\t\targs: {\n\t\t\t\tid: { type: new GraphQLNonNull(GraphQLID) }\n\t\t\t},\n\t\t\tasync resolve(parent, args) {\n\t\t\t\tconst data = await carController.deleteCar(args)\n\t\t\t\treturn data\n\t\t\t}\n\t\t}\n\t}\n})</code></pre><figcaption>mutations</figcaption></figure><p>As before, we declare our <strong>Object Type</strong>, specify the <strong>name</strong> and the <strong>fields</strong>.</p><p>A mutation consists of the the <strong>type</strong>, <strong>args </strong>and the <strong>async resolve</strong> function. The <strong>resolve</strong> function passes the args to the controller, which returns the result of the mutation.</p><figure><img alt=\"tYpE1tGBixN4mxO8kfdXer-MXBXDqDPHNjdQ\" height=\"369\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/tYpE1tGBixN4mxO8kfdXer-MXBXDqDPHNjdQ\" width=\"800\"/><figcaption>addCar Mutation</figcaption></figure><figure><img alt=\"i57zXGAVZ1qVKIv69sNLSXJs4H351cx7mB9j\" height=\"370\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/i57zXGAVZ1qVKIv69sNLSXJs4H351cx7mB9j\" width=\"800\"/><figcaption>editCar Mutation</figcaption></figure><figure><img alt=\"MZW4-sSHxitchUGDZQUUEAZ-xMH-8BqnXzVa\" height=\"370\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/MZW4-sSHxitchUGDZQUUEAZ-xMH-8BqnXzVa\" width=\"800\"/><figcaption>deleteCar Mutation</figcaption></figure><p>You have now coded a fully functional <strong>REST API</strong> and a fully functional <strong>GraphQL API.</strong></p><p>There are no rules stating that one should use exclusively <strong>REST </strong>or exclusively <strong>GraphQL.</strong> In some projects, the best solution may be a mix of both. This is really determined on a project-to-project basis.</p><p>You can download the source code form Git <a href=\"https://github.com/siegfriedgrimbeek/fastify-graphql-api\" rel=\"noopener\">here</a>.</p><h4 id=\"what-is-next\">What is Next?</h4><p>In the next tutorial, we will consume our <strong>GraphQL</strong> <strong>API</strong> with a <strong>Vue.js </strong>frontend as a single page application!</p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nThis tutorial is part two of a four part series, which aims to take you from scratch to deploying a fully functional full stack application.Part 1: How to build blazing fast REST APIs with Node.js, MongoDB, Fastify and SwaggerPart 2: How to build a blazing fast GraphQL API with Node.js, MongoDB, Fastify and GraphQL! (You are here.)Part 3: Coupling Vue.js with a GraphQL API.Part 4: Deploying a GraphQL API and Vue.js frontend application.The first part of the series is available here and the source code for the application can be found here.In this part we will revisit the models, controllers and routes from part one and then integrate GraphQL into the application. As a bonus we will also use Faker.js to create some fake data and seed the database.Introduction:GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data.Every GraphQL query goes through three phases: the queries are parsed, validated and executed.GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need, makes it easier to evolve APIs over time, and enables powerful developer tools. Learn More.\n        \n          \n            \n          \n        \n      Prerequisites\u2026If you have completed the first part of this series, you should be up to speed with beginner/intermediate JavaScript knowledge, Node.js, Fastify.JS and MongoDB (Mongoose).To follow along, you will need to complete part one of this series or grab the code from Git, although I would highly recommend at least skimming through part one.Let\u2019s get started!Clone the repo for part one (skip this step if you followed part one and you are continuing with your own code) by opening your terminal, navigating to your project directory and executing each of the following lines of code:git clone https://github.com/siegfriedgrimbeek/fastify-api.git\ncd fastify-apiSo now that we have a copy of the codebase we will update our packages and package.json file by running the following code:sudo npm i -g npm-check-updates\nncu -u\nnpm installFirst we globally install the npm package \u201cnpm-check-updates\u201d and then we use this package to automatically update our package.json file with the latest package versions and then we install/update all our npm modules by running npm install.This is done to ensure that everyone completing the tutorial is working with the same package versions.Refactor our server and start the app!As with all software solutions, as the solution grows, developers often need to revisit and refactor the code.In the src directory we will create a new file called server.js:cd src\ntouch server.jsAdd the following code code to the server.js file:// Require the fastify framework and instantiate it\nconst fastify = require('fastify')({\n\tlogger: true\n})\n\n// Require external modules\nconst mongoose = require('mongoose')\n\n// Connect to DB\nmongoose\n\t.connect('mongodb://localhost/mycargarage')\n\t.then(() => console.log('MongoDB connected...'))\n\t.catch(err => console.log(err))\n\nmodule.exports = fastifyserver.jsWe have now extracted the logic that starts the server to the server.js file, allowing us to reuse this code throughout the project.Next we need to update our index.js file in the src directory:\n// Import Server\nconst fastify = require('./server.js')\n\n// Import Routes\nconst routes = require('./routes')\n\n// Import Swagger Options\nconst swagger = require('./config/swagger')\n\n// Register Swagger\nfastify.register(require('fastify-swagger'), swagger.options)\n\n// Loop over each route\nroutes.forEach((route, index) => {\n\tfastify.route(route)\n})\n\n// Run the server!\nconst start = async () => {\n\ttry {\n\t\tawait fastify.listen(3000, '0.0.0.0')\n\t\tfastify.swagger()\n\t\tfastify.log.info(`server listening on ${fastify.server.address().port}`)\n\t} catch (err) {\n\t\tfastify.log.error(err)\n\t\tprocess.exit(1)\n\t}\n}\nstart()index.jsWe will revisit the index.js file, once we setup and configure GraphQL.Start the Fastify server by running the following code in your terminal:npm startNote that there is no default route setup so for now, navigating to http://localhost:3000/ will result in the server returning a 404 error which is correct.Start MongoDB and update the modelsLet\u2019s extend the existing model to also include Services and Owners. The below diagram below demonstrates the relationships between the collections:Data modelsOne car can have one owner.One owner can have many cars.One car can have many services.Revisit the Car.js file in the models directory and update it as follows:// External Dependancies\nconst mongoose = require(\"mongoose\")\nconst ObjectId = mongoose.Schema.Types.ObjectId\n\nconst carSchema = new mongoose.Schema({\n  title: String,\n  brand: String,\n  price: String,\n  age: Number,\n  owner_id: ObjectId\n})\n\nmodule.exports = mongoose.model(\"Car\", carSchema)Car.jsCreate two new files in the models directory, Owner.js and Service.js and add the following code to the files respectively:Owner.js// External Dependancies\nconst mongoose = require('mongoose')\n\nconst ownerSchema = new mongoose.Schema({\n\tfirstName: String,\n\tlastName: String,\n\temail: String\n})\n\nmodule.exports = mongoose.model('Owner', ownerSchema)Owner.jsService.js// External Dependancies\nconst mongoose = require(\"mongoose\")\nconst ObjectId = mongoose.Schema.Types.ObjectId\n\nconst serviceSchema = new mongoose.Schema({\n  car_id: ObjectId,\n  name: String,\n  date: String\n})\n\nmodule.exports = mongoose.model(\"Service\", serviceSchema)\nview rawService.js hosted with \u2764 by GitHubThere are no new concepts used in the above code. We have just created standard Mongoose Schemas, as with the Car.js model.Revisit the Car Controller and create the additional controllersThere are some slight changes to the carController.js so navigate to the controllers directory and update your file as per below:// External Dependancies\nconst boom = require('boom')\n\n// Get Data Models\nconst Car = require('../models/Car')\n\n// Get all cars\nexports.getCars = async () => {\n\ttry {\n\t\tconst cars = await Car.find()\n\t\treturn cars\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}\n\n// Get single car by ID\nexports.getSingleCar = async req => {\n\ttry {\n\t\tconst id = req.params === undefined ? req.id : req.params.id\n\t\tconst car = await Car.findById(id)\n\t\treturn car\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}\n\n// Add a new car\nexports.addCar = async req => {\n\ttry {\n\t\tconst car = new Car(req)\n\t\tconst newCar = await car.save()\n\t\treturn newCar\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}\n\n// Update an existing car\nexports.updateCar = async req => {\n\ttry {\n\t\tconst id = req.params === undefined ? req.id : req.params.id\n\t\tconst updateData = req.params === undefined ? req : req.params\n\t\tconst update = await Car.findByIdAndUpdate(id, updateData, { new: true })\n\t\treturn update\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}\n\n// Delete a car\nexports.deleteCar = async req => {\n\ttry {\n\t\tconst id = req.params === undefined ? req.id : req.params.id\n\t\tconst car = await Car.findByIdAndRemove(id)\n\t\treturn car\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}carController.jsCreate two new files in the controllers directory, serviceController.js and ownerController.js, and add the following code to the files respectively:serviceController.js// External Dependancies\nconst boom = require('boom')\n\n// Get Data Models\nconst Service = require('../models/Service')\n\n// Get single service ID\nexports.getSingleService = async req => {\n\ttry {\n\t\tconst id = req.params === undefined ? req.id : req.params.id\n\t\tconst service = await Service.findById(id)\n\t\treturn service\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}\n\n// Get single car's services\nexports.getCarsServices = async req => {\n\ttry {\n\t\tconst id = req.params === undefined ? req.id : req.params.id\n\t\tconst services = await Service.find({ car_id: id })\n\t\treturn services\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}serviceController.jsownerController.js// External Dependancies\nconst boom = require('boom')\n\n// Get Data Models\nconst Owner = require('../models/Owner')\nconst Car = require('../models/Car')\n\n// Get all owners\nexports.getOwner = async () => {\n\ttry {\n\t\tconst owners = await Owner.find()\n\t\treturn owners\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}\n\n// Get single owner by ID\nexports.getSingleOwner = async req => {\n\ttry {\n\t\tconst id = req.params === undefined ? req.id : req.params.id\n\t\tconst owner = await Owner.findById(id)\n\t\treturn owner\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}\n\n// Get single owner's cars\nexports.getOwnersCars = async req => {\n\ttry {\n\t\tconst id = req.params === undefined ? req.id : req.params.id\n\t\tconst cars = await Car.find({ owner_id: id })\n\t\treturn cars\n\t} catch (err) {\n\t\tthrow boom.boomify(err)\n\t}\n}ownerController.jsThe biggest change to the controllers is how we get the parameters:const id = req.params === undefined ? req.id : req.params.id\nconst updateData = req.params === undefined ? req : req.paramsThe above code is called a \u201cconditional (ternary) operator\u201d and is used as shorthand for the following if statement:let id\n\nif (req.params === undefined) {\n\nid = req.id\n\n} else {\n\nid = req.params.id\n\n}We are using the ternary operator to accommodate requests from both the REST API and the GraphQL API, as they have a slightly different implementation.Time to seed the database with some fake data!In the src directory let\u2019s create a new directory and file by running the following code:mkdir helpers\ntouch seed.jsAdd the following code to the seed.js file:\n// Import external dependancies\nconst faker = require('faker')\nconst boom = require('boom')\n\n// Import internal dependancies\nconst fastify = require('../server.js')\n\n// Fake data\nconst cars = [\n\t{\n\t\tname: 'Tesla',\n\t\tmodels: ['S', 'E', 'X', 'Y']\n\t},\n\t{\n\t\tname: 'Mercedes',\n\t\tmodels: ['GLA', 'GLC', 'GLE', 'GLS']\n\t},\n\t{\n\t\tname: 'BMW',\n\t\tmodels: ['X4', 'Z3', 'M2', '7']\n\t},\n\t{\n\t\tname: 'Audi',\n\t\tmodels: ['A1', 'A3', 'A4', 'A5']\n\t},\n\t{\n\t\tname: 'Ford',\n\t\tmodels: ['Fiesta', 'Focus', 'Fusion', 'Mustang']\n\t}\n]\nconst serviceGarages = ['A++ Auto Services', \"Gary's Garage\", 'Super Service', 'iGarage', 'Best Service']\n\n// Get Data Models\nconst Car = require('../models/Car')\nconst Owner = require('../models/Owner')\nconst Service = require('../models/Service')\n\n// Fake data generation functions\nconst generateOwnerData = () => {\n\tlet ownerData = []\n\tlet i = 0\n\n\twhile (i < 50) {\n\t\tconst firstName = faker.fake('{{name.firstName}}')\n\t\tconst lastName = faker.fake('{{name.lastName}}')\n\t\tconst email = faker.fake(`${firstName.toLowerCase()}.${lastName.toLowerCase()}@gmail.com`)\n\n\t\tconst owner = {\n\t\t\tfirstName,\n\t\t\tlastName,\n\t\t\temail\n\t\t}\n\n\t\townerData.push(owner)\n\t\ti++\n\t}\n\n\treturn ownerData\n}\n\nconst generateCarData = ownersIds => {\n\tlet carData = []\n\tlet i = 0\n\n\twhile (i < 1000) {\n\t\tconst owner_id = faker.random.arrayElement(ownersIds)\n\t\tconst carObject = faker.random.arrayElement(cars)\n\t\tconst title = faker.random.arrayElement(carObject.models)\n\t\tconst price = faker.random.number({ min: 5000, max: 30000 })\n\t\tconst age = faker.random.number({ min: 2, max: 10 })\n\n\t\tconst car = {\n\t\t\towner_id,\n\t\t\tbrand: carObject.name,\n\t\t\ttitle,\n\t\t\tprice,\n\t\t\tage\n\t\t}\n\n\t\tcarData.push(car)\n\t\ti++\n\t}\n\n\treturn carData\n}\n\nconst generateServiceData = carsIds => {\n\tlet serviceData = []\n\tlet i = 0\n\n\twhile (i < 5000) {\n\t\tconst car_id = faker.random.arrayElement(carsIds)\n\t\tconst name = faker.random.arrayElement(serviceGarages)\n\t\tconst date = faker.fake('{{date.past}}')\n\n\t\tconst service = {\n\t\t\tcar_id,\n\t\t\tname,\n\t\t\tdate\n\t\t}\n\n\t\tserviceData.push(service)\n\t\ti++\n\t}\n\n\treturn serviceData\n}\n\nfastify.ready().then(\n\tasync () => {\n\t\ttry {\n\t\t\tconst owners = await Owner.insertMany(generateOwnerData())\n\t\t\tconst ownersIds = owners.map(x => x._id)\n\n\t\t\tconst cars = await Car.insertMany(generateCarData(ownersIds))\n\t\t\tconst carsIds = cars.map(x => x._id)\n\n\t\t\tconst services = await Service.insertMany(generateServiceData(carsIds))\n\n\t\t\tconsole.log(`\n      Data successfully added:\n        - ${owners.length} owners added.\n        - ${cars.length} cars added.\n        - ${services.length} services added.\n      `)\n\t\t} catch (err) {\n\t\t\tthrow boom.boomify(err)\n\t\t}\n\t\tprocess.exit()\n\t},\n\terr => {\n\t\tconsole.log('An error occured: ', err)\n\t\tprocess.exit()\n\t}\n)seed.jsLet\u2019s break down this mountain of code:First we import two external libraries, Faker.js which is used to generate fake data and Boom, which is used to throw http friendly error objects.Then we import the server.js file which will spin up an instance of our server allowing us to interact with the models.We then declare two arrays with fake data, cars and serviceGarages.Then we import the models and declare three functions (generateOwnerData, generateCarData, generateServiceData) which each return an array of objects with the owner, car and service data respectively.Once the Fastify.js instance is ready we use the Mongoose insertMany() function to insert the generated arrays into the database. The function then returns an array of objects containing the original object data and ids of the each record.We use the JavaScript Map function to create an array of ids owners and cars arrays. We use the ownersIDs array for when generating car data and we use the carsIds array when generating service data, they are passed into the respective functions and then values are randomly selected from them.Lastly we need to install the Faker.js package and add the seed task to our package.json file.We can add the Faker.js package by navigating to the root directory and running the following code:npm i faker -DWe then add the following to the package.json file:...\n\n\"scripts\": {\n\n...\n\n\"seed\": \"node ./src/helpers/seed.js\"\n\n},\n\n...That\u2019s it! We can now run our seeding script from the project root directory with the following code:npm run seedIf you are using MongoDB Compass (you should), you will see the data in your database:\u201cmycargarage\u201d database viewed in MongoDB CompassGraphQL installation, setup and testingLet\u2019s get started by navigating to the root directory and running the following code:npm i fastify-gql graphqlThe above installs GraphQL and the Fastify barebone GraphQL adapter.Navigate to the src directory and run the following code:mkdir schema\ncd shema\ntouch index.jsNavigate to the src directory update the index.js file with the following:// Import Server\nconst fastify = require('./server.js')\n\n// Import external dependancies\nconst gql = require('fastify-gql')\n\n// Import GraphQL Schema\nconst schema = require('./schema')\n\n// Register Fastify GraphQL\nfastify.register(gql, {\n   schema,\n   graphiql: true\n})\n\n... end here\n\n// Import Routes\nconst routes = require('./routes')With the above code we require the Fastify GraphQL Adapter, import the schema and register the GraphQl Adapter with Fastify.We register the schema and enable GraphiQL, an in-browser IDE for exploring GraphQL.Navigate to the schema directory and open the index.js file and add the following boilerplate code:// Import External Dependancies\nconst graphql = require('graphql')\n\n// Destructure GraphQL functions\nconst {\n\tGraphQLSchema,\n\tGraphQLObjectType,\n\tGraphQLString,\n\tGraphQLInt,\n\tGraphQLID,\n\tGraphQLList,\n\tGraphQLNonNull\n} = graphql\n\n// Import Controllers\nconst carController = require('../controllers/carController')\nconst ownerController = require('../controllers/ownerController')\nconst serviceController = require('../controllers/serviceController')\n\n// Define Object Types\nconst carType = new GraphQLObjectType({\n\tname: 'Car',\n\tfields: () => ({})\n})\n\nconst ownerType = new GraphQLObjectType({\n\tname: 'Owner',\n\tfields: () => ({})\n})\n\nconst serviceType = new GraphQLObjectType({\n\tname: 'Service',\n\tfields: () => ({})\n})\n\n// Define Root Query\nconst RootQuery = new GraphQLObjectType({\n\tname: 'RootQueryType',\n\tfields: {\n\t\tcar: {},\n\t\tcars: {},\n\t\towner: {},\n\t\tservice: {}\n\t}\n})\n\n// Define Mutations\nconst Mutations = new GraphQLObjectType({\n\tname: 'Mutations',\n\tfields: {\n\t\taddCar: {\n\t\t\ttype: carType,\n\t\t\targs: {},\n\t\t\tasync resolve(args) {\n\t\t\t\treturn ''\n\t\t\t}\n\t\t},\n\t\teditCar: {\n\t\t\ttype: carType,\n\t\t\targs: {},\n\t\t\tasync resolve(args) {\n\t\t\t\treturn ''\n\t\t\t}\n\t\t},\n\t\tdeleteCar: {\n\t\t\ttype: carType,\n\t\t\targs: {},\n\t\t\tasync resolve(args) {\n\t\t\t\treturn ''\n\t\t\t}\n\t\t}\n\t}\n})\n\n// Export the schema\nmodule.exports = new GraphQLSchema({\n\tquery: RootQuery,\n\tmutation: Mutations\n})index.jsLet\u2019s run through the above code:We require the main GraphQL package and use JavaScript Destructuring to get the necessary GraphQL functions(GraphQLSchema, GraphQLObjectType, GraphQLString, GraphQLInt, GraphQLID, GraphQLList and GraphQLNonNull).We import our three controllers (carController, ownerController and serviceController).We declare the carType, ownerType and serviceType GraphQL Object Types, which are functions that accept an object as a parameter, with a name and a fields key.These functions are used to define our GraphQL schema, similar to the Mongoose models defined earlier.The fields can return a particular type, and methods that take arguments. Learn More about Object Types.Then we declare the RootQuery which is also a GraphQL Object Type and is found at the top level of every GraphQL server. It represents all of the possible entry points into the GraphQL API. Learn More about root fields and resolvers.We then declare our Mutations, which are used to change data. Although any query could be implemented to change data, operations that cause changes should be sent explicitly via a mutation. Learn More about Mutations.Lastly we export the GraphQLSchema.Now that we have our template setup we can start populating the Object Types, Root Query and Mutations.Note that there are Mongoose to GraphQL schema generators available, but for the tutorial purposes we will manually create the schema.Let\u2019s update the carType Object Type as follows:const carType = new GraphQLObjectType({\n\tname: 'Car',\n\tfields: () => ({\n\t\t_id: { type: GraphQLID },\n\t\ttitle: { type: GraphQLString },\n\t\tbrand: { type: GraphQLString },\n\t\tprice: { type: GraphQLString },\n\t\tage: { type: GraphQLInt },\n\t\towner_id: { type: GraphQLID },\n\t\towner: {\n\t\t\ttype: ownerType,\n\t\t\tasync resolve(parent, args) {\n\t\t\t\treturn await ownerController.getSingleOwner({ id: parent.owner_id })\n\t\t\t}\n\t\t},\n\t\tservices: {\n\t\t\ttype: new GraphQLList(serviceType),\n\t\t\tasync resolve(parent, args) {\n\t\t\t\treturn await serviceController.getCarsServices({ id: parent._id })\n\t\t\t}\n\t\t}\n\t})\n})carType Object TypeLet\u2019s dive deeper into the GraphQL functions, starting with the Scalars types in GraphQL:GraphQL comes with a set of default scalar types out of the box:Int: A signed 32\u2010bit integer. GraphQLIntFloat: A signed double-precision floating-point value. GraphQLFloatString: A UTF\u20108 character sequence. GraphQLStringBoolean: true or false. GraphQLBooleanID: The ID scalar type represents a unique identifier, often used to refetch an object or as the key for a cache. The ID type is serialised in the same way as a String; however, defining it as an ID signifies that it is not intended to be human\u2010readable. GraphQLIDThe owner and service fields are where it gets interesting. These fields are not defined as Scalar types like the rest \u2014 instead, their type is referencing the ownerType and serviceType that we have created and are yet to populate.The second argument that we pass into the owner and service fields are resolver functions.Resolver functions or methods are functions that resolves a value for a type or field in a schemaResolvers can be asynchronous too! They can resolve values from another REST API, database, cache, constant, etc.You can think of each field in a GraphQL query as a function or method of the previous type which returns the next type. In fact, this is exactly how GraphQL works. Each field on each type is backed by a function called the resolver which is provided by the GraphQL server developer. When a field is executed, the corresponding resolver is called to produce the next value.If a field produces a scalar value like a string or number, then the execution completes. However if a field produces an object value then the query will contain another selection of fields which apply to that object. This continues until scalar values are reached. GraphQL queries always end at scalar values.In order to create the relationship between the different types we pass the _id and the owner_id values into the respective controller functions.So essentially we are requesting the owner details along with the car details:return await userController.getSingleOwner({ id: parent.owner_id })and the details of all the services related to the car:return await serviceController.getCarsServices({ id: parent._id })To return a list or array from with GraphQL, we use the GraphQLList. Here is a great in depth tutorial about using arrays in GraphQL Schema, but it is really simple: whenever we need an array we will use the GraphQLList function.Let\u2019s update the ownerType and serviceType with the following code:ownerTypeconst ownerType = new GraphQLObjectType({\n\tname: 'Owner',\n\tfields: () => ({\n\t\t_id: { type: GraphQLID },\n\t\tfirstName: { type: GraphQLString },\n\t\tlastName: { type: GraphQLString },\n\t\temail: { type: GraphQLString },\n\t\tcars: {\n\t\t\ttype: new GraphQLList(carType),\n\t\t\tasync resolve(parent, args) {\n\t\t\t\treturn await ownerController.getOwnersCars({ id: parent._id })\n\t\t\t}\n\t\t}\n\t})\n})ownerType Object TypeserviceTypeconst serviceType = new GraphQLObjectType({\n\tname: 'Service',\n\tfields: () => ({\n\t\t_id: { type: GraphQLID },\n\t\tcar_id: { type: GraphQLID },\n\t\tname: { type: GraphQLString },\n\t\tdate: { type: GraphQLString },\n\t\tcar: {\n\t\t\ttype: carType,\n\t\t\tasync resolve(parent, args) {\n\t\t\t\treturn await carController.getSingleCar({ id: parent.car_id })\n\t\t\t}\n\t\t}\n\t})\n})serviceType Object TypeThe above two Object Types are very similar to the carType. You can notice a pattern between the different Object Types and their relationships.We can now populate the RootQuery root with the following code:const RootQuery = new GraphQLObjectType({\n\tname: 'RootQueryType',\n\tfields: {\n\t\tcar: {\n\t\t\ttype: carType,\n\t\t\targs: { id: { type: GraphQLID } },\n\t\t\tasync resolve(parent, args) {\n\t\t\t\treturn await carController.getSingleCar(args)\n\t\t\t}\n\t\t},\n\t\tcars: {\n\t\t\ttype: new GraphQLList(carType),\n\t\t\tasync resolve(parent, args) {\n\t\t\t\treturn await carController.getCars()\n\t\t\t}\n\t\t},\n\t\towner: {\n\t\t\ttype: ownerType,\n\t\t\targs: { id: { type: GraphQLID } },\n\t\t\tasync resolve(parent, args) {\n\t\t\t\treturn await ownerController.getSingleOwner(args)\n\t\t\t}\n\t\t},\n\t\tservice: {\n\t\t\ttype: serviceType,\n\t\t\targs: { id: { type: GraphQLID } },\n\t\t\tasync resolve(parent, args) {\n\t\t\t\treturn await serviceController.getSingleService(args)\n\t\t\t}\n\t\t}\n\t}\n})rootQuery Object TypeThere are no new concepts in the above code, but keep in mind that the RootQuery query is the entry point to all queries on the GraphQL API. So from the above we can see that we can run the following queries directly:Get all the CarsGet a single CarGet a single OwnerGet a single ServiceLet\u2019s open the GraphiQL user interface and build some queries: http://localhost:3000/graphiql.htmlQueries are entered on the left, results are in the middle, and the documentation explorer is on the right.The documentation explorer can be used to explore the entire graph down to Scalar level. This is very helpful when building queries.The language used to build the queries resembles JSON. This cheat sheet is a great a reference.Below demonstrates why GraphQL is so awesome:GraphiQL IDEIn the above example, we are using the cars root query to display a list of all the cars, their owners, and their services.Get a single car \u2014 car root queryGet a single owner \u2014 owner root queryGet a single service \u2014 service root queryWe have one final topic to address, and that is mutations. Let\u2019s update the mutations with the following code:const Mutations = new GraphQLObjectType({\n\tname: 'Mutations',\n\tfields: {\n\t\taddCar: {\n\t\t\ttype: carType,\n\t\t\targs: {\n\t\t\t\ttitle: { type: new GraphQLNonNull(GraphQLString) },\n\t\t\t\tbrand: { type: new GraphQLNonNull(GraphQLString) },\n\t\t\t\tprice: { type: GraphQLString },\n\t\t\t\tage: { type: GraphQLInt },\n\t\t\t\towner_id: { type: GraphQLID }\n\t\t\t},\n\t\t\tasync resolve(parent, args) {\n\t\t\t\tconst data = await carController.addCar(args)\n\t\t\t\treturn data\n\t\t\t}\n\t\t},\n\t\teditCar: {\n\t\t\ttype: carType,\n\t\t\targs: {\n\t\t\t\tid: { type: new GraphQLNonNull(GraphQLID) },\n\t\t\t\ttitle: { type: new GraphQLNonNull(GraphQLString) },\n\t\t\t\tbrand: { type: new GraphQLNonNull(GraphQLString) },\n\t\t\t\tprice: { type: new GraphQLNonNull(GraphQLString) },\n\t\t\t\tage: { type: new GraphQLNonNull(GraphQLInt) },\n\t\t\t\towner_id: { type: GraphQLID }\n\t\t\t},\n\t\t\tasync resolve(parent, args) {\n\t\t\t\tconst data = await carController.updateCar(args)\n\t\t\t\treturn data\n\t\t\t}\n\t\t},\n\t\tdeleteCar: {\n\t\t\ttype: carType,\n\t\t\targs: {\n\t\t\t\tid: { type: new GraphQLNonNull(GraphQLID) }\n\t\t\t},\n\t\t\tasync resolve(parent, args) {\n\t\t\t\tconst data = await carController.deleteCar(args)\n\t\t\t\treturn data\n\t\t\t}\n\t\t}\n\t}\n})mutationsAs before, we declare our Object Type, specify the name and the fields.A mutation consists of the the type, args and the async resolve function. The resolve function passes the args to the controller, which returns the result of the mutation.addCar MutationeditCar MutationdeleteCar MutationYou have now coded a fully functional REST API and a fully functional GraphQL API.There are no rules stating that one should use exclusively REST or exclusively GraphQL. In some projects, the best solution may be a mix of both. This is really determined on a project-to-project basis.You can download the source code form Git here.What is Next?In the next tutorial, we will consume our GraphQL API with a Vue.js frontend as a single page application!\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 26290, "excerpt": "This tutorial is part two of a four part series, which aims to take you from\nscratch to deploying a fully functional full stack application.\n\n * Part 1: How to build blazing fast REST APIs with Node.js, MongoDB, Fastify\n   and Swagger\n * Part 2: How to build a blazing fast GraphQL API with Node.js, MongoDB,\n   Fastify and GraphQL! (You are here.)\n * Part 3: Coupling Vue.js with a GraphQL API.\n * Part 4: Deploying a GraphQL API and Vue.js frontend application.\n\nThe first part of the series is ava", "siteName": "freeCodeCamp.org", "publishedTime": "2019-05-23T15:47:45.000Z", "id": "956be94f717b74bb7fa28c046e17c465bd5cb959", "url": "https://www.freecodecamp.org/news/how-to-build-a-blazing-fast-graphql-api-with-node-js-mongodb-and-fastify-77fd5acd2998/", "domain": "freecodecamp.org", "date": "2023-12-27T18:09:21.202035", "resultUri": "http://localhost:3000/result/956be94f717b74bb7fa28c046e17c465bd5cb959", "query": {"url": ["https://www.freecodecamp.org/news/how-to-build-a-blazing-fast-graphql-api-with-node-js-mongodb-and-fastify-77fd5acd2998/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "How to build a blazing fast GraphQL API with Node.js, MongoDB and Fastify", "description": "This tutorial is part two of a four part series, which aims to take you from scratch to deploying a fully functional full stack application.  * Part 1: How to build blazing fast REST APIs with Node.js, MongoDB, Fastify    and Swagger  * Part 2: How", "url": "https://www.freecodecamp.org/news/how-to-build-a-blazing-fast-graphql-api-with-node-js-mongodb-and-fastify-77fd5acd2998/", "image": "https://cdn-media-1.freecodecamp.org/images/1*vUgaEEzxSp2YWsJ7p7jgjA.png", "image:width": "800", "image:height": "360"}, "twitter": {"card": "summary_large_image", "title": "How to build a blazing fast GraphQL API with Node.js, MongoDB and Fastify", "description": "This tutorial is part two of a four part series, which aims to take you from scratch to deploying a fully functional full stack application.  * Part 1: How to build blazing fast REST APIs with Node.js, MongoDB, Fastify    and Swagger  * Part 2: How", "url": "https://www.freecodecamp.org/news/how-to-build-a-blazing-fast-graphql-api-with-node-js-mongodb-and-fastify-77fd5acd2998/", "image": "https://cdn-media-1.freecodecamp.org/images/1*vUgaEEzxSp2YWsJ7p7jgjA.png", "label1": "Written by", "data1": "Siegfried Grimbeek", "label2": "Filed under", "data2": "GraphQL, JavaScript, Nodejs, Tech, Programming", "site": "@freecodecamp"}}}