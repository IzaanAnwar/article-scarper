{"title": "How to Add a MetaMask Login to Your Laravel Web Application", "byline": "Darren Chowles", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>How to Add a MetaMask Login to Your Laravel Web Application</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>Logging into a website via third parties is ubiquitous online. Almost every other member-based website allows you to log in with accounts like Facebook, Twitter, and Google.</p><p>If you\u2019ve ever visited NFT marketplaces like OpenSea or Rarible, you would have noticed they allow you to sign in with a crypto wallet like MetaMask. </p><p>This login process affirms you\u2019re the owner of the Ethereum address in question and allows the system to authenticate your access. Very similar to how a username and password would allow you access to a gated part of a website.</p><h2 id=\"prerequisites\">Prerequisites</h2><p>Before starting this tutorial, I\u2019ll assume you have a basic understanding of Laravel, and that you can initialise a new project in your environment. Even though this tutorial is Laravel-focused, with some tweaking you can apply this to any other PHP project. The concepts remain the same.</p><p>I\u2019ve tried to keep this as generic as possible. I only focus on the MetaMask signing and validation, without restricting you to using it with specific front-end technologies (like React or Vue) or authentication scaffolding (like Breeze or Jetstream). This gives you the freedom to implement it with minimal effort into an existing project.</p><p>We\u2019ll need the following before we start:</p><ul><li>A new or existing Laravel project.</li><li><a href=\"https://metamask.io/\">MetaMask</a> installed in your browser.</li></ul><h2 id=\"boilerplate\">Boilerplate</h2><p>We\u2019ll start out with some boilerplate code by importing <a href=\"https://getbootstrap.com/\">Bootstrap 5</a> and creating a simple \u201cLog in with MetaMask\u201d button.</p><figure><img alt=\"image-1-2\" height=\"74\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2022/03/image-1-2.png\" width=\"293\"/></figure><pre tabindex=\"0\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;title&gt;MetaMask Login&lt;/title&gt;\n    &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3\" crossorigin=\"anonymous\"&gt;\n    &lt;script src=\"https://cdn.ethers.io/lib/ethers-5.2.umd.min.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=\"container\"&gt;\n    &lt;div class=\"row\"&gt;\n        &lt;div class=\"col-12 text-center\"&gt;\n            &lt;button class=\"btn btn-primary mt-5\"&gt;Log in with MetaMask&lt;/button&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>Easy enough. \ud83d\ude00</p><p>We\u2019re also importing the <a href=\"https://docs.ethers.io/\">ethers.js library</a> that will allow us to interact with the Ethereum blockchain via MetaMask, which in this case acts as the interface to the provider (<a href=\"https://infura.io/\">Infura</a> by default).</p><h3 id=\"quick-tip-\">Quick tip:</h3><p>Providers allow us to interact with the Ethereum blockchain. To connect to the network, you need access to a node. Depending on the type of node, it could require a large amount of disk space and bandwidth. Running a node can also be a complex process, especially if you want to focus on development rather than maintaining and operating a node. </p><p>Enter, the provider! Companies like Infura provide these nodes as a service, so you don\u2019t need to worry about running your own. Instead, you can access this functionality via their APIs.</p><p>You may run into older tutorials that state MetaMask injects web3.js (a library providing similar functionality to ethers.js) into the page by default. This is <a href=\"https://docs.metamask.io/guide/provider-migration.html#summary-of-breaking-changes\">no longer the case</a>.</p><h2 id=\"detect-the-provider\">Detect the Provider</h2><p>We\u2019ll start off our new <code>web3Login()</code> function by checking that the browser has a provider available. This would be the case if you have MetaMask installed. You can also test this code where MetaMask is not installed (for example, an incognito window) to confirm the detection works.</p><p>Add the click event to the button:</p><pre tabindex=\"0\"><code>&lt;button class=\"btn btn-primary mt-5\" onclick=\"web3Login();\"&gt;Log in with MetaMask&lt;/button&gt;</code></pre><p>And start off the function with our detection snippet in our <code>&lt;head&gt;</code> below the ethers.js import:</p><pre tabindex=\"0\"><code>&lt;script&gt;\n    async function web3Login() {\n        if (!window.ethereum) {\n            alert('MetaMask not detected. Please install MetaMask first.');\n            return;\n        }\n    }\n&lt;/script&gt;</code></pre><p>Go ahead and test this in a browser with no MetaMask installed.</p><figure><img alt=\"image-2-2\" height=\"133\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2022/03/image-2-2.png\" width=\"461\"/></figure><h2 id=\"install-laravel-dependencies\">Install Laravel Dependencies</h2><p>Before we continue with the front-end login process, we need to put some endpoints in place. Our login script will need these so the user can sign a message with their wallet, and our system can then verify their signature.</p><p>We need to install two dependencies via Composer to help us perform hashing and use elliptic curve cryptography:</p><pre tabindex=\"0\"><code>composer require kornrunner/keccak\ncomposer require simplito/elliptic-php</code></pre><h2 id=\"add-laravel-routes\">Add Laravel Routes</h2><p>Open your <strong>routes/web.php </strong>file and add the following routes:</p><pre tabindex=\"0\"><code>Route::get('/web3-login-message', 'Web3LoginController@message');\nRoute::post('/web3-login-verify', 'Web3LoginController@verify');</code></pre><p>The first route will return the message that needs to be signed, and the second route will verify the signed message.</p><h2 id=\"create-the-login-controller\">Create the Login Controller</h2><p>Now it\u2019s time to create the controller that will generate the message and perform the verification.</p><p>Create a new file called <strong>Web3LoginController.php </strong>in <strong>app/Http/Controllers</strong> and add the following code to it:</p><pre tabindex=\"0\"><code>&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse Elliptic\\EC;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Str;\nuse kornrunner\\Keccak;\n\nclass Web3LoginController\n{\n    public function message(): string\n    {\n        $nonce = Str::random();\n        $message = \"Sign this message to confirm you own this wallet address. This action will not cost any gas fees.\\n\\nNonce: \" . $nonce;\n\n        session()-&gt;put('sign_message', $message);\n\n        return $message;\n    }\n\n    public function verify(Request $request): string\n    {\n        $result = $this-&gt;verifySignature(session()-&gt;pull('sign_message'), $request-&gt;input('signature'), $request-&gt;input('address'));\n        // If $result is true, perform additional logic like logging the user in, or by creating an account if one doesn't exist based on the Ethereum address\n        return ($result ? 'OK' : 'ERROR');\n    }\n\n    protected function verifySignature(string $message, string $signature, string $address): bool\n    {\n        $hash = Keccak::hash(sprintf(\"\\x19Ethereum Signed Message:\\n%s%s\", strlen($message), $message), 256);\n        $sign = [\n            'r' =&gt; substr($signature, 2, 64),\n            's' =&gt; substr($signature, 66, 64),\n        ];\n        $recid = ord(hex2bin(substr($signature, 130, 2))) - 27;\n\n        if ($recid != ($recid &amp; 1)) {\n            return false;\n        }\n\n        $pubkey = (new EC('secp256k1'))-&gt;recoverPubKey($hash, $sign, $recid);\n        $derived_address = '0x' . substr(Keccak::hash(substr(hex2bin($pubkey-&gt;encode('hex')), 1), 256), 24);\n\n        return (Str::lower($address) === $derived_address);\n    }\n}\n</code></pre><p>There\u2019s a lot going on in there, so let\u2019s break it down:</p><h3 id=\"create-the-message\">Create the message</h3><p>The <code>message()</code> method creates the message we\u2019ll supply to the front end. It also includes a random token to ensure the message to sign will be different each time.</p><p>This token is usually referred to as a nonce, or number used once. In this case, however, it\u2019s a simple random string. </p><p>The purpose of this is to prevent <a href=\"https://en.wikipedia.org/wiki/Replay_attack\">replay attacks</a> where, if a malicious user obtained your signature, they could use that to authenticate as you on the website.</p><p>The message is then saved to the session and returned to the front end.</p><h3 id=\"verify-the-message\">Verify the message</h3><p>Once you have signed the message with your private key via MetaMask, your Ethereum address as well as the signature is sent to the back end for verification.</p><p>If it passes the verification, we determine the Ethereum address that signed the message and ensure it matches the Ethereum address sent from the front end during the signing process.</p><p>If that passes, we send an <strong>OK </strong>or <strong>ERROR</strong> back to the front end.</p><p>It\u2019s also at this point where you can add additional logic like logging the member in or creating a new member record if one doesn\u2019t exist for the Ethereum address in question.</p><figure><img alt=\"Laravel-Metamask\" height=\"280\" loading=\"lazy\" sizes=\"(min-width: 720px) 720px\" src=\"https://www.freecodecamp.org/news/content/images/2022/03/Laravel-Metamask.png\" srcset=\"https://www.freecodecamp.org/news/content/images/size/w600/2022/03/Laravel-Metamask.png 600w, https://www.freecodecamp.org/news/content/images/2022/03/Laravel-Metamask.png 880w\" width=\"880\"/></figure><h2 id=\"finalise-the-front-end\">Finalise the Front End</h2><p>Now that the backend is ready, we can complete the rest of the front end. This will involve launching MetaMask, asking the user to sign the message, and then verifying the signature by using our back-end route.</p><p>Below is the full <code>web3Login()</code> function:</p><pre tabindex=\"0\"><code>&lt;script&gt;\n    async function web3Login() {\n        if (!window.ethereum) {\n            alert('MetaMask not detected. Please install MetaMask first.');\n            return;\n        }\n\n        const provider = new ethers.providers.Web3Provider(window.ethereum);\n\n        let response = await fetch('/web3-login-message');\n        const message = await response.text();\n\n        await provider.send(\"eth_requestAccounts\", []);\n        const address = await provider.getSigner().getAddress();\n        const signature = await provider.getSigner().signMessage(message);\n\n        response = await fetch('/web3-login-verify', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                'address': address,\n                'signature': signature,\n                '_token': '{{ csrf_token() }}'\n            })\n        });\n        const data = await response.text();\n\n        console.log(data);\n    }\n&lt;/script&gt;\n</code></pre><p>Let\u2019s break it down:</p><ul><li>We first set the provider to the MetaMask provided <code>window.ethereum</code>.</li><li>Next, we grab the message returned from our back end (refresh the page a few times to try this out, you will notice the random token changes every time).</li><li>Once we have the message, we obtain the user\u2019s Ethereum address and ask them to sign the message.</li></ul><figure><img alt=\"image-3-2\" height=\"687\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2022/03/image-3-2.png\" width=\"420\"/></figure><ul><li>We then POST the address and signature to the back end (along with our Laravel CRSF token) for verification.</li><li>The result is either an <strong>OK</strong> or <strong>ERROR </strong>string which we output in the console.</li><li>At this point you may elect to show an error message (if applicable) or redirect the user if they were registered or logged in during the back-end verification.</li></ul><h2 id=\"conclusion\">Conclusion</h2><p>In this tutorial we covered the basics of adding a MetaMask login to your website. I hope this has proven useful! <a href=\"https://webdev.chowles.com/\">Sign up to my newsletter</a> or <a href=\"https://www.chowles.com/\">visit my blog</a> where I\u2019ll share insightful web development articles to supercharge your skills.</p><p>Here are some ideas to take your integration one step further:</p><ul><li>Integrate a library like <a href=\"https://github.com/web3modal/web3modal\">Web3Modal</a> to provide users with various wallet options instead of only MetaMask.</li><li>With the user\u2019s Ethereum address validated, provide them with functions like displaying their ETH balance.</li></ul><h3 id=\"resources\">Resources</h3><ul><li>Download <a href=\"https://metamask.io/\">MetaMask</a>.</li><li>View the <a href=\"https://docs.ethers.io/\">ethers.js documentation</a>.</li><li>Latest <a href=\"https://laravel.com/docs\">Laravel documentation</a>.</li></ul>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nLogging into a website via third parties is ubiquitous online. Almost every other member-based website allows you to log in with accounts like Facebook, Twitter, and Google.If you\u2019ve ever visited NFT marketplaces like OpenSea or Rarible, you would have noticed they allow you to sign in with a crypto wallet like MetaMask. This login process affirms you\u2019re the owner of the Ethereum address in question and allows the system to authenticate your access. Very similar to how a username and password would allow you access to a gated part of a website.PrerequisitesBefore starting this tutorial, I\u2019ll assume you have a basic understanding of Laravel, and that you can initialise a new project in your environment. Even though this tutorial is Laravel-focused, with some tweaking you can apply this to any other PHP project. The concepts remain the same.I\u2019ve tried to keep this as generic as possible. I only focus on the MetaMask signing and validation, without restricting you to using it with specific front-end technologies (like React or Vue) or authentication scaffolding (like Breeze or Jetstream). This gives you the freedom to implement it with minimal effort into an existing project.We\u2019ll need the following before we start:A new or existing Laravel project.MetaMask installed in your browser.BoilerplateWe\u2019ll start out with some boilerplate code by importing Bootstrap 5 and creating a simple \u201cLog in with MetaMask\u201d button.<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>MetaMask Login</title>\n    <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3\" crossorigin=\"anonymous\">\n    <script src=\"https://cdn.ethers.io/lib/ethers-5.2.umd.min.js\"></script>\n</head>\n<body>\n<div class=\"container\">\n    <div class=\"row\">\n        <div class=\"col-12 text-center\">\n            <button class=\"btn btn-primary mt-5\">Log in with MetaMask</button>\n        </div>\n    </div>\n</div>\n</body>\n</html>Easy enough. \ud83d\ude00We\u2019re also importing the ethers.js library that will allow us to interact with the Ethereum blockchain via MetaMask, which in this case acts as the interface to the provider (Infura by default).Quick tip:Providers allow us to interact with the Ethereum blockchain. To connect to the network, you need access to a node. Depending on the type of node, it could require a large amount of disk space and bandwidth. Running a node can also be a complex process, especially if you want to focus on development rather than maintaining and operating a node. Enter, the provider! Companies like Infura provide these nodes as a service, so you don\u2019t need to worry about running your own. Instead, you can access this functionality via their APIs.You may run into older tutorials that state MetaMask injects web3.js (a library providing similar functionality to ethers.js) into the page by default. This is no longer the case.Detect the ProviderWe\u2019ll start off our new web3Login() function by checking that the browser has a provider available. This would be the case if you have MetaMask installed. You can also test this code where MetaMask is not installed (for example, an incognito window) to confirm the detection works.Add the click event to the button:<button class=\"btn btn-primary mt-5\" onclick=\"web3Login();\">Log in with MetaMask</button>And start off the function with our detection snippet in our <head> below the ethers.js import:<script>\n    async function web3Login() {\n        if (!window.ethereum) {\n            alert('MetaMask not detected. Please install MetaMask first.');\n            return;\n        }\n    }\n</script>Go ahead and test this in a browser with no MetaMask installed.Install Laravel DependenciesBefore we continue with the front-end login process, we need to put some endpoints in place. Our login script will need these so the user can sign a message with their wallet, and our system can then verify their signature.We need to install two dependencies via Composer to help us perform hashing and use elliptic curve cryptography:composer require kornrunner/keccak\ncomposer require simplito/elliptic-phpAdd Laravel RoutesOpen your routes/web.php file and add the following routes:Route::get('/web3-login-message', 'Web3LoginController@message');\nRoute::post('/web3-login-verify', 'Web3LoginController@verify');The first route will return the message that needs to be signed, and the second route will verify the signed message.Create the Login ControllerNow it\u2019s time to create the controller that will generate the message and perform the verification.Create a new file called Web3LoginController.php in app/Http/Controllers and add the following code to it:<?php\n\nnamespace App\\Http\\Controllers;\n\nuse Elliptic\\EC;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Str;\nuse kornrunner\\Keccak;\n\nclass Web3LoginController\n{\n    public function message(): string\n    {\n        $nonce = Str::random();\n        $message = \"Sign this message to confirm you own this wallet address. This action will not cost any gas fees.\\n\\nNonce: \" . $nonce;\n\n        session()->put('sign_message', $message);\n\n        return $message;\n    }\n\n    public function verify(Request $request): string\n    {\n        $result = $this->verifySignature(session()->pull('sign_message'), $request->input('signature'), $request->input('address'));\n        // If $result is true, perform additional logic like logging the user in, or by creating an account if one doesn't exist based on the Ethereum address\n        return ($result ? 'OK' : 'ERROR');\n    }\n\n    protected function verifySignature(string $message, string $signature, string $address): bool\n    {\n        $hash = Keccak::hash(sprintf(\"\\x19Ethereum Signed Message:\\n%s%s\", strlen($message), $message), 256);\n        $sign = [\n            'r' => substr($signature, 2, 64),\n            's' => substr($signature, 66, 64),\n        ];\n        $recid = ord(hex2bin(substr($signature, 130, 2))) - 27;\n\n        if ($recid != ($recid & 1)) {\n            return false;\n        }\n\n        $pubkey = (new EC('secp256k1'))->recoverPubKey($hash, $sign, $recid);\n        $derived_address = '0x' . substr(Keccak::hash(substr(hex2bin($pubkey->encode('hex')), 1), 256), 24);\n\n        return (Str::lower($address) === $derived_address);\n    }\n}\nThere\u2019s a lot going on in there, so let\u2019s break it down:Create the messageThe message() method creates the message we\u2019ll supply to the front end. It also includes a random token to ensure the message to sign will be different each time.This token is usually referred to as a nonce, or number used once. In this case, however, it\u2019s a simple random string. The purpose of this is to prevent replay attacks where, if a malicious user obtained your signature, they could use that to authenticate as you on the website.The message is then saved to the session and returned to the front end.Verify the messageOnce you have signed the message with your private key via MetaMask, your Ethereum address as well as the signature is sent to the back end for verification.If it passes the verification, we determine the Ethereum address that signed the message and ensure it matches the Ethereum address sent from the front end during the signing process.If that passes, we send an OK or ERROR back to the front end.It\u2019s also at this point where you can add additional logic like logging the member in or creating a new member record if one doesn\u2019t exist for the Ethereum address in question.Finalise the Front EndNow that the backend is ready, we can complete the rest of the front end. This will involve launching MetaMask, asking the user to sign the message, and then verifying the signature by using our back-end route.Below is the full web3Login() function:<script>\n    async function web3Login() {\n        if (!window.ethereum) {\n            alert('MetaMask not detected. Please install MetaMask first.');\n            return;\n        }\n\n        const provider = new ethers.providers.Web3Provider(window.ethereum);\n\n        let response = await fetch('/web3-login-message');\n        const message = await response.text();\n\n        await provider.send(\"eth_requestAccounts\", []);\n        const address = await provider.getSigner().getAddress();\n        const signature = await provider.getSigner().signMessage(message);\n\n        response = await fetch('/web3-login-verify', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                'address': address,\n                'signature': signature,\n                '_token': '{{ csrf_token() }}'\n            })\n        });\n        const data = await response.text();\n\n        console.log(data);\n    }\n</script>\nLet\u2019s break it down:We first set the provider to the MetaMask provided window.ethereum.Next, we grab the message returned from our back end (refresh the page a few times to try this out, you will notice the random token changes every time).Once we have the message, we obtain the user\u2019s Ethereum address and ask them to sign the message.We then POST the address and signature to the back end (along with our Laravel CRSF token) for verification.The result is either an OK or ERROR string which we output in the console.At this point you may elect to show an error message (if applicable) or redirect the user if they were registered or logged in during the back-end verification.ConclusionIn this tutorial we covered the basics of adding a MetaMask login to your website. I hope this has proven useful! Sign up to my newsletter or visit my blog where I\u2019ll share insightful web development articles to supercharge your skills.Here are some ideas to take your integration one step further:Integrate a library like Web3Modal to provide users with various wallet options instead of only MetaMask.With the user\u2019s Ethereum address validated, provide them with functions like displaying their ETH balance.ResourcesDownload MetaMask.View the ethers.js documentation.Latest Laravel documentation.\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 10857, "excerpt": "Logging into a website via third parties is ubiquitous online. Almost every\nother member-based website allows you to log in with accounts like Facebook,\nTwitter, and Google.\n\nIf you\u2019ve ever visited NFT marketplaces like OpenSea or Rarible, you would have\nnoticed they allow you to sign in with a crypto wallet like MetaMask. \n\nThis login process affirms you\u2019re the owner of the Ethereum address in question\nand allows the system to authenticate your access. Very similar to how a\nusername and passwor", "siteName": "freeCodeCamp.org", "publishedTime": "2022-03-23T18:38:03.000Z", "id": "0b7dae2f01e81136b021d6309c6966a12fe03704", "url": "https://www.freecodecamp.org/news/add-a-metamask-login-to-your-laravel-app/", "domain": "freecodecamp.org", "date": "2023-12-27T18:05:33.093922", "resultUri": "http://localhost:3000/result/0b7dae2f01e81136b021d6309c6966a12fe03704", "query": {"url": ["https://www.freecodecamp.org/news/add-a-metamask-login-to-your-laravel-app/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "How to Add a MetaMask Login to Your Laravel Web Application", "description": "Logging into a website via third parties is ubiquitous online. Almost every other member-based website allows you to log in with accounts like Facebook, Twitter, and Google. If you\u2019ve ever visited NFT marketplaces like OpenSea or Rarible, you would have noticed they allow you to sign in with a crypto", "url": "https://www.freecodecamp.org/news/add-a-metamask-login-to-your-laravel-app/", "image": "https://www.freecodecamp.org/news/content/images/2022/03/photo.png", "image:width": "1280", "image:height": "720"}, "twitter": {"card": "summary_large_image", "title": "How to Add a MetaMask Login to Your Laravel Web Application", "description": "Logging into a website via third parties is ubiquitous online. Almost every other member-based website allows you to log in with accounts like Facebook, Twitter, and Google. If you\u2019ve ever visited NFT marketplaces like OpenSea or Rarible, you would have noticed they allow you to sign in with a crypto", "url": "https://www.freecodecamp.org/news/add-a-metamask-login-to-your-laravel-app/", "image": "https://www.freecodecamp.org/news/content/images/2022/03/photo.png", "label1": "Written by", "data1": "Darren Chowles", "label2": "Filed under", "data2": "Laravel, Web3, PHP, metamask, Programming", "site": "@freecodecamp", "creator": "@chimeratheory"}}}