{"title": "So you\u2019re in if/else hell\u200a\u2014\u200ahere\u2019s how to get out of it", "byline": "Adeel Imran", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>So you\u2019re in if/else hell\u200a\u2014\u200ahere\u2019s how to get out of it</h1>\n<section>\n<section data-test-label=\"post-content\">\n<figure><img alt=\"image-245\" height=\"720\" loading=\"lazy\" sizes=\"(min-width: 720px) 720px\" src=\"https://www.freecodecamp.org/news/content/images/2021/04/image-245.png\" srcset=\"https://www.freecodecamp.org/news/content/images/size/w600/2021/04/image-245.png 600w, https://www.freecodecamp.org/news/content/images/size/w1000/2021/04/image-245.png 1000w, https://www.freecodecamp.org/news/content/images/2021/04/image-245.png 1080w\" width=\"1080\"/><figcaption>Photo by <a href=\"https://unsplash.com/@markusspiske?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit\">Markus Spiske</a> / <a href=\"https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit\">Unsplash</a></figcaption></figure><h3 id=\"what-is-this-topic-about\">What is this topic about?</h3><p>If you are from a <code>javascript</code> background you might have heard the terms <code>callback hell</code> or <code>async/await hell</code>. It looks something like this:</p><figure><img alt=\"1*13tInwUptNwGlHemJrxTig\" height=\"520\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1*13tInwUptNwGlHemJrxTig.png\" width=\"657\"/><figcaption>The horror.</figcaption></figure><p>There is a similar situation with just using <code>if/else</code> as well. You might label this as developers being obsessive, or ignore it by thinking that this is kind of okay in some situations.</p><p>I beg to differ. As the saying goes\u2026just pretend that whoever maintains your code next knows where you work and can come yell at you.</p><p>For the purpose of this article, I\u2019ll demonstrate an example using ReactJS. The principle itself can be applied in Javascript or any language for that matter.</p><p><strong>Before we begin</strong>, the <code><em>&lt;MyButton</em></code> /&gt; example may not be the best example to explain the if/else nested problem. But hopefully it\u2019ll give you a good guideline as to what the problem is &amp; how to avoid it.</p><p>Let\u2019s paint a picture. You are given a button to implement in <code>React</code> &amp; the button has 2 options for a theme, either <code>default</code> or <code>primary</code>. You think it\u2019s simple &amp; you write your <code>&lt;MyButton</code> /&gt; component:</p><figure><pre tabindex=\"0\"><code>const MyButton = ({ theme, content }) =&gt; {\n  let className = '';                \n  if (theme === 'default') {\n    className = 'default-btn';\n  } else if (theme === 'primary') {\n    className = 'primary-btn';\n  }\n                   \n  return (\n    &lt;button className={className}&gt;{content}&lt;/button&gt;\n  );\n}</code></pre><figcaption>MyButton.1.jsx</figcaption></figure><p>Some time passes &amp; another developer is given a task to add functionality for round corners for the button for both themes, default &amp; primary. The developer who picks up the tasks is very big on using ternary operators. They end up doing something like below:</p><figure><pre tabindex=\"0\"><code>const MyButton = ({ theme, rounded, content }) =&gt; {\n  let className = '';                \n  if (theme === 'default') {\n    className = rounded ? 'default-btn rounded' : 'default-btn';\n  } else if (theme === 'primary') {\n    className = rounded ? 'primary-btn rounded' : 'primary-btn';\n  }\n                   \n  return (\n    &lt;button className={className}&gt;{content}&lt;/button&gt;\n  );\n}</code></pre><figcaption>MyButton.2.jsx</figcaption></figure><p>Time passes &amp; another developer is given a task to add a <code>hover</code> state for both the <code>default</code> &amp; <code>primary</code> buttons. Now the other developer does not want to make changes in the already code implemented, fearing they might end up breaking something.</p><p>So they write a separate if statement:</p><figure><pre tabindex=\"0\"><code>const MyButton = ({ theme, rounded, hover, content }) =&gt; {\n  let className = '';                \n  if (theme === 'default') {\n    className = rounded ? 'default-btn rounded' : 'default-btn';\n  } else if (theme === 'primary') {\n    className = rounded ? 'primary-btn rounded' : 'primary-btn';\n  }\n  \n  if (hover) {\n    className = className + ' hover';\n  }\n                   \n  return (\n    &lt;button className={className}&gt;{content}&lt;/button&gt;\n  );\n}</code></pre><figcaption>MyButton.3.jsx</figcaption></figure><p>So far so good \u2026</p><h4 id=\"this-is-where-it-gets-interesting\">This is where it gets interesting</h4><p>Moving on, a final requirement comes in months later to add an animation when the user <strong>hovers </strong>over a button which has a <strong>primary </strong>theme &amp; is of <strong>rounded </strong>type.</p><p>Now based on this requirement, the entire API structure changes the <code>&lt;MyButto</code>n/&gt; component. The developer working on the code ends up with logic like this:</p><figure><pre tabindex=\"0\"><code>const MyButton = ({ theme, rounded, hover, animation, content }) =&gt; {\n  let className = '';                \n  if (theme === 'default') {\n    className = rounded ? 'default-btn rounded' : 'default-btn';\n    if (hover) {\n      className = className + ' hover';\n    }\n  } else if (theme === 'primary') {\n    if (rounded) {\n      if (hover) {\n        if (animation) {\n           className = 'primary-btn rounded hover my-custom-animation';\n        } else {\n          className = 'primary-btn rounded hover';\n        }\n      } else {\n        className = 'primary-btn rounded';\n      }\n    } else {\n      if (hover) {\n        className = 'primary-btn hover';\n      } else {\n        className = 'primary-btn';\n      }\n    }\n  }\n\n  return (\n    &lt;button className={className}&gt;{content}&lt;/button&gt;\n  );\n}</code></pre><figcaption>MyButton.4.jsx</figcaption></figure><p>That got out of hand way too quickly \u2026. didn\u2019t it?</p><figure><img alt=\"1*XwM0kI6bX9utPF0VwT20Gg\" height=\"281\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1*XwM0kI6bX9utPF0VwT20Gg.gif\" width=\"500\"/><figcaption>and you think to yourself, there was nothing you could have done :(</figcaption></figure><p>In order to make this code simpler, we need to understand all the possible states that this code has. I have made a possibility chart of all the possible combinations at a certain time for the button.</p><figure><img alt=\"1*mnWn59gP2Lwb7f3huo783A\" height=\"237\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1*mnWn59gP2Lwb7f3huo783A.png\" width=\"800\"/><figcaption>All the possible combinations of values that &lt;MyButton /&gt; component can have at a time</figcaption></figure><p>If this seems a bit complicated, you can try looking at this next chart for your understanding.</p><figure><img alt=\"1*H5yLaIar39mkoVbzwJlLlQ\" height=\"239\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/1*H5yLaIar39mkoVbzwJlLlQ.png\" width=\"800\"/><figcaption>This is the same as the previous one, the FALSE values are omitted here for simplicity sake</figcaption></figure><p><strong>The key thing when writing code is understanding the data flow of your code. Once you have a complete understanding of it, everything becomes simpler.</strong></p><h4 id=\"solution\">Solution</h4><p>Based on the above given criteria, I can write my code like this to simplify it.</p><figure><pre tabindex=\"0\"><code>const MyButton = ({ theme, rounded, hover, animation, content }) =&gt; {\n  const isThemeDefault = theme === 'default'\n  const isThemePrimary = theme === 'primary';\n  const isRounded = rounded === true;\n  const isHover = hover === true;\n  const isAnimated = animation === true;\n  \n  const isPrimaryAnimated = isThemePrimary &amp;&amp; isAnimated;\n  \n  let className = isThemePrimary ? 'primary-btn' : 'default-btn';\n\n  if (isRounded) {\n    className = `${className} rounded`;\n  }\n  if (isHover) {\n    className = `${className} hover`;\n  }\n  if (isPrimaryAnimated) {\n    className = `${className} animated`;\n  }\n \n  return (\n    &lt;button className={className}&gt;{content}&lt;/button&gt;\n  );\n}</code></pre><figcaption>MyButton.5.jsx (As a bonus feature, it also ends up handling an edge case where, if the wrong theme is passed to MyButton, it ends up ignoring it &amp; assigning it the value of default.</figcaption></figure><p>This code is now way more readable. Any developer who works on this code can easily extend its functionality &amp; get on with their life, knowing that they have done a wonderful job with the code.</p><p>You can try playing with the code if you want, to see if it matches all the use cases.</p><figure><figcaption>codesandbox demo https://codesandbox.io/s/0pl6xvqrnw</figcaption></figure><p>With the automata (finite state machines)-like coding approach:</p><ul><li>Code is more readable now</li><li>Code is more maintainable</li></ul><p>Feel free to share your thoughts. Thank you for reading.</p><p>You can also reach me out on twitter <a href=\"https://twitter.com/adeelibr\" rel=\"noopener\"><strong>@adeelibr</strong></a></p><blockquote>Reference &amp; Inspiration: <a href=\"https://softwareengineering.stackexchange.com/questions/205803/how-to-tackle-a-branched-arrow-head-anti-pattern\" rel=\"noopener\">Stack Exchange Forum</a></blockquote>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nPhoto by Markus Spiske / UnsplashWhat is this topic about?If you are from a javascript background you might have heard the terms callback hell or async/await hell. It looks something like this:The horror.There is a similar situation with just using if/else as well. You might label this as developers being obsessive, or ignore it by thinking that this is kind of okay in some situations.I beg to differ. As the saying goes\u2026just pretend that whoever maintains your code next knows where you work and can come yell at you.For the purpose of this article, I\u2019ll demonstrate an example using ReactJS. The principle itself can be applied in Javascript or any language for that matter.Before we begin, the <MyButton /> example may not be the best example to explain the if/else nested problem. But hopefully it\u2019ll give you a good guideline as to what the problem is & how to avoid it.Let\u2019s paint a picture. You are given a button to implement in React & the button has 2 options for a theme, either default or primary. You think it\u2019s simple & you write your <MyButton /> component:const MyButton = ({ theme, content }) => {\n  let className = '';                \n  if (theme === 'default') {\n    className = 'default-btn';\n  } else if (theme === 'primary') {\n    className = 'primary-btn';\n  }\n                   \n  return (\n    <button className={className}>{content}</button>\n  );\n}MyButton.1.jsxSome time passes & another developer is given a task to add functionality for round corners for the button for both themes, default & primary. The developer who picks up the tasks is very big on using ternary operators. They end up doing something like below:const MyButton = ({ theme, rounded, content }) => {\n  let className = '';                \n  if (theme === 'default') {\n    className = rounded ? 'default-btn rounded' : 'default-btn';\n  } else if (theme === 'primary') {\n    className = rounded ? 'primary-btn rounded' : 'primary-btn';\n  }\n                   \n  return (\n    <button className={className}>{content}</button>\n  );\n}MyButton.2.jsxTime passes & another developer is given a task to add a hover state for both the default & primary buttons. Now the other developer does not want to make changes in the already code implemented, fearing they might end up breaking something.So they write a separate if statement:const MyButton = ({ theme, rounded, hover, content }) => {\n  let className = '';                \n  if (theme === 'default') {\n    className = rounded ? 'default-btn rounded' : 'default-btn';\n  } else if (theme === 'primary') {\n    className = rounded ? 'primary-btn rounded' : 'primary-btn';\n  }\n  \n  if (hover) {\n    className = className + ' hover';\n  }\n                   \n  return (\n    <button className={className}>{content}</button>\n  );\n}MyButton.3.jsxSo far so good \u2026This is where it gets interestingMoving on, a final requirement comes in months later to add an animation when the user hovers over a button which has a primary theme & is of rounded type.Now based on this requirement, the entire API structure changes the <MyButton/> component. The developer working on the code ends up with logic like this:const MyButton = ({ theme, rounded, hover, animation, content }) => {\n  let className = '';                \n  if (theme === 'default') {\n    className = rounded ? 'default-btn rounded' : 'default-btn';\n    if (hover) {\n      className = className + ' hover';\n    }\n  } else if (theme === 'primary') {\n    if (rounded) {\n      if (hover) {\n        if (animation) {\n           className = 'primary-btn rounded hover my-custom-animation';\n        } else {\n          className = 'primary-btn rounded hover';\n        }\n      } else {\n        className = 'primary-btn rounded';\n      }\n    } else {\n      if (hover) {\n        className = 'primary-btn hover';\n      } else {\n        className = 'primary-btn';\n      }\n    }\n  }\n\n  return (\n    <button className={className}>{content}</button>\n  );\n}MyButton.4.jsxThat got out of hand way too quickly \u2026. didn\u2019t it?and you think to yourself, there was nothing you could have done :(In order to make this code simpler, we need to understand all the possible states that this code has. I have made a possibility chart of all the possible combinations at a certain time for the button.All the possible combinations of values that <MyButton /> component can have at a timeIf this seems a bit complicated, you can try looking at this next chart for your understanding.This is the same as the previous one, the FALSE values are omitted here for simplicity sakeThe key thing when writing code is understanding the data flow of your code. Once you have a complete understanding of it, everything becomes simpler.SolutionBased on the above given criteria, I can write my code like this to simplify it.const MyButton = ({ theme, rounded, hover, animation, content }) => {\n  const isThemeDefault = theme === 'default'\n  const isThemePrimary = theme === 'primary';\n  const isRounded = rounded === true;\n  const isHover = hover === true;\n  const isAnimated = animation === true;\n  \n  const isPrimaryAnimated = isThemePrimary && isAnimated;\n  \n  let className = isThemePrimary ? 'primary-btn' : 'default-btn';\n\n  if (isRounded) {\n    className = `${className} rounded`;\n  }\n  if (isHover) {\n    className = `${className} hover`;\n  }\n  if (isPrimaryAnimated) {\n    className = `${className} animated`;\n  }\n \n  return (\n    <button className={className}>{content}</button>\n  );\n}MyButton.5.jsx (As a bonus feature, it also ends up handling an edge case where, if the wrong theme is passed to MyButton, it ends up ignoring it & assigning it the value of default.This code is now way more readable. Any developer who works on this code can easily extend its functionality & get on with their life, knowing that they have done a wonderful job with the code.You can try playing with the code if you want, to see if it matches all the use cases.codesandbox demo https://codesandbox.io/s/0pl6xvqrnwWith the automata (finite state machines)-like coding approach:Code is more readable nowCode is more maintainableFeel free to share your thoughts. Thank you for reading.You can also reach me out on twitter @adeelibrReference & Inspiration: Stack Exchange Forum\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 6905, "excerpt": "Photo by Markus Spiske\n[https://unsplash.com/@markusspiske?utm_source=ghost&utm_medium=referral&utm_campaign=api-credit] \n/ Unsplash\n[https://unsplash.com/?utm_source=ghost&utm_medium=referral&utm_campaign=api-credit]\nWhat is this topic about?\nIf you are from a javascript background you might have heard the terms callback\nhell or async/await hell. It looks something like this:\n\nThe horror.There is a similar situation with just using if/else as well. You might label\nthis as developers being obses", "siteName": "freeCodeCamp.org", "publishedTime": "2019-04-25T16:34:57.000Z", "id": "80305a6aa5e793cc1425ba871e9e0ff2f8d73c9f", "url": "https://www.freecodecamp.org/news/so-youre-in-if-else-hell-here-s-how-to-get-out-of-it-fc6407fec0e/", "domain": "freecodecamp.org", "date": "2023-12-27T18:11:20.432158", "resultUri": "http://localhost:3000/result/80305a6aa5e793cc1425ba871e9e0ff2f8d73c9f", "query": {"url": ["https://www.freecodecamp.org/news/so-youre-in-if-else-hell-here-s-how-to-get-out-of-it-fc6407fec0e/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "So you\u2019re in if/else hell\u200a\u2014\u200ahere\u2019s how to get out of it", "description": "Photo by Markus Spiske [https://unsplash.com/@markusspiske?utm_source=ghost&utm_medium=referral&utm_campaign=api-credit]  / Unsplash [https://unsplash.com/?utm_source=ghost&utm_medium=referral&utm_campaign=api-credit] What is this topic about? If you are from a javascript background you might have heard the terms callback hell or async/await hell. It looks something like this: The horror.There is a similar situation with just using if/else as well. You", "url": "https://www.freecodecamp.org/news/so-youre-in-if-else-hell-here-s-how-to-get-out-of-it-fc6407fec0e/", "image": "https://cdn-media-1.freecodecamp.org/images/1*hEbJvltnslRrdEzjWQ7Img.jpeg", "image:width": "800", "image:height": "533"}, "twitter": {"card": "summary_large_image", "title": "So you\u2019re in if/else hell\u200a\u2014\u200ahere\u2019s how to get out of it", "description": "Photo by Markus Spiske [https://unsplash.com/@markusspiske?utm_source=ghost&utm_medium=referral&utm_campaign=api-credit]  / Unsplash [https://unsplash.com/?utm_source=ghost&utm_medium=referral&utm_campaign=api-credit] What is this topic about? If you are from a javascript background you might have heard the terms callback hell or async/await hell. It looks something like this: The horror.There is a similar situation with just using if/else as well. You", "url": "https://www.freecodecamp.org/news/so-youre-in-if-else-hell-here-s-how-to-get-out-of-it-fc6407fec0e/", "image": "https://cdn-media-1.freecodecamp.org/images/1*hEbJvltnslRrdEzjWQ7Img.jpeg", "label1": "Written by", "data1": "Adeel Imran", "label2": "Filed under", "data2": "JavaScript, Design Patterns, Tech, Programming, Technology", "site": "@freecodecamp", "creator": "@adeelibr"}}}