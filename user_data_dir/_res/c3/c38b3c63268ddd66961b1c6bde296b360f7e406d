{"title": "Problem Solving Patterns for Technical Interviews: the Frequency Counter Pattern Explained", "byline": "Martin Cartledge", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>Problem Solving Patterns for Technical Interviews: the Frequency Counter Pattern Explained</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>In my last article, I shared my thoughts on how to <a href=\"https://www.martincartledge.io/prepare-for-software-developer-interview/\" rel=\"noopener\">prepare for a software developer interview</a>. </p><p>In this article, I am going to switch gears a bit and talk about common patterns you can use to solve problems in technical interviews. We'll discuss the <em>frequency counter</em> pattern in depth to help you tackle it effectively.</p><p>The Frequency Counter pattern uses an object or set to collect values and the frequency of those values.</p><p>This pattern is often used with an <code>array</code> or a <code>string</code>, and allows you to avoid nested loops (quadratic time complexity <code>O(n\u00b2)</code>).</p><h2 id=\"when-should-i-use-the-frequency-counter-pattern\">When should I use the Frequency Counter pattern?</h2><p>The Frequency Counter pattern is most helpful when you have multiple pieces of data that you want to compare with one another. Let me walk you through an example to see the Frequency Counter in action.</p><h2 id=\"the-samesquared-exercise\">The \"sameSquared\" exercise</h2><ul><li>Write a function called <code>sameSquared</code> which accepts two arrays</li><li>The function should return <code>true</code> if <em>every</em> value in the first array has its corresponding value squared in the second array</li><li>The frequency of the values must be the same</li></ul><h3 id=\"what-is-the-optimal-outcome\">What is the optimal outcome?</h3><p>After our function is written, we should expect our <code>sameSquared</code> function to return these values.</p><p><code>sameSquared([1, 2, 3], [4, 1, 9]); <em>// true</em></code></p><p><code>sameSquared([1, 2, 3], [1, 9]); <em>// false</em></code></p><p><code>sameSquared([1, 2, 1], [4, 4, 1]); <em>// false</em></code></p><p><code>sameSquared([2, 3, 6, 8, 8], [64, 36, 4, 9, 64]); <em>// true</em></code></p><h3 id=\"getting-started\">Getting started</h3><p>First, using the <code>function</code> keyword, we create a function with the identifier <code>sameSquared</code>:</p><pre tabindex=\"0\"><code>function sameSquared() {\n</code></pre><p>Our function <code>sameSquared</code> needs two parameters, a first array and a second array. In this example, we are passing these values <code>[1, 2, 3]</code> and <code>[4, 1, 9]</code>.</p><pre tabindex=\"0\"><code>function sameSquared(firstArr, secondArr) {\n\n    </code></pre><h3 id=\"check-edge-cases\">Check edge cases</h3><p>Inside of our function block, we want to address a few edge cases. First, we need to check that both parameters have truthy values, that is <em>not</em> <code>null</code>, <code>undefined</code>, and so on. </p><p>We can check for a falsy value by using the <code>!</code> operator. If <code>firstArr</code> or <code>secondArr</code> is falsy, we return <code>false</code>.</p><pre tabindex=\"0\"><code>function sameSquared(firstArr, secondArr) {\n  if (!firstArr || !secondArr) return false;</code></pre><p>The next edge case we want to account for is to ensure that the length of both arrays are the same. If they are different, we know that they can <em>not</em> contain an equal amount of shared values.</p><p>By checking the <code>length</code> property on both parameters, we can determine if they are the same. If they are not, we return <code>false</code>.</p><pre tabindex=\"0\"><code>function sameSquared(firstArr, secondArr) {\n  if (!firstArr || !secondArr) return false;\n  if (firstArr.length !== secondArr.length) return false;</code></pre><h3 id=\"build-a-dictionary-to-avoid-nested-loops\">Build a \"dictionary\" to avoid nested loops</h3><p>We need to keep track of all values in at least one of the arrays. To do this, and to avoid a nested loop, we can store these values in a hash table (object). I\u2019ll call mine <code>lookup</code>.</p><pre tabindex=\"0\"><code>function sameSquared(firstArr, secondArr) {\n  if (!firstArr || !secondArr) return false;\n  if (firstArr.length !== secondArr.length) return false;\n\n  const lookup = {};</code></pre><p>Using a <code>for of</code> loop, we iterate through the <code>firstArr</code>. Inside of the <code>for of</code> block, we assign the key to the result of <code>value * value</code>.</p><p>The value in this key/value pair will be a <em>frequency counter</em> that reflects how many times a specific value is \u201cseen\u201d in the <code>firstArr</code>.</p><p>First, we check if <code>lookup</code> contains an entry for <code>value * value</code>, if it does, we add <code>1</code> to it. If it does not, we assign the value to <code>0</code> and then add <code>1</code>.</p><pre tabindex=\"0\"><code>function sameSquared(firstArr, secondArr) {\n  if (!firstArr || !secondArr) return false;\n  if (firstArr.length !== secondArr.length) return false;\n\n  const lookup = {};\n\n  for (value of firstArr) {\n    lookup[value * value] = (lookup[value * value] || 0) + 1;\n  }</code></pre><p>Once the <code>firstArr</code> is finished looping, the <code>lookup</code> should contain these values:</p><pre tabindex=\"0\"><code>{\n  1: 1,\n  4: 1,\n  9: 1\n}</code></pre><h3 id=\"compare-array-values\">Compare array values</h3><p>Now that we have iterated through all of the values in the <code>firstArr</code> and stored them as their respective <em>squared</em> value, we want to compare those values to the values in the <code>secondArr</code>.</p><p>We start by creating another <code>for of</code> loop. On the first line inside of our new <code>for of</code> block, we write a conditional statement to check if the current value from our <code>secondArr</code> is <em>not</em> inside of our <code>lookup</code>. If it is not, we stop looping and return <code>false</code>.</p><p>If the value from the <code>secondArr</code> is in our <code>lookup</code>, we want to decrement the value of that entry. We can do so by using the <code>-=</code> assignment operator.</p><pre tabindex=\"0\"><code>function sameSquared(firstArr, secondArr) {\n  if (!firstArr || !secondArr) return false;\n  if (firstArr.length !== secondArr.length) return false;\n\n  const lookup = {};\n  for (value of firstArr) {\n    lookup[value * value] = (lookup[value * value] || 0) + 1;\n  }\n  for (secondValue of secondArr) {\n    if (!lookup[secondValue]) return false;\n      lookup[secondValue] -= 1;\n    }</code></pre><p>After we are finished looping through the <code>secondArr</code>, our <code>lookup</code> should have these values:</p><pre tabindex=\"0\"><code>{\n  1: 0,\n  4: 0,\n  9: 0\n}</code></pre><h3 id=\"wrapping-up-our-samesquared-function\">Wrapping up our \"sameSquared\" function</h3><p>If we finish iterating through the <code>secondArr</code> without returning <code>false</code>, that means that our <code>firstArr</code> contains all values that are in a squared state in the <code>secondArr</code>. Therefore, we return <code>true</code> outside of <code>for of</code> loop.</p><pre tabindex=\"0\"><code>function sameSquared(firstArr, secondArr) {\n  if (!firstArr || !secondArr) return false;\n  if (firstArr.length !== secondArr.length) return false;\n\n  const lookup = {};\n  for (value of firstArr) {\n    lookup[value * value] = (lookup[value * value] || 0) + 1;\n  }\n  for (secondValue of secondArr) {\n    if (!lookup[secondValue]) return false;\n    lookup[secondValue] -= 1;\n  }\n  return true;\n}</code></pre><p>Let me show you another example which is used very commonly in coding assessments (so you might\u2019ve seen this problem before).</p><h2 id=\"the-isanagram-exercise\">The \"isAnagram\" exercise</h2><ul><li>Write a function called <code>isAnagram</code> which accepts two strings</li><li>The function should return <code>true</code> if the two strings parameters are <a href=\"https://en.wikipedia.org/wiki/Anagram\" rel=\"noopener\">anagrams</a> of each other</li></ul><h3 id=\"what-is-the-optimal-outcome-1\">What is the optimal outcome?</h3><p>After our function is written, we should expect our <code>isAnagram</code> function to return these values.</p><p><code>isAnagram(\u201csilent\u201d, \u201clisten\u201d); <em>// true</em></code></p><p><code>isAnagram(\u201cmartin\u201d, \u201cnitram\u201d); <em>// true</em></code></p><p><code>isAnagram(\u201ccat\u201d, \u201ctag\u201d); <em>// false</em></code></p><p><code>isAnagram(\u201crat\u201d, \u201ctar\u201d); <em>// true</em></code></p><h3 id=\"getting-started-1\">Getting started</h3><p>First, using the <code>function</code> keyword, we create a function with the identifier <code>isAnagram</code>:</p><pre tabindex=\"0\"><code>function isAnagram() {\n</code></pre><p>Our function <code>isAnagram</code> needs two parameters, a first <code>string</code> and a second <code>string</code>. In this example, we are passing these value, <code>silent</code> and <code>listen</code>.</p><pre tabindex=\"0\"><code>function isAnagram(firstStr, secondStr) {\n</code></pre><h3 id=\"check-edge-cases-1\">Check edge cases</h3><p>On the first few lines of our function block, we want to address a few edge cases, just like in the first example. </p><p>Similar to <code>isAnagram</code>, we need to check that both parameters have truthy values, that is <em>not</em> <code>null</code>, <code>undefined</code>, and so on. We can check for a falsy value by using the <code>!</code> operator. If <code>firstStr</code> or <code>secondStr</code> is falsy, we return <code>false</code>.</p><pre tabindex=\"0\"><code>function isAnagram(firstStr, secondStr) {\n  if (!firstStr || !secondStr) return false;</code></pre><p>The next edge case we want to account for is to ensure that the length of both arrays are the same. If they are different, we know that they can <em>not</em> contain an equal number of shared values.</p><p>By checking the <code>length</code> property on both parameters, we can determine if they are the same. If they are not, we return <code>false</code></p><pre tabindex=\"0\"><code>function isAnagram(firstStr, secondStr) {\n  if (!firstStr || !secondStr) return false;\n  if (firstStr.length !== secondStr.length) return false;</code></pre><h3 id=\"build-a-dictionary-to-avoid-nested-loops-1\">Build a \"dictionary\" to avoid nested loops</h3><p>Remember, we are using the frequency counter pattern and we need to keep track of all values in at least one of the arrays. Now we know that the best way to handle this is to store these values in a hash table (object). To keep things consistent, I\u2019ll call mine <code>lookup</code> again.</p><pre tabindex=\"0\"><code>function isAnagram(firstStr, secondStr) {\n  if (!firstStr || !secondStr) return false;\n  if (firstStr.length !== secondStr.length) return false;\n\n  const lookup = {};</code></pre><p>Using a <code>for of</code> loop, we iterate through the <code>firstStr</code>. Inside of the <code>for of</code> block, we assign the key to the result of the expression <code>value * value</code>.</p><p>The value in this key/value pair will be a <em>frequency counter</em> that reflects how many times a specific value is \u201cseen\u201d in the <code>firstStr</code>.</p><p>Using a ternary operator, we check if <code>lookup</code> contains an entry for <code>value * value</code>, if it does, we use the <code>+=</code> assignment operator to increment the value by <code>1</code>. If it does not, we simply assign the value to <code>1</code>.</p><pre tabindex=\"0\"><code>function isAnagram(firstStr, secondStr) {\n\tif (!firstStr || !secondStr) return false;\n    if (firstStr.length !== secondStr.length) return false;\n\n\tconst lookup = {};\n\n\tfor (first of firstStr) {\n\n    \tlookup[first] ? (lookup[first] += 1) : (lookup[first] = 1);\n\n  }</code></pre><p>Once the <code>firstStr</code> is finished looping, the <code>lookup</code> should contain these values:</p><pre tabindex=\"0\"><code>{\n  s: 1,\n  i: 1,\n  l: 1,\n  e: 1,\n  n: 1,\n  t: 1\n}</code></pre><h3 id=\"compare-array-values-1\">Compare array values</h3><p>Now that we have iterated through all of the values in the <code>firstStr</code> and stored their values, we want to compare those values to the values in the <code>secondStr</code>.</p><p>We start by creating another <code>for of</code> loop. On the first line inside of our new <code>for of</code> block, we write a conditional statement to check if the current value from our <code>secondStr</code> is <em>not</em> inside of our <code>lookup</code>. If it is not, we want to stop iteration and return <code>false</code>.</p><p>Otherwise, if the value from the <code>secondStr</code> <em>is</em> in our <code>lookup</code>, we want to decrement the value of that entry. We can do so by using the <code>-=</code> assignment operator.</p><pre tabindex=\"0\"><code>function isAnagram(firstStr, secondStr) {\n  if (!firstStr || !secondStr) return false;\n  if (firstStr.length !== secondStr.length) return false;\n\n  const lookup = {};\n\n  for (first of firstStr) {\n    lookup[first] ? (lookup[first] += 1) : (lookup[first] = 1);\n  }\n\n  for (second of secondStr) {\n    if (!lookup[second]) return false;\n    lookup[second] -= 1;\n  }</code></pre><p>After we are finished looping through the <code>secondStr</code>, our <code>lookup</code> should have these values:</p><pre tabindex=\"0\"><code>{\n  s: 0,\n  i: 0,\n  l: 0,\n  e: 0,\n  n: 0,\n  t: 0\n}</code></pre><h3 id=\"wrapping-up-our-isanagram-function\">Wrapping up our \"isAnagram\" function</h3><p>If we finish iterating through the <code>secondStr</code> without returning <code>false</code>, that means that our <code>firstStr</code> contains all values that are in the <code>secondStr</code>. Therefore, we return <code>true</code> outside of <code>for of</code> loop.</p><pre tabindex=\"0\"><code>function isAnagram(firstStr, secondStr) {\n  if (!firstStr || !secondStr) return false;\n  if (firstStr.length !== secondStr.length) return false;\n\n  const lookup = {};\n\n  for (first of firstStr) {\n    lookup[first] ? (lookup[first] += 1) : (lookup[first] = 1);\n  }\n\n  for (second of secondStr) {\n    if (!lookup[second]) return false;\n    lookup[second] -= 1;\n  }\n  return true;\n}</code></pre><h2 id=\"in-summary\">In Summary</h2><p>I hope this in-depth overview of the Frequency Counter pattern was helpful. Now that you know how the pattern works, I am confident that you will be able to impress your interviewer by showcasing your skills at an even higher level.</p><p>In my next article, I will be discussing another common problem-solving pattern called the Sliding Window. Thanks for reading, and happy interviewing!</p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nIn my last article, I shared my thoughts on how to prepare for a software developer interview. In this article, I am going to switch gears a bit and talk about common patterns you can use to solve problems in technical interviews. We'll discuss the frequency counter pattern in depth to help you tackle it effectively.The Frequency Counter pattern uses an object or set to collect values and the frequency of those values.This pattern is often used with an array or a string, and allows you to avoid nested loops (quadratic time complexity O(n\u00b2)).When should I use the Frequency Counter pattern?The Frequency Counter pattern is most helpful when you have multiple pieces of data that you want to compare with one another. Let me walk you through an example to see the Frequency Counter in action.The \"sameSquared\" exerciseWrite a function called sameSquared which accepts two arraysThe function should return true if every value in the first array has its corresponding value squared in the second arrayThe frequency of the values must be the sameWhat is the optimal outcome?After our function is written, we should expect our sameSquared function to return these values.sameSquared([1, 2, 3], [4, 1, 9]); // truesameSquared([1, 2, 3], [1, 9]); // falsesameSquared([1, 2, 1], [4, 4, 1]); // falsesameSquared([2, 3, 6, 8, 8], [64, 36, 4, 9, 64]); // trueGetting startedFirst, using the function keyword, we create a function with the identifier sameSquared:function sameSquared() {\nOur function sameSquared needs two parameters, a first array and a second array. In this example, we are passing these values [1, 2, 3] and [4, 1, 9].function sameSquared(firstArr, secondArr) {\n\n    Check edge casesInside of our function block, we want to address a few edge cases. First, we need to check that both parameters have truthy values, that is not null, undefined, and so on. We can check for a falsy value by using the ! operator. If firstArr or secondArr is falsy, we return false.function sameSquared(firstArr, secondArr) {\n  if (!firstArr || !secondArr) return false;The next edge case we want to account for is to ensure that the length of both arrays are the same. If they are different, we know that they can not contain an equal amount of shared values.By checking the length property on both parameters, we can determine if they are the same. If they are not, we return false.function sameSquared(firstArr, secondArr) {\n  if (!firstArr || !secondArr) return false;\n  if (firstArr.length !== secondArr.length) return false;Build a \"dictionary\" to avoid nested loopsWe need to keep track of all values in at least one of the arrays. To do this, and to avoid a nested loop, we can store these values in a hash table (object). I\u2019ll call mine lookup.function sameSquared(firstArr, secondArr) {\n  if (!firstArr || !secondArr) return false;\n  if (firstArr.length !== secondArr.length) return false;\n\n  const lookup = {};Using a for of loop, we iterate through the firstArr. Inside of the for of block, we assign the key to the result of value * value.The value in this key/value pair will be a frequency counter that reflects how many times a specific value is \u201cseen\u201d in the firstArr.First, we check if lookup contains an entry for value * value, if it does, we add 1 to it. If it does not, we assign the value to 0 and then add 1.function sameSquared(firstArr, secondArr) {\n  if (!firstArr || !secondArr) return false;\n  if (firstArr.length !== secondArr.length) return false;\n\n  const lookup = {};\n\n  for (value of firstArr) {\n    lookup[value * value] = (lookup[value * value] || 0) + 1;\n  }Once the firstArr is finished looping, the lookup should contain these values:{\n  1: 1,\n  4: 1,\n  9: 1\n}Compare array valuesNow that we have iterated through all of the values in the firstArr and stored them as their respective squared value, we want to compare those values to the values in the secondArr.We start by creating another for of loop. On the first line inside of our new for of block, we write a conditional statement to check if the current value from our secondArr is not inside of our lookup. If it is not, we stop looping and return false.If the value from the secondArr is in our lookup, we want to decrement the value of that entry. We can do so by using the -= assignment operator.function sameSquared(firstArr, secondArr) {\n  if (!firstArr || !secondArr) return false;\n  if (firstArr.length !== secondArr.length) return false;\n\n  const lookup = {};\n  for (value of firstArr) {\n    lookup[value * value] = (lookup[value * value] || 0) + 1;\n  }\n  for (secondValue of secondArr) {\n    if (!lookup[secondValue]) return false;\n      lookup[secondValue] -= 1;\n    }After we are finished looping through the secondArr, our lookup should have these values:{\n  1: 0,\n  4: 0,\n  9: 0\n}Wrapping up our \"sameSquared\" functionIf we finish iterating through the secondArr without returning false, that means that our firstArr contains all values that are in a squared state in the secondArr. Therefore, we return true outside of for of loop.function sameSquared(firstArr, secondArr) {\n  if (!firstArr || !secondArr) return false;\n  if (firstArr.length !== secondArr.length) return false;\n\n  const lookup = {};\n  for (value of firstArr) {\n    lookup[value * value] = (lookup[value * value] || 0) + 1;\n  }\n  for (secondValue of secondArr) {\n    if (!lookup[secondValue]) return false;\n    lookup[secondValue] -= 1;\n  }\n  return true;\n}Let me show you another example which is used very commonly in coding assessments (so you might\u2019ve seen this problem before).The \"isAnagram\" exerciseWrite a function called isAnagram which accepts two stringsThe function should return true if the two strings parameters are anagrams of each otherWhat is the optimal outcome?After our function is written, we should expect our isAnagram function to return these values.isAnagram(\u201csilent\u201d, \u201clisten\u201d); // trueisAnagram(\u201cmartin\u201d, \u201cnitram\u201d); // trueisAnagram(\u201ccat\u201d, \u201ctag\u201d); // falseisAnagram(\u201crat\u201d, \u201ctar\u201d); // trueGetting startedFirst, using the function keyword, we create a function with the identifier isAnagram:function isAnagram() {\nOur function isAnagram needs two parameters, a first string and a second string. In this example, we are passing these value, silent and listen.function isAnagram(firstStr, secondStr) {\nCheck edge casesOn the first few lines of our function block, we want to address a few edge cases, just like in the first example. Similar to isAnagram, we need to check that both parameters have truthy values, that is not null, undefined, and so on. We can check for a falsy value by using the ! operator. If firstStr or secondStr is falsy, we return false.function isAnagram(firstStr, secondStr) {\n  if (!firstStr || !secondStr) return false;The next edge case we want to account for is to ensure that the length of both arrays are the same. If they are different, we know that they can not contain an equal number of shared values.By checking the length property on both parameters, we can determine if they are the same. If they are not, we return falsefunction isAnagram(firstStr, secondStr) {\n  if (!firstStr || !secondStr) return false;\n  if (firstStr.length !== secondStr.length) return false;Build a \"dictionary\" to avoid nested loopsRemember, we are using the frequency counter pattern and we need to keep track of all values in at least one of the arrays. Now we know that the best way to handle this is to store these values in a hash table (object). To keep things consistent, I\u2019ll call mine lookup again.function isAnagram(firstStr, secondStr) {\n  if (!firstStr || !secondStr) return false;\n  if (firstStr.length !== secondStr.length) return false;\n\n  const lookup = {};Using a for of loop, we iterate through the firstStr. Inside of the for of block, we assign the key to the result of the expression value * value.The value in this key/value pair will be a frequency counter that reflects how many times a specific value is \u201cseen\u201d in the firstStr.Using a ternary operator, we check if lookup contains an entry for value * value, if it does, we use the += assignment operator to increment the value by 1. If it does not, we simply assign the value to 1.function isAnagram(firstStr, secondStr) {\n\tif (!firstStr || !secondStr) return false;\n    if (firstStr.length !== secondStr.length) return false;\n\n\tconst lookup = {};\n\n\tfor (first of firstStr) {\n\n    \tlookup[first] ? (lookup[first] += 1) : (lookup[first] = 1);\n\n  }Once the firstStr is finished looping, the lookup should contain these values:{\n  s: 1,\n  i: 1,\n  l: 1,\n  e: 1,\n  n: 1,\n  t: 1\n}Compare array valuesNow that we have iterated through all of the values in the firstStr and stored their values, we want to compare those values to the values in the secondStr.We start by creating another for of loop. On the first line inside of our new for of block, we write a conditional statement to check if the current value from our secondStr is not inside of our lookup. If it is not, we want to stop iteration and return false.Otherwise, if the value from the secondStr is in our lookup, we want to decrement the value of that entry. We can do so by using the -= assignment operator.function isAnagram(firstStr, secondStr) {\n  if (!firstStr || !secondStr) return false;\n  if (firstStr.length !== secondStr.length) return false;\n\n  const lookup = {};\n\n  for (first of firstStr) {\n    lookup[first] ? (lookup[first] += 1) : (lookup[first] = 1);\n  }\n\n  for (second of secondStr) {\n    if (!lookup[second]) return false;\n    lookup[second] -= 1;\n  }After we are finished looping through the secondStr, our lookup should have these values:{\n  s: 0,\n  i: 0,\n  l: 0,\n  e: 0,\n  n: 0,\n  t: 0\n}Wrapping up our \"isAnagram\" functionIf we finish iterating through the secondStr without returning false, that means that our firstStr contains all values that are in the secondStr. Therefore, we return true outside of for of loop.function isAnagram(firstStr, secondStr) {\n  if (!firstStr || !secondStr) return false;\n  if (firstStr.length !== secondStr.length) return false;\n\n  const lookup = {};\n\n  for (first of firstStr) {\n    lookup[first] ? (lookup[first] += 1) : (lookup[first] = 1);\n  }\n\n  for (second of secondStr) {\n    if (!lookup[second]) return false;\n    lookup[second] -= 1;\n  }\n  return true;\n}In SummaryI hope this in-depth overview of the Frequency Counter pattern was helpful. Now that you know how the pattern works, I am confident that you will be able to impress your interviewer by showcasing your skills at an even higher level.In my next article, I will be discussing another common problem-solving pattern called the Sliding Window. Thanks for reading, and happy interviewing!\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 11340, "excerpt": "In my last article, I shared my thoughts on how to prepare for a software\ndeveloper interview\n[https://www.martincartledge.io/prepare-for-software-developer-interview/]. \n\nIn this article, I am going to switch gears a bit and talk about common patterns\nyou can use to solve problems in technical interviews. We'll discuss the \nfrequency counter pattern in depth to help you tackle it effectively.\n\nWhat is the \u201cFrequency Counter\u201d pattern?\nThe Frequency Counter pattern uses an object or set to collec", "siteName": "freeCodeCamp.org", "publishedTime": "2020-12-18T21:48:23.000Z", "id": "c38b3c63268ddd66961b1c6bde296b360f7e406d", "url": "https://www.freecodecamp.org/news/solve-technical-interview-questions-using-frequency-counter/", "domain": "freecodecamp.org", "date": "2023-12-27T18:06:22.166152", "resultUri": "http://localhost:3000/result/c38b3c63268ddd66961b1c6bde296b360f7e406d", "query": {"url": ["https://www.freecodecamp.org/news/solve-technical-interview-questions-using-frequency-counter/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "Problem Solving Patterns for Technical Interviews: the Frequency Counter Pattern Explained", "description": "In my last article, I shared my thoughts on how to prepare for a software developer interview [https://www.martincartledge.io/prepare-for-software-developer-interview/].  In this article, I am going to switch gears a bit and talk about common patterns you can use to solve problems in technical interviews. We'll discuss the  frequency counter", "url": "https://www.freecodecamp.org/news/solve-technical-interview-questions-using-frequency-counter/", "image": "https://www.freecodecamp.org/news/content/images/2020/12/beach.jpg", "image:width": "2000", "image:height": "1333"}, "twitter": {"card": "summary_large_image", "title": "Problem Solving Patterns for Technical Interviews: the Frequency Counter Pattern Explained", "description": "In my last article, I shared my thoughts on how to prepare for a software developer interview [https://www.martincartledge.io/prepare-for-software-developer-interview/].  In this article, I am going to switch gears a bit and talk about common patterns you can use to solve problems in technical interviews. We'll discuss the  frequency counter", "url": "https://www.freecodecamp.org/news/solve-technical-interview-questions-using-frequency-counter/", "image": "https://www.freecodecamp.org/news/content/images/2020/12/beach.jpg", "label1": "Written by", "data1": "Martin Cartledge", "label2": "Filed under", "data2": "Interviews, Interview Tips, Career Advice, Careers, Self Improvement, Programming", "site": "@freecodecamp"}}}