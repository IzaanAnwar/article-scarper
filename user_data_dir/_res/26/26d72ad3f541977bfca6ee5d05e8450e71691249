{"title": "Some awesome modern C++ features that every developer should know", "byline": "M Chowdhury", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>Some awesome modern C++ features that every developer should know</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>As a language, C++ has evolved a lot.</p><p>Of course this did not happen overnight. There was a time when C++ lacked dynamism. It was difficult to be fond of the language.</p><p>But things changed when the C++ standard committee decided to spin up the wheel.</p><p>Since 2011, C++ has emerged as a dynamic and ever-evolving language that a lot of people have been hoping for.</p><p>Don\u2019t get the wrong idea that the language has become easier. It still is one of the hardest programming languages, if not the hardest one, that are used widely. But C++ has also become much more user friendly than its previous versions.</p><p>In my last post, I talked about the <a href=\"https://medium.freecodecamp.org/how-i-discovered-the-c-algorithm-library-and-learned-not-to-reinvent-the-wheel-2398a34e23e3\" rel=\"noopener\">C++ algorithm library</a> that has been enriched over the last couple of years.</p><p>Today, we shall look into some new features (starting from C++11, which is already 8 years old by the way) that every developer would like to know.</p><p>Also note that I have skipped some advanced features in this article, but I\u2019m willing to write about them in future. ?\ufe0f</p><h4 id=\"the-auto-keyword\">The auto keyword</h4><p>When C++11 first introduced <code><strong>auto</strong></code>, life became easier.</p><p>The idea of <code><strong>auto</strong></code> was to make the C++ compiler deduce the type of your data while compiling \u2014 instead of making you declare the type <em>every-freaking-time. </em>That was so convenient when you have data types like <code><strong>map&lt;string,vector&lt;pair&lt;i</strong></code>nt,int&gt;&gt;&gt; ?</p><figure><img alt=\"YwOaX7rBM68C0zmNWaR6gndEN3QGeNJC818u\" height=\"191\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/YwOaX7rBM68C0zmNWaR6gndEN3QGeNJC818u\" width=\"800\"/></figure><p>Look at the line number 5. You cannot declare something without an <code><strong>initializer</strong></code>. That actually makes sense. Line 5 doesn\u2019t let the compiler know what can the data type be.</p><p>Initially, <code><strong>auto</strong></code> was somewhat limited. Then in the later versions of the language, more power was added to it!</p><figure><img alt=\"-T08jZzWKlBmaksJQ07a73Z7OqtEVZ-w0uP5\" height=\"276\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/-T08jZzWKlBmaksJQ07a73Z7OqtEVZ-w0uP5\" width=\"800\"/></figure><p>In lines 7 and 8, I used bracketed initialization. This was also a new feature added in C++11.</p><p>Remember, in case of using <code><strong>auto</strong></code>, there must be some way for the compiler to deduce your type.</p><p>Now a very nice question, <em>what happens if we write </em><code><strong>auto a = {1, 2, 3}</strong></code>? Is that a compile error? Is that a vector?</p><figure><img alt=\"vqLLzds6Emf3TXGvAE0G7wLljRA5A809IABC\" height=\"500\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/vqLLzds6Emf3TXGvAE0G7wLljRA5A809IABC\" width=\"556\"/><figcaption>smh ? </figcaption></figure><p>Actually, C++11 introduced <code><strong>std::initializer_list&lt;ty</strong></code>pe&gt;. Braced initialized list will be considered as this lightweight container if dec<code><strong>lare</strong></code>d auto.</p><p>Finally, as I previously mentioned, type-deducing by compiler can be really useful when you have complex data structures:</p><figure><img alt=\"-eqnhRNy7wggdV2kZKrm8Jb075m5iQKBwb76\" height=\"774\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/-eqnhRNy7wggdV2kZKrm8Jb075m5iQKBwb76\" width=\"800\"/></figure><p>Don\u2019t forget to check out line 25! The expression <code><strong>auto [v1,v2] = itr.second</strong></code> is literally a new feature in C++17. This is called <strong>structured binding</strong>. In previous versions of the language, you had to extract each variable separately. But structured binding has made it much more convenient.</p><p>Moreover, if you wanted to get the data using reference, you would just add a symbol \u2014 <code><strong>auto &amp;[v1,v2] = itr.second</strong></code>.</p><h4 id=\"the-lambda-expression\">The lambda expression</h4><p>C++11 introduced lambda expressions, something like anonymous functions in JavaScript. They are function objects, without any names, and they capture variables on various <em>scopes</em> based on some concise syntax. They are also assignable to variables.</p><p>Lambdas are very useful if you need some small quick thing to be done inside your code but you are not willing to write a whole separate function for that. Another pretty common use is to use them as compare functions.</p><figure><img alt=\"q06OCThwvuI4tAq9WDMcFYMc45cQuBSMlorB\" height=\"141\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/q06OCThwvuI4tAq9WDMcFYMc45cQuBSMlorB\" width=\"800\"/></figure><p>The above example has a lot to say.</p><p>Firstly, notice how curly braced initialization is lifting the weight for you. Then comes generic <code><strong>begin(), end()</strong></code> that is also an addition in C++11. Then comes the lambda function as a comparator for you data. The parameters of the lambda function are declared <code><strong>auto</strong></code><strong> </strong>which was added in C++14. Before that, we could not use <code><strong>auto</strong></code> for function parameters.</p><p>Note how we start the lambda expression with a square bracket <code><strong>[]</strong></code>. They define the scope of the lambda \u2014 how much authority it has over the local variables and objects.</p><p>As defined in this <a href=\"https://github.com/AnthonyCalandra/modern-cpp-features#lambda-expressions\" rel=\"noopener\">awesome repository</a> on modern C++:</p><ul><li><code>[]</code>\u200a\u2014 captures nothing. So you cannot use any local variable of the outer scope inside your lambda expression. You can only use the parameters.</li><li><code>[=]</code> \u2014 captures local objects (local variables, parameters) in scope by value. You can use them, but cannot modify them.</li><li><code>[&amp;]</code>\u200a\u2014 capture local objects (local variables, parameters) in scope by reference. You can modify them. Like the following example.</li><li><code>[this]</code> \u2014 capture <code>this</code> pointer by value.</li><li><code>[a, &amp;b]</code> \u2014 capture objects <code>a</code> by value, <code>b</code> by reference.</li></ul><p>So if, inside your lambda function, you want to transform your data into some other format, you can use lambda by taking the advantage of the scoping. For example:</p><figure><img alt=\"5Mzg1Eaplh7V3tBwddUibP6e32TASKqNB5Bo\" height=\"296\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/5Mzg1Eaplh7V3tBwddUibP6e32TASKqNB5Bo\" width=\"800\"/></figure><p>In the above example, if you had captured local variables by value (<code><strong>[factor]</strong></code>) in your lambda expression, you could not change <code><strong>factor</strong></code> in line 5. Because simply, you have no right to do that. Don\u2019t misuse your rights! ?</p><p>Finally, notice that we take <code><strong>val</strong></code> as reference. This ensures that any change inside the lambda function actually changes the <code><strong>vector</strong></code>.</p><figure><img alt=\"bybwfMOcOk0FvwwbyJ3SpNr7PZ4hZbEvZZKo\" height=\"534\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/bybwfMOcOk0FvwwbyJ3SpNr7PZ4hZbEvZZKo\" width=\"800\"/><figcaption>They feel joyous after learning about modern C++! (Photo by <a href=\"https://unsplash.com/@goian?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\" target=\"_blank\" title=\"\">Ian Schneider</a> on <a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" rel=\"noopener\" target=\"_blank\" title=\"\">Unsplash</a>)</figcaption></figure><h4 id=\"init-statements-inside-if-switch\">Init statements inside if &amp; switch</h4><p>I really liked this feature of C++17 immediately after I got to know of it.</p><figure><img alt=\"YbAQUY16a5gfoVCDzIxa0VQRI2L62g3YmN51\" height=\"265\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/YbAQUY16a5gfoVCDzIxa0VQRI2L62g3YmN51\" width=\"800\"/></figure><p>So apparently, now you can do initialization of variables and check condition on that \u2014 simultaneously inside the <code><strong>if/switch</strong></code> block. This is really helpful to keep your code concise and clean. The general form is:</p><pre tabindex=\"0\"><code>if( init-statement(x); condition(x)) {\n    // do some stuff here\n} else {\n    // else has the scope of x\n    // do some other stuff\n}</code></pre><h4 id=\"do-it-in-compile-time-by-constexpr\">Do it in compile time by constexpr</h4><p><code><strong>constexpr</strong></code> is cool!</p><p>Say you have some expression to evaluate and its value won\u2019t change once initialized. You can pre-calculate the value and then use it as a macro. Or as C++11 offered, you can use <code><strong>constexpr</strong></code>.</p><p>Programmers tend to reduce runtime of their programs as much as possible. So if there are some operations you can make the compiler do and take the load off runtime, then the runtime can be improved.</p><figure><img alt=\"oFNs0a4DpggilcCOH4rUe6Lb7Og4g5JpI1PR\" height=\"367\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/oFNs0a4DpggilcCOH4rUe6Lb7Og4g5JpI1PR\" width=\"800\"/></figure><p>The above code is a very common example of <code><strong>constexpr</strong></code>.</p><p>Since we declared the fibonacci calculation function as <code><strong>constexpr</strong></code>, the compiler can pre-calculate <code><strong>fib(20)</strong></code><strong> </strong>in compile time. So after compilation, it can replace the line</p><p><code><strong>const long long bigval = fib(20);</strong></code><strong> </strong>with</p><p><code><strong>const long long bigval = 2432902008176640000;</strong></code></p><p>Note that the passed argument is a <code><strong>const</strong></code> value. This is one important point of functions declared <code><strong>constexpr</strong></code> \u2014 the arguments passed should also be <code><strong>constexpr</strong></code> or <code><strong>const</strong></code>. Otherwise, the function will behave as a normal function which means no pre-calculation during compile time.</p><p>Variables can also be <code><strong>constexpr</strong></code>, too. In that case, as you can guess, those variables have to be evaluable in compile time. Otherwise, you get a compilation error.</p><p>Interestingly, later in C++17, <code><a href=\"https://hackernoon.com/a-tour-of-c-17-if-constexpr-3ea62f62ff65\" rel=\"noopener\"><strong>constexpr-if</strong></a></code> and <code><a href=\"https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-constexpr?view=vs-2019\" rel=\"noopener\"><strong>constexpr-lambda</strong></a></code><strong> </strong>were introduced.</p><h4 id=\"tuples\">Tuples</h4><p>Much like <code><strong>pair</strong></code>, <code><strong>tuple</strong></code> is a collection of fixed size values of various data types.</p><figure><img alt=\"jeeQ66M5YWztfoGaEVNd5vBQgYXZkh6-layn\" height=\"403\" loading=\"lazy\" src=\"https://cdn-media-1.freecodecamp.org/images/jeeQ66M5YWztfoGaEVNd5vBQgYXZkh6-layn\" width=\"800\"/></figure><p>Sometimes it is more convenient to use <code><strong>std::array</strong></code> instead of <code><strong>tuple</strong></code>.<strong> <code>array</code> </strong>is similar to plain C type array along with couple of functionalities of the C++ standard library. This data structure was added in C++11.</p><h4 id=\"class-template-argument-deduction\">Class template argument deduction</h4><p>A very verbose name for a feature. The idea is, from C++17, argument deduction for templates will also happen for standard class templates. Previously, it was supported for only function templates.</p><p>As a result,</p><pre tabindex=\"0\"><code>std::pair&lt;std::string, int&gt; user = {\"M\", 25}; // previous\nstd::pair user = {\"M\", 25}; // C++17</code></pre><p>The type of deduction is done implicitly. This becomes even more convenient for <code><strong>tuple</strong></code>.</p><pre tabindex=\"0\"><code>// previous\nstd::tuple&lt;std::string, std::string, int&gt; user (\"M\", \"Chy\", 25);\n// deduction in action! \nstd::tuple user2(\"M\", \"Chy\", 25);</code></pre><p>This feature above won\u2019t make any sense if you are not quite familiar with C++ templates.</p><h4 id=\"smart-pointers\">Smart pointers</h4><p>Pointers can be hellish.</p><p>Due to the freedom that languages like C++ provide to programmers, it sometimes becomes very easy to shoot yourself in the foot. And in many cases, pointers are responsible for the harm.</p><p>Luckily, C++11 introduced smart pointers, pointers that are far more convenient than raw pointers. They help programmers to prevent memory-leaks by freeing it when possible. They also provide exception safety.</p><p>I thought of writing about the smart pointers in C++ in this post. But apparently, there are lots of important details about them. They deserve their own post and I am certainly willing to write one about them in near future.</p><p>That\u2019s all for today. Remember that C++ actually added a lot more newer features in the latest versions of the language. You should check them out if you feel interested. Here is an awesome repository on modern C++ which is literally named <a href=\"https://github.com/rigtorp/awesome-modern-cpp\" rel=\"noopener\">Awesome Modern C++</a>!</p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nAs a language, C++ has evolved a lot.Of course this did not happen overnight. There was a time when C++ lacked dynamism. It was difficult to be fond of the language.But things changed when the C++ standard committee decided to spin up the wheel.Since 2011, C++ has emerged as a dynamic and ever-evolving language that a lot of people have been hoping for.Don\u2019t get the wrong idea that the language has become easier. It still is one of the hardest programming languages, if not the hardest one, that are used widely. But C++ has also become much more user friendly than its previous versions.In my last post, I talked about the C++ algorithm library that has been enriched over the last couple of years.Today, we shall look into some new features (starting from C++11, which is already 8 years old by the way) that every developer would like to know.Also note that I have skipped some advanced features in this article, but I\u2019m willing to write about them in future. ?\ufe0fGo!The auto keywordWhen C++11 first introduced auto, life became easier.The idea of auto was to make the C++ compiler deduce the type of your data while compiling \u2014 instead of making you declare the type every-freaking-time. That was so convenient when you have data types like map<string,vector<pair<int,int>>> ?Look at the line number 5. You cannot declare something without an initializer. That actually makes sense. Line 5 doesn\u2019t let the compiler know what can the data type be.Initially, auto was somewhat limited. Then in the later versions of the language, more power was added to it!In lines 7 and 8, I used bracketed initialization. This was also a new feature added in C++11.Remember, in case of using auto, there must be some way for the compiler to deduce your type.Now a very nice question, what happens if we write auto a = {1, 2, 3}? Is that a compile error? Is that a vector?smh ? Actually, C++11 introduced std::initializer_list<type>. Braced initialized list will be considered as this lightweight container if declared auto.Finally, as I previously mentioned, type-deducing by compiler can be really useful when you have complex data structures:Don\u2019t forget to check out line 25! The expression auto [v1,v2] = itr.second is literally a new feature in C++17. This is called structured binding. In previous versions of the language, you had to extract each variable separately. But structured binding has made it much more convenient.Moreover, if you wanted to get the data using reference, you would just add a symbol \u2014 auto &[v1,v2] = itr.second.Neat.The lambda expressionC++11 introduced lambda expressions, something like anonymous functions in JavaScript. They are function objects, without any names, and they capture variables on various scopes based on some concise syntax. They are also assignable to variables.Lambdas are very useful if you need some small quick thing to be done inside your code but you are not willing to write a whole separate function for that. Another pretty common use is to use them as compare functions.The above example has a lot to say.Firstly, notice how curly braced initialization is lifting the weight for you. Then comes generic begin(), end() that is also an addition in C++11. Then comes the lambda function as a comparator for you data. The parameters of the lambda function are declared auto which was added in C++14. Before that, we could not use auto for function parameters.Note how we start the lambda expression with a square bracket []. They define the scope of the lambda \u2014 how much authority it has over the local variables and objects.As defined in this awesome repository on modern C++:[]\u200a\u2014 captures nothing. So you cannot use any local variable of the outer scope inside your lambda expression. You can only use the parameters.[=] \u2014 captures local objects (local variables, parameters) in scope by value. You can use them, but cannot modify them.[&]\u200a\u2014 capture local objects (local variables, parameters) in scope by reference. You can modify them. Like the following example.[this] \u2014 capture this pointer by value.[a, &b] \u2014 capture objects a by value, b by reference.So if, inside your lambda function, you want to transform your data into some other format, you can use lambda by taking the advantage of the scoping. For example:In the above example, if you had captured local variables by value ([factor]) in your lambda expression, you could not change factor in line 5. Because simply, you have no right to do that. Don\u2019t misuse your rights! ?Finally, notice that we take val as reference. This ensures that any change inside the lambda function actually changes the vector.They feel joyous after learning about modern C++! (Photo by Ian Schneider on Unsplash)Init statements inside if & switchI really liked this feature of C++17 immediately after I got to know of it.So apparently, now you can do initialization of variables and check condition on that \u2014 simultaneously inside the if/switch block. This is really helpful to keep your code concise and clean. The general form is:if( init-statement(x); condition(x)) {\n    // do some stuff here\n} else {\n    // else has the scope of x\n    // do some other stuff\n}Do it in compile time by constexprconstexpr is cool!Say you have some expression to evaluate and its value won\u2019t change once initialized. You can pre-calculate the value and then use it as a macro. Or as C++11 offered, you can use constexpr.Programmers tend to reduce runtime of their programs as much as possible. So if there are some operations you can make the compiler do and take the load off runtime, then the runtime can be improved.The above code is a very common example of constexpr.Since we declared the fibonacci calculation function as constexpr, the compiler can pre-calculate fib(20) in compile time. So after compilation, it can replace the lineconst long long bigval = fib(20); withconst long long bigval = 2432902008176640000;Note that the passed argument is a const value. This is one important point of functions declared constexpr \u2014 the arguments passed should also be constexpr or const. Otherwise, the function will behave as a normal function which means no pre-calculation during compile time.Variables can also be constexpr, too. In that case, as you can guess, those variables have to be evaluable in compile time. Otherwise, you get a compilation error.Interestingly, later in C++17, constexpr-if and constexpr-lambda were introduced.TuplesMuch like pair, tuple is a collection of fixed size values of various data types.Sometimes it is more convenient to use std::array instead of tuple. array is similar to plain C type array along with couple of functionalities of the C++ standard library. This data structure was added in C++11.Class template argument deductionA very verbose name for a feature. The idea is, from C++17, argument deduction for templates will also happen for standard class templates. Previously, it was supported for only function templates.As a result,std::pair<std::string, int> user = {\"M\", 25}; // previous\nstd::pair user = {\"M\", 25}; // C++17The type of deduction is done implicitly. This becomes even more convenient for tuple.// previous\nstd::tuple<std::string, std::string, int> user (\"M\", \"Chy\", 25);\n// deduction in action! \nstd::tuple user2(\"M\", \"Chy\", 25);This feature above won\u2019t make any sense if you are not quite familiar with C++ templates.Smart pointersPointers can be hellish.Due to the freedom that languages like C++ provide to programmers, it sometimes becomes very easy to shoot yourself in the foot. And in many cases, pointers are responsible for the harm.Luckily, C++11 introduced smart pointers, pointers that are far more convenient than raw pointers. They help programmers to prevent memory-leaks by freeing it when possible. They also provide exception safety.I thought of writing about the smart pointers in C++ in this post. But apparently, there are lots of important details about them. They deserve their own post and I am certainly willing to write one about them in near future.That\u2019s all for today. Remember that C++ actually added a lot more newer features in the latest versions of the language. You should check them out if you feel interested. Here is an awesome repository on modern C++ which is literally named Awesome Modern C++!Adios!\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 8979, "excerpt": "As a language, C++ has evolved a lot.\n\nOf course this did not happen overnight. There was a time when C++ lacked\ndynamism. It was difficult to be fond of the language.\n\nBut things changed when the C++ standard committee decided to spin up the wheel.\n\nSince 2011, C++ has emerged as a dynamic and ever-evolving language that a lot\nof people have been hoping for.\n\nDon\u2019t get the wrong idea that the language has become easier. It still is one of\nthe hardest programming languages, if not the hardest on", "siteName": "freeCodeCamp.org", "publishedTime": "2019-05-08T16:21:51.000Z", "id": "26d72ad3f541977bfca6ee5d05e8450e71691249", "url": "https://www.freecodecamp.org/news/some-awesome-modern-c-features-that-every-developer-should-know-5e3bf6f79a3c/", "domain": "freecodecamp.org", "date": "2023-12-27T18:10:24.247600", "resultUri": "http://localhost:3000/result/26d72ad3f541977bfca6ee5d05e8450e71691249", "query": {"url": ["https://www.freecodecamp.org/news/some-awesome-modern-c-features-that-every-developer-should-know-5e3bf6f79a3c/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "Some awesome modern C++ features that every developer should know", "description": "As a language, C++ has evolved a lot. Of course this did not happen overnight. There was a time when C++ lacked dynamism. It was difficult to be fond of the language. But things changed when the C++ standard committee decided to spin up the wheel. Since 2011, C++ has", "url": "https://www.freecodecamp.org/news/some-awesome-modern-c-features-that-every-developer-should-know-5e3bf6f79a3c/", "image": "https://cdn-media-1.freecodecamp.org/images/0*IttEgAi22EwkjY2h", "image:width": "800", "image:height": "482"}, "twitter": {"card": "summary_large_image", "title": "Some awesome modern C++ features that every developer should know", "description": "As a language, C++ has evolved a lot. Of course this did not happen overnight. There was a time when C++ lacked dynamism. It was difficult to be fond of the language. But things changed when the C++ standard committee decided to spin up the wheel. Since 2011, C++ has", "url": "https://www.freecodecamp.org/news/some-awesome-modern-c-features-that-every-developer-should-know-5e3bf6f79a3c/", "image": "https://cdn-media-1.freecodecamp.org/images/0*IttEgAi22EwkjY2h", "label1": "Written by", "data1": "M Chowdhury", "label2": "Filed under", "data2": "Programming, Coding, Tech, Software Development, Technology", "site": "@freecodecamp"}}}