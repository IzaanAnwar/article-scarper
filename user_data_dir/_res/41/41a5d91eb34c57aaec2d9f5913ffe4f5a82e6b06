{"title": "A variation on the Knapsack Problem: how to solve the Partition Equal Subset Sum problem in Java", "byline": "freeCodeCamp.org", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>A variation on the Knapsack Problem: how to solve the Partition Equal Subset Sum problem in Java</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>by Fabian Terh</p><p>Previously, I wrote about solving the Knapsack Problem (KP) with dynamic programming. <a href=\"https://medium.freecodecamp.org/how-to-solve-the-knapsack-problem-with-dynamic-programming-eb88c706d3cf\" rel=\"noopener\">You can read about it here</a>.</p><p>Today I want to discuss a variation of KP: the <a href=\"https://leetcode.com/problems/partition-equal-subset-sum/\" rel=\"noopener\">partition equal subset sum problem</a>. I first saw this problem on Leetcode \u2014 this was what prompted me to learn about, and write about, KP.</p><p>This is the problem statement (reproduced partially without examples):</p><blockquote>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</blockquote><p>For the full problem statement, with constraints and examples, check out the <a href=\"https://leetcode.com/problems/partition-equal-subset-sum/\" rel=\"noopener\">Leetcode problem</a>.</p><h3 id=\"dynamic-programming\">Dynamic programming</h3><p>Like with KP, we\u2019ll be solving this using dynamic programming. Since this is a variation of KP, the logic and methodology is largely similar.</p><h3 id=\"solution\">Solution</h3><p>We will house our solution in a method that returns a boolean \u2014 true if the array can be partitioned into equal subsets, and false otherwise.</p><h4 id=\"step-1-guarding-against-odd-array-sum\">Step 1: Guarding against odd array sum</h4><p>Trivially, if all the numbers in the array add up to an odd sum, we can return false. We only proceed if the array adds up to an even sum.</p><h4 id=\"step-2-creating-the-table\">Step 2: Creating the table</h4><p>Next, we create the table.</p><p>Table rows represent the set of array elements to be considered, while table columns indicate the sum we want to arrive at. Table values are simply boolean values, indicating whether a sum (column) can be arrived at with a set of array elements (row).</p><p>Concretely, row <em>i </em>represents a set of array elements from indices 0 to (<em>i</em>-1). The reason for this offset of 1 is because row 0 represents an empty set of elements. Therefore, row 1 represents the first array element (index 0), row 2 represents the first two array elements (indices 0\u20131), and so on. In total, we create <code>n + 1</code> rows, inclusive of 0.</p><p>We only want to know if we can sum up exactly to half the total sum of the array. So we only need to create <code>totalSum / 2 + 1</code> columns, inclusive of 0.</p><h4 id=\"step-3-pre-filling-the-table\">Step 3: Pre-filling the table</h4><p>We can immediately begin filling the entries for the base cases in our table \u2014 row 0 and column 0.</p><p>In the first row, every entry \u2014 except the first \u2014 must be <code>false</code>. Recall that the first row represents an empty set . Naturally, we are unable to arrive at any target sum \u2014 column number \u2014 except 0.</p><p>In the first column, every entry must be <code>true</code>. We can always,trivially, arrive at a target sum of 0, regardless of the set of elements we have to work with.</p><h4 id=\"step-4-building-the-table-the-crux-of-the-problem-\">Step 4: Building the table (the crux of the problem)</h4><p>Some entry in the table at row <em>i </em>and column <em>j</em> is <code>true</code> (attainable) if one of the following three conditions are satisfied:</p><ol><li>the entry at row <em>i</em>-1 and column <em>j</em> is <code>true</code>. Recall what the row number represents. Therefore, if we are able to attain a particular sum with a subset of the elements that we have presently, we can also attain that sum with our current set of elements \u2014 by simply not using the extra elements. This is trivial. Let\u2019s call this <code>prevRowIsTrue</code>.</li><li>The current element is exactly the sum we want to attain. This is also trivially true. Let\u2019s call this <code>isExactMatch</code>.</li><li>If the above two conditions are not satisfied, we have one remaining way of attaining our target sum. Here, we use the current element \u2014 the additional element in the set of elements in our current row compared to the set of elements in the previous row \u2014 and check that we are able to attain the remainder of the target sum. Let\u2019s call this <code>canArriveAtSum</code>.</li></ol><p>Let\u2019s unpack condition 3. We can only use the current element <strong>if </strong>it is less than our target sum. If they\u2019re equal, condition 2 would be satisfied. If it\u2019s larger, we can\u2019t use it. Therefore, the first step is to ensure that current element &lt; target sum.</p><p>After using our current element, we are left with the remainder of our target sum. We then check if that is attainable by checking the corresponding entry in the row above.</p><p>As with regular KP, we want to progressively build our table from the bottom-up. We start with the base cases, until we arrive at our final solution.</p><h4 id=\"step-5-returning-the-answer\">Step 5: Returning the answer</h4><p>We simply return <code>return mat[nums.length][totalSum / 2]</code>.</p><h3 id=\"working-code\">Working code</h3><p>Thanks for reading!</p>\n</section>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nby Fabian TerhPreviously, I wrote about solving the Knapsack Problem (KP) with dynamic programming. You can read about it here.Today I want to discuss a variation of KP: the partition equal subset sum problem. I first saw this problem on Leetcode \u2014 this was what prompted me to learn about, and write about, KP.This is the problem statement (reproduced partially without examples):Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.For the full problem statement, with constraints and examples, check out the Leetcode problem.Dynamic programmingLike with KP, we\u2019ll be solving this using dynamic programming. Since this is a variation of KP, the logic and methodology is largely similar.SolutionWe will house our solution in a method that returns a boolean \u2014 true if the array can be partitioned into equal subsets, and false otherwise.Step 1: Guarding against odd array sumTrivially, if all the numbers in the array add up to an odd sum, we can return false. We only proceed if the array adds up to an even sum.Step 2: Creating the tableNext, we create the table.Table rows represent the set of array elements to be considered, while table columns indicate the sum we want to arrive at. Table values are simply boolean values, indicating whether a sum (column) can be arrived at with a set of array elements (row).Concretely, row i represents a set of array elements from indices 0 to (i-1). The reason for this offset of 1 is because row 0 represents an empty set of elements. Therefore, row 1 represents the first array element (index 0), row 2 represents the first two array elements (indices 0\u20131), and so on. In total, we create n + 1 rows, inclusive of 0.We only want to know if we can sum up exactly to half the total sum of the array. So we only need to create totalSum / 2 + 1 columns, inclusive of 0.Step 3: Pre-filling the tableWe can immediately begin filling the entries for the base cases in our table \u2014 row 0 and column 0.In the first row, every entry \u2014 except the first \u2014 must be false. Recall that the first row represents an empty set . Naturally, we are unable to arrive at any target sum \u2014 column number \u2014 except 0.In the first column, every entry must be true. We can always,trivially, arrive at a target sum of 0, regardless of the set of elements we have to work with.Step 4: Building the table (the crux of the problem)Some entry in the table at row i and column j is true (attainable) if one of the following three conditions are satisfied:the entry at row i-1 and column j is true. Recall what the row number represents. Therefore, if we are able to attain a particular sum with a subset of the elements that we have presently, we can also attain that sum with our current set of elements \u2014 by simply not using the extra elements. This is trivial. Let\u2019s call this prevRowIsTrue.The current element is exactly the sum we want to attain. This is also trivially true. Let\u2019s call this isExactMatch.If the above two conditions are not satisfied, we have one remaining way of attaining our target sum. Here, we use the current element \u2014 the additional element in the set of elements in our current row compared to the set of elements in the previous row \u2014 and check that we are able to attain the remainder of the target sum. Let\u2019s call this canArriveAtSum.Let\u2019s unpack condition 3. We can only use the current element if it is less than our target sum. If they\u2019re equal, condition 2 would be satisfied. If it\u2019s larger, we can\u2019t use it. Therefore, the first step is to ensure that current element < target sum.After using our current element, we are left with the remainder of our target sum. We then check if that is attainable by checking the corresponding entry in the row above.As with regular KP, we want to progressively build our table from the bottom-up. We start with the base cases, until we arrive at our final solution.Step 5: Returning the answerWe simply return return mat[nums.length][totalSum / 2].Working codeThanks for reading!\n\n                        \n                    \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 4698, "excerpt": "by Fabian Terh\n\nPreviously, I wrote about solving the Knapsack Problem (KP) with dynamic\nprogramming. You can read about it here\n[https://medium.freecodecamp.org/how-to-solve-the-knapsack-problem-with-dynamic-programming-eb88c706d3cf]\n.\n\nToday I want to discuss a variation of KP: the partition equal subset sum\nproblem [https://leetcode.com/problems/partition-equal-subset-sum/]. I first saw\nthis problem on Leetcode \u2014 this was what prompted me to learn about, and write\nabout, KP.\n\nThis is the prob", "siteName": "freeCodeCamp.org", "publishedTime": "2019-05-10T16:53:32.000Z", "id": "41a5d91eb34c57aaec2d9f5913ffe4f5a82e6b06", "url": "https://www.freecodecamp.org/news/a-variation-on-the-knapsack-problem-how-to-solve-the-partition-equal-subset-sum-problem-in-java-7e0fc047f19b/", "domain": "freecodecamp.org", "date": "2023-12-27T18:10:08.857581", "resultUri": "http://localhost:3000/result/41a5d91eb34c57aaec2d9f5913ffe4f5a82e6b06", "query": {"url": ["https://www.freecodecamp.org/news/a-variation-on-the-knapsack-problem-how-to-solve-the-partition-equal-subset-sum-problem-in-java-7e0fc047f19b/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "A variation on the Knapsack Problem: how to solve the Partition Equal Subset Sum problem in Java", "description": "by Fabian Terh Previously, I wrote about solving the Knapsack Problem (KP) with dynamic programming. You can read about it here [https://medium.freecodecamp.org/how-to-solve-the-knapsack-problem-with-dynamic-programming-eb88c706d3cf] . Today I want to discuss a variation of KP: the partition equal subset sum problem [https://leetcode.com/problems/partition-equal-subset-sum/]. I first saw this problem on Leetcode \u2014 this was what", "url": "https://www.freecodecamp.org/news/a-variation-on-the-knapsack-problem-how-to-solve-the-partition-equal-subset-sum-problem-in-java-7e0fc047f19b/", "image": "https://cdn-media-1.freecodecamp.org/images/1*u-j8qYS9582smJPe1ZzNcw.jpeg", "image:width": "800", "image:height": "533"}, "twitter": {"card": "summary_large_image", "title": "A variation on the Knapsack Problem: how to solve the Partition Equal Subset Sum problem in Java", "description": "by Fabian Terh Previously, I wrote about solving the Knapsack Problem (KP) with dynamic programming. You can read about it here [https://medium.freecodecamp.org/how-to-solve-the-knapsack-problem-with-dynamic-programming-eb88c706d3cf] . Today I want to discuss a variation of KP: the partition equal subset sum problem [https://leetcode.com/problems/partition-equal-subset-sum/]. I first saw this problem on Leetcode \u2014 this was what", "url": "https://www.freecodecamp.org/news/a-variation-on-the-knapsack-problem-how-to-solve-the-partition-equal-subset-sum-problem-in-java-7e0fc047f19b/", "image": "https://cdn-media-1.freecodecamp.org/images/1*u-j8qYS9582smJPe1ZzNcw.jpeg", "label1": "Written by", "data1": "freeCodeCamp.org", "label2": "Filed under", "data2": "Programming, Algorithms, Dynamic Programming, Java, Tech", "site": "@freecodecamp"}}}