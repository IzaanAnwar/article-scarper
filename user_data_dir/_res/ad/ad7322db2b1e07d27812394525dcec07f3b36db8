{"title": "How to understand Scala variances by building restaurants", "byline": "Luca Florio", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>How to understand Scala variances by building restaurants</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>I understand that type variance is not fundamental to writing Scala code. It's been more or less a year since I've been using Scala for my day-to-day job, and honestly, I've never had to worry much about it.</p>\n<p>However, I think it is an interesting \"advanced\" topic, so I started to study it. It is not easy to grasp it immediately, but with the right example, it might be a little bit easier to understand. Let me try using a food-based analogy...</p>\n<h2 id=\"whatistypevariance\">What is type variance?</h2>\n<p>First of all, we have to define what type variance is. When you develop in an Object-Oriented language, you can define complex types. That means that a type may be parametrized using another type (component type).</p>\n<p>Think of <code>List</code> for example. You cannot define a <code>List</code> without specifying which types will be inside the list. You do it by putting the type contained in the list inside square brackets: <code>List[String]</code>. When you define a complex type, you can specify how it will vary its subtype relationship according to the relation between the component type and its subtypes.</p>\n<p>Ok, sounds like a mess... Let's get a little practical.</p>\n<h2 id=\"buildingarestaurantempire\">Building a restaurant empire</h2>\n<p>Our goal is to build an empire of restaurants. We want generic and specialised restaurants. Every restaurant we will open needs a menu composed of different recipes, and a (possibly) starred chef.</p>\n<p>The recipes can be composed of different kinds of food (fish, meat, white meat, vegetables, etc.), while the chef we hire has to be able to cook that kind of food. This is our model. Now it's coding time!</p>\n<h2 id=\"differenttypesoffood\">Different types of food</h2>\n<p>For our food-based example, we start by defining the <code>Trait Food</code>, providing just the name of the food.</p>\n<pre tabindex=\"0\"><code>trait Food {\n\n  def name: String\n\n}\n</code></pre>\n<p>Then we can create <code>Meat</code> and <code>Vegetable</code>, that are subclasses of <code>Food</code>.</p>\n<pre tabindex=\"0\"><code>class Meat(val name: String) extends Food\n</code></pre>\n<pre tabindex=\"0\"><code>class Vegetable(val name: String) extends Food\n</code></pre>\n<p>In the end, we define a <code>WhiteMeat</code> class that is a subclass of <code>Meat</code>.</p>\n<pre tabindex=\"0\"><code>class WhiteMeat(override val name: String) extends Meat(name)\n</code></pre>\n<p>Sounds reasonable right? So we have this hierarchy of types.</p>\n<p><img alt=\"food subtype relationship\" height=\"400\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2019/07/food_type_rel.png\" width=\"600\"/></p>\n<p>We can create some food instances of various type. They will be the ingredients of the recipes we are going to serve in our restaurants.</p>\n<pre tabindex=\"0\"><code>// Food &lt;- Meat\nval beef = new Meat(\"beef\")\n\n// Food &lt;- Meat &lt;- WhiteMeat\nval chicken = new WhiteMeat(\"chicken\")\nval turkey = new WhiteMeat(\"turkey\")\n\n// Food &lt;- Vegetable\nval carrot = new Vegetable(\"carrot\")\nval pumpkin = new Vegetable(\"pumpkin\")\n</code></pre>\n<h2 id=\"recipeacovarianttype\">Recipe, a covariant type</h2>\n<p>Let's define the covariant type <code>Recipe</code>. It takes a component type that expresses the base food for the recipe - that is, a recipe based on meat, vegetable, etc.</p>\n<pre tabindex=\"0\"><code>trait Recipe[+A] {\n\n  def name: String\n\n  def ingredients: List[A]\n\n}\n</code></pre>\n<p>The <code>Recipe</code> has a name and a list of ingredients. The list of ingredients has the same type of <code>Recipe</code>. To express that the <code>Recipe</code> is covariant in its type <code>A</code>, we write it as <code>Recipe[+A]</code>. The generic recipe is based on every kind of food, the meat recipe is based on meat, and a white meat recipe has just white meat in its list of ingredients.</p>\n<pre tabindex=\"0\"><code>case class GenericRecipe(ingredients: List[Food]) extends Recipe[Food] {\n\n  def name: String = s\"Generic recipe based on ${ingredients.map(_.name)}\"\n\n}\n</code></pre>\n<pre tabindex=\"0\"><code>case class MeatRecipe(ingredients: List[Meat]) extends Recipe[Meat] {\n\n  def name: String = s\"Meat recipe based on ${ingredients.map(_.name)}\"\n\n}\n</code></pre>\n<pre tabindex=\"0\"><code>case class WhiteMeatRecipe(ingredients: List[WhiteMeat]) extends Recipe[WhiteMeat] {\n\n  def name: String = s\"Meat recipe based on ${ingredients.map(_.name)}\"\n\n}\n</code></pre>\n<p>A type is covariant if it follows the same relationship of subtypes of its component type. This means that <code>Recipe</code> follows the same subtype relationship of its component Food.</p>\n<p><img alt=\"recipe subtype relationship\" height=\"400\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2019/07/recipe_type_rel-1.png\" width=\"600\"/></p>\n<p>Let's define some recipes that will be part of different menus.</p>\n<pre tabindex=\"0\"><code>// Recipe[Food]: Based on Meat or Vegetable\nval mixRecipe = new GenericRecipe(List(chicken, carrot, beef, pumpkin))\n// Recipe[Food] &lt;- Recipe[Meat]: Based on any kind of Meat\nval meatRecipe = new MeatRecipe(List(beef, turkey))\n// Recipe[Food] &lt;- Recipe[Meat] &lt;- Recipe[WhiteMeat]: Based only on WhiteMeat\nval whiteMeatRecipe = new WhiteMeatRecipe(List(chicken, turkey))\n</code></pre>\n<h2 id=\"chefacontravarianttype\">Chef, a contravariant type</h2>\n<p>We defined some recipes, but we need a chef to cook them. This gives us the chance to talk about contravariance. A type is contravariant if it follows an inverse relationship of subtypes of its component type. Let's define our complex type <code>Chef</code>, that is contravariant in the component type. The component type will be the food that the chef can cook.</p>\n<pre tabindex=\"0\"><code>trait Chef[-A] {\n  \n  def specialization: String\n\n  def cook(recipe: Recipe[A]): String\n}\n</code></pre>\n<p>A <code>Chef</code> has a specialisation and a method to cook a recipe based on a specific food. We express that it is contravariant writing it as <code>Chef[-A]</code>. Now we can create a chef able to cook generic food, a chef able to cook meat and a chef specialised on white meat.</p>\n<pre tabindex=\"0\"><code>class GenericChef extends Chef[Food] {\n\n  val specialization = \"All food\"\n\n  override def cook(recipe: Recipe[Food]): String = s\"I made a ${recipe.name}\"\n}\n</code></pre>\n<pre tabindex=\"0\"><code>class MeatChef extends Chef[Meat] {\n\n  val specialization = \"Meat\"\n\n  override def cook(recipe: Recipe[Meat]): String = s\"I made a ${recipe.name}\"\n}\n</code></pre>\n<pre tabindex=\"0\"><code>class WhiteMeatChef extends Chef[WhiteMeat] {\n\n  override val specialization = \"White meat\"\n\n  def cook(recipe: Recipe[WhiteMeat]): String = s\"I made a ${recipe.name}\"\n}\n</code></pre>\n<p>Since <code>Chef</code> is contravariant, <code>Chef[Food]</code> is a subclass of <code>Chef[Meat]</code> that is a subclass of <code>Chef[WhiteMeat]</code>. This means that the relationship between subtypes is the inverse of its component type Food.</p>\n<p><img alt=\"chef subtype relationship\" height=\"400\" loading=\"lazy\" src=\"https://www.freecodecamp.org/news/content/images/2019/07/chef_type_rel-1.png\" width=\"600\"/></p>\n<p>Ok, we can now define different chef with various specialization to hire in our restaurants.</p>\n<pre tabindex=\"0\"><code>// Chef[WhiteMeat]: Can cook only WhiteMeat\nval giuseppe = new WhiteMeatChef\ngiuseppe.cook(whiteMeatRecipe)\n\n// Chef[WhiteMeat] &lt;- Chef[Meat]: Can cook only Meat\nval alfredo = new MeatChef\nalfredo.cook(meatRecipe)\nalfredo.cook(whiteMeatRecipe)\n\n// Chef[WhiteMeat]&lt;- Chef[Meat] &lt;- Chef[Food]: Can cook any Food\nval mario = new GenericChef\nmario.cook(mixRecipe)\nmario.cook(meatRecipe)\nmario.cook(whiteMeatRecipe)\n</code></pre>\n<h2 id=\"restaurantwherethingscometogether\">Restaurant, where things come together</h2>\n<p>We have recipes, we have chefs, now we need a restaurant where the chef can cook a menu of recipes.</p>\n<pre tabindex=\"0\"><code>trait Restaurant[A] {\n\n  def menu: List[Recipe[A]]\n  def chef: Chef[A]\n\n  def cookMenu: List[String] = menu.map(chef.cook)\n}\n</code></pre>\n<p>We are not interested in the subtype relationship between restaurants, so we can define it as invariant. An invariant type does not follow the relationship between the subtypes of the component type. In other words, <code>Restaurant[Food]</code> is not a subclass or superclass of <code>Restaurant[Meat]</code>. They are simply unrelated.<br/>\nWe will have a <code>GenericRestaurant</code>, where you can eat different type of food. The <code>MeatRestaurant</code> is specialised in meat-based dished and the <code>WhiteMeatRestaurant</code> is specialised only in dishes based on white meat. Every restaurant to be instantiated needs a menu, that is a list of recipes, and a chef able to cook the recipes in the menu. Here is where the subtype relationship of <code>Recipe</code> and <code>Chef</code> comes into play.</p>\n<pre tabindex=\"0\"><code>case class GenericRestaurant(menu: List[Recipe[Food]], chef: Chef[Food]) extends Restaurant[Food]\n</code></pre>\n<pre tabindex=\"0\"><code>case class MeatRestaurant(menu: List[Recipe[Meat]], chef: Chef[Meat]) extends Restaurant[Meat]\n</code></pre>\n<pre tabindex=\"0\"><code>case class WhiteMeatRestaurant(menu: List[Recipe[WhiteMeat]], chef: Chef[WhiteMeat]) extends Restaurant[WhiteMeat]\n</code></pre>\n<p>Let's start defining some generic restaurants. In a generic restaurant, the menu is composed of recipes of various type of food. Since <code>Recipe</code> is covariant, a <code>GenericRecipe</code> is a superclass of <code>MeatRecipe</code> and <code>WhiteMeatRecipe</code>, so I can pass them to my <code>GenericRestaurant</code> instance. The thing is different for the chef. If the Restaurant requires a chef that can cook generic food, I cannot put in it a chef able to cook only a specific one. The class <code>Chef</code> is covariant, so <code>GenericChef</code> is a subclass of <code>MeatChef</code> that is a subclass of <code>WhiteMeatChef</code>. This implies that I cannot pass to my instance anything different from <code>GenericChef</code>.</p>\n<pre tabindex=\"0\"><code>val allFood = new GenericRestaurant(List(mixRecipe), mario)\nval foodParadise = new GenericRestaurant(List(meatRecipe), mario)\nval superFood = new GenericRestaurant(List(whiteMeatRecipe), mario)\n</code></pre>\n<p>The same goes for <code>MeatRestaurant</code> and <code>WhiteMeatRestaurant</code>. I can pass to the instance only a menu composed of more specific recipes then the required one, but chefs that can cook food more generic than the required one.</p>\n<pre tabindex=\"0\"><code>val meat4All = new MeatRestaurant(List(meatRecipe), alfredo)\nval meetMyMeat = new MeatRestaurant(List(whiteMeatRecipe), mario)\n</code></pre>\n<pre tabindex=\"0\"><code>val notOnlyChicken = new WhiteMeatRestaurant(List(whiteMeatRecipe), giuseppe)\nval whiteIsGood = new WhiteMeatRestaurant(List(whiteMeatRecipe), alfredo)\nval wingsLovers = new WhiteMeatRestaurant(List(whiteMeatRecipe), mario)\n</code></pre>\n<p>That's it, our empire of restaurants is ready to make tons of money!</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Ok guys, in this story I did my best to explain type variances in Scala. It is an advanced topic, but it is worth to know just out of curiosity. I hope that the restaurant example can be of help to make it more understandable. If something is not clear, or if I wrote something wrong (I'm still learning!) don't hesitate to leave a comment!</p>\n<p>See you! ?</p>\n<!--kg-card-end: markdown-->\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nI understand that type variance is not fundamental to writing Scala code. It's been more or less a year since I've been using Scala for my day-to-day job, and honestly, I've never had to worry much about it.\nHowever, I think it is an interesting \"advanced\" topic, so I started to study it. It is not easy to grasp it immediately, but with the right example, it might be a little bit easier to understand. Let me try using a food-based analogy...\nWhat is type variance?\nFirst of all, we have to define what type variance is. When you develop in an Object-Oriented language, you can define complex types. That means that a type may be parametrized using another type (component type).\nThink of List for example. You cannot define a List without specifying which types will be inside the list. You do it by putting the type contained in the list inside square brackets: List[String]. When you define a complex type, you can specify how it will vary its subtype relationship according to the relation between the component type and its subtypes.\nOk, sounds like a mess... Let's get a little practical.\nBuilding a restaurant empire\nOur goal is to build an empire of restaurants. We want generic and specialised restaurants. Every restaurant we will open needs a menu composed of different recipes, and a (possibly) starred chef.\nThe recipes can be composed of different kinds of food (fish, meat, white meat, vegetables, etc.), while the chef we hire has to be able to cook that kind of food. This is our model. Now it's coding time!\nDifferent types of food\nFor our food-based example, we start by defining the Trait Food, providing just the name of the food.\ntrait Food {\n\n  def name: String\n\n}\n\nThen we can create Meat and Vegetable, that are subclasses of Food.\nclass Meat(val name: String) extends Food\n\nclass Vegetable(val name: String) extends Food\n\nIn the end, we define a WhiteMeat class that is a subclass of Meat.\nclass WhiteMeat(override val name: String) extends Meat(name)\n\nSounds reasonable right? So we have this hierarchy of types.\n\nWe can create some food instances of various type. They will be the ingredients of the recipes we are going to serve in our restaurants.\n// Food <- Meat\nval beef = new Meat(\"beef\")\n\n// Food <- Meat <- WhiteMeat\nval chicken = new WhiteMeat(\"chicken\")\nval turkey = new WhiteMeat(\"turkey\")\n\n// Food <- Vegetable\nval carrot = new Vegetable(\"carrot\")\nval pumpkin = new Vegetable(\"pumpkin\")\n\nRecipe, a covariant type\nLet's define the covariant type Recipe. It takes a component type that expresses the base food for the recipe - that is, a recipe based on meat, vegetable, etc.\ntrait Recipe[+A] {\n\n  def name: String\n\n  def ingredients: List[A]\n\n}\n\nThe Recipe has a name and a list of ingredients. The list of ingredients has the same type of Recipe. To express that the Recipe is covariant in its type A, we write it as Recipe[+A]. The generic recipe is based on every kind of food, the meat recipe is based on meat, and a white meat recipe has just white meat in its list of ingredients.\ncase class GenericRecipe(ingredients: List[Food]) extends Recipe[Food] {\n\n  def name: String = s\"Generic recipe based on ${ingredients.map(_.name)}\"\n\n}\n\ncase class MeatRecipe(ingredients: List[Meat]) extends Recipe[Meat] {\n\n  def name: String = s\"Meat recipe based on ${ingredients.map(_.name)}\"\n\n}\n\ncase class WhiteMeatRecipe(ingredients: List[WhiteMeat]) extends Recipe[WhiteMeat] {\n\n  def name: String = s\"Meat recipe based on ${ingredients.map(_.name)}\"\n\n}\n\nA type is covariant if it follows the same relationship of subtypes of its component type. This means that Recipe follows the same subtype relationship of its component Food.\n\nLet's define some recipes that will be part of different menus.\n// Recipe[Food]: Based on Meat or Vegetable\nval mixRecipe = new GenericRecipe(List(chicken, carrot, beef, pumpkin))\n// Recipe[Food] <- Recipe[Meat]: Based on any kind of Meat\nval meatRecipe = new MeatRecipe(List(beef, turkey))\n// Recipe[Food] <- Recipe[Meat] <- Recipe[WhiteMeat]: Based only on WhiteMeat\nval whiteMeatRecipe = new WhiteMeatRecipe(List(chicken, turkey))\n\nChef, a contravariant type\nWe defined some recipes, but we need a chef to cook them. This gives us the chance to talk about contravariance. A type is contravariant if it follows an inverse relationship of subtypes of its component type. Let's define our complex type Chef, that is contravariant in the component type. The component type will be the food that the chef can cook.\ntrait Chef[-A] {\n  \n  def specialization: String\n\n  def cook(recipe: Recipe[A]): String\n}\n\nA Chef has a specialisation and a method to cook a recipe based on a specific food. We express that it is contravariant writing it as Chef[-A]. Now we can create a chef able to cook generic food, a chef able to cook meat and a chef specialised on white meat.\nclass GenericChef extends Chef[Food] {\n\n  val specialization = \"All food\"\n\n  override def cook(recipe: Recipe[Food]): String = s\"I made a ${recipe.name}\"\n}\n\nclass MeatChef extends Chef[Meat] {\n\n  val specialization = \"Meat\"\n\n  override def cook(recipe: Recipe[Meat]): String = s\"I made a ${recipe.name}\"\n}\n\nclass WhiteMeatChef extends Chef[WhiteMeat] {\n\n  override val specialization = \"White meat\"\n\n  def cook(recipe: Recipe[WhiteMeat]): String = s\"I made a ${recipe.name}\"\n}\n\nSince Chef is contravariant, Chef[Food] is a subclass of Chef[Meat] that is a subclass of Chef[WhiteMeat]. This means that the relationship between subtypes is the inverse of its component type Food.\n\nOk, we can now define different chef with various specialization to hire in our restaurants.\n// Chef[WhiteMeat]: Can cook only WhiteMeat\nval giuseppe = new WhiteMeatChef\ngiuseppe.cook(whiteMeatRecipe)\n\n// Chef[WhiteMeat] <- Chef[Meat]: Can cook only Meat\nval alfredo = new MeatChef\nalfredo.cook(meatRecipe)\nalfredo.cook(whiteMeatRecipe)\n\n// Chef[WhiteMeat]<- Chef[Meat] <- Chef[Food]: Can cook any Food\nval mario = new GenericChef\nmario.cook(mixRecipe)\nmario.cook(meatRecipe)\nmario.cook(whiteMeatRecipe)\n\nRestaurant, where things come together\nWe have recipes, we have chefs, now we need a restaurant where the chef can cook a menu of recipes.\ntrait Restaurant[A] {\n\n  def menu: List[Recipe[A]]\n  def chef: Chef[A]\n\n  def cookMenu: List[String] = menu.map(chef.cook)\n}\n\nWe are not interested in the subtype relationship between restaurants, so we can define it as invariant. An invariant type does not follow the relationship between the subtypes of the component type. In other words, Restaurant[Food] is not a subclass or superclass of Restaurant[Meat]. They are simply unrelated.\nWe will have a GenericRestaurant, where you can eat different type of food. The MeatRestaurant is specialised in meat-based dished and the WhiteMeatRestaurant is specialised only in dishes based on white meat. Every restaurant to be instantiated needs a menu, that is a list of recipes, and a chef able to cook the recipes in the menu. Here is where the subtype relationship of Recipe and Chef comes into play.\ncase class GenericRestaurant(menu: List[Recipe[Food]], chef: Chef[Food]) extends Restaurant[Food]\n\ncase class MeatRestaurant(menu: List[Recipe[Meat]], chef: Chef[Meat]) extends Restaurant[Meat]\n\ncase class WhiteMeatRestaurant(menu: List[Recipe[WhiteMeat]], chef: Chef[WhiteMeat]) extends Restaurant[WhiteMeat]\n\nLet's start defining some generic restaurants. In a generic restaurant, the menu is composed of recipes of various type of food. Since Recipe is covariant, a GenericRecipe is a superclass of MeatRecipe and WhiteMeatRecipe, so I can pass them to my GenericRestaurant instance. The thing is different for the chef. If the Restaurant requires a chef that can cook generic food, I cannot put in it a chef able to cook only a specific one. The class Chef is covariant, so GenericChef is a subclass of MeatChef that is a subclass of WhiteMeatChef. This implies that I cannot pass to my instance anything different from GenericChef.\nval allFood = new GenericRestaurant(List(mixRecipe), mario)\nval foodParadise = new GenericRestaurant(List(meatRecipe), mario)\nval superFood = new GenericRestaurant(List(whiteMeatRecipe), mario)\n\nThe same goes for MeatRestaurant and WhiteMeatRestaurant. I can pass to the instance only a menu composed of more specific recipes then the required one, but chefs that can cook food more generic than the required one.\nval meat4All = new MeatRestaurant(List(meatRecipe), alfredo)\nval meetMyMeat = new MeatRestaurant(List(whiteMeatRecipe), mario)\n\nval notOnlyChicken = new WhiteMeatRestaurant(List(whiteMeatRecipe), giuseppe)\nval whiteIsGood = new WhiteMeatRestaurant(List(whiteMeatRecipe), alfredo)\nval wingsLovers = new WhiteMeatRestaurant(List(whiteMeatRecipe), mario)\n\nThat's it, our empire of restaurants is ready to make tons of money!\nConclusion\nOk guys, in this story I did my best to explain type variances in Scala. It is an advanced topic, but it is worth to know just out of curiosity. I hope that the restaurant example can be of help to make it more understandable. If something is not clear, or if I wrote something wrong (I'm still learning!) don't hesitate to leave a comment!\nSee you! ?\n\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 9826, "excerpt": "I understand that type variance is not fundamental to writing Scala code. It's\nbeen more or less a year since I've been using Scala for my day-to-day job, and\nhonestly, I've never had to worry much about it.\n\nHowever, I think it is an interesting \"advanced\" topic, so I started to study\nit. It is not easy to grasp it immediately, but with the right example, it might\nbe a little bit easier to understand. Let me try using a food-based analogy...\n\nWhat is type variance?\nFirst of all, we have to defi", "siteName": "freeCodeCamp.org", "publishedTime": "2019-07-24T16:34:04.000Z", "id": "ad7322db2b1e07d27812394525dcec07f3b36db8", "url": "https://www.freecodecamp.org/news/understand-scala-variances-building-restaurants/", "domain": "freecodecamp.org", "date": "2023-12-27T18:08:52.857408", "resultUri": "http://localhost:3000/result/ad7322db2b1e07d27812394525dcec07f3b36db8", "query": {"url": ["https://www.freecodecamp.org/news/understand-scala-variances-building-restaurants/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "How to understand Scala variances by building restaurants", "description": "I understand that type variance is not fundamental to writing Scala code. It's been more or less a year since I've been using Scala for my day-to-day job, and honestly, I've never had to worry much about it. However, I think it is an interesting \"advanced\" topic, so I started", "url": "https://www.freecodecamp.org/news/understand-scala-variances-building-restaurants/", "image": "https://cdn-media-2.freecodecamp.org/w1280/5f9ca13e740569d1a4ca4d7c.jpg", "image:width": "1280", "image:height": "960"}, "twitter": {"card": "summary_large_image", "title": "How to understand Scala variances by building restaurants", "description": "I understand that type variance is not fundamental to writing Scala code. It's been more or less a year since I've been using Scala for my day-to-day job, and honestly, I've never had to worry much about it. However, I think it is an interesting \"advanced\" topic, so I started", "url": "https://www.freecodecamp.org/news/understand-scala-variances-building-restaurants/", "image": "https://cdn-media-2.freecodecamp.org/w1280/5f9ca13e740569d1a4ca4d7c.jpg", "label1": "Written by", "data1": "Luca Florio", "label2": "Filed under", "data2": "Scala, Variance, covariant, contravariant, invariant, Programming", "site": "@freecodecamp", "creator": "@elleFlorio"}}}