{"title": "How to print newlines in command line output", "byline": "Victoria Drake", "dir": null, "lang": "en", "content": "<div class=\"page\" id=\"readability-page-1\"><div id=\"site-main\">\n<article><h1>How to print newlines in command line output</h1>\n<section>\n<section data-test-label=\"post-content\">\n<p>Surprisingly, getting computers to give humans readable output is no easy feat. With the introduction of <a href=\"https://en.wikipedia.org/wiki/Standard_streams\">standard streams</a> and specifically standard output, programs gained a way to talk to each other using plain text streams. But humanizing and displaying stdout is another matter. Technology throughout the computing age has tried to solve this problem, from the use of <a href=\"https://en.wikipedia.org/wiki/Computer_terminal#Early_VDUs\">ASCII characters in video computer displays</a> to modern shell commands like <code>echo</code> and <code>printf</code>.</p><p>These advancements have not been seamless. The job of printing output to a terminal is fraught with quirks for programmers to navigate, as exemplified by the deceptively nontrivial task of expanding an <a href=\"https://en.wikipedia.org/wiki/Escape_sequence\">escape sequence</a> to print newlines. The expansion of the placeholder <code>\\n</code> can be accomplished in a multitude of ways, each with its own unique history and complications.</p><h2 id=\"using-echo\">Using <code>echo</code></h2><p>From its appearance in <a href=\"https://en.wikipedia.org/wiki/Multics\">Multics</a> to its modern-day Unix-like system ubiquity, <code>echo</code> remains a familiar tool for getting your terminal to say \u201cHello world!\u201d Unfortunately, inconsistent implementations across operating systems make its usage tricky. Where <code>echo</code> on some systems will automatically expand escape sequences, <a href=\"https://man.cat-v.org/unix_8th/1/echo\">others</a> require a <code>-e</code> option to do the same:</p><pre tabindex=\"0\"><code>echo \"the study of European nerves is \\neurology\"\n# the study of European nerves is \\neurology\n\necho -e \"the study of European nerves is \\neurology\"\n# the study of European nerves is \n# eurology</code></pre><p>Because of these inconsistencies in implementations, <code>echo</code> is considered non-portable. Additionally, its usage in conjunction with user input is relatively easy to corrupt through <a href=\"https://en.wikipedia.org/wiki/Code_injection#Shell_injection\">shell injection attack</a> using command substitutions.</p><p>In modern systems, it is retained only to provide compatibility with the many programs that still use it. The <a href=\"https://pubs.opengroup.org/onlinepubs/9699919799/utilities/echo.html#tag_20_37_16\">POSIX specification recommends</a> the use of <code>printf</code> in new programs.</p><h2 id=\"using-printf\">Using <code>printf</code></h2><p>Since 4th <a href=\"https://en.wikipedia.org/wiki/Research_Unix#Versions\">Edition</a> Unix, the portable <a href=\"https://en.wikipedia.org/wiki/Printf_(Unix)\"><code>printf</code> command</a> has essentially been the new and better <code>echo</code>. It allows you to use <a href=\"https://en.wikipedia.org/wiki/Printf_format_string#Format_placeholder_specification\">format specifiers</a> to humanize input. To interpret backslash escape sequences, use <code>%b</code>. The character sequence <code>\\n</code> ensures the output ends with a newline:</p><pre tabindex=\"0\"><code>printf \"%b\\n\" \"Many females in Oble are \\noblewomen\"\n# Many females in Oble are \n# oblewomen</code></pre><p>Though <code>printf</code> has further options that make it a far more powerful replacement of <code>echo</code>, this utility is not foolproof and can be vulnerable to an <a href=\"https://en.wikipedia.org/wiki/Uncontrolled_format_string\">uncontrolled format string</a> attack. It\u2019s important for programmers to ensure they <a href=\"https://victoria.dev/blog/sql-injection-and-xss-what-white-hat-hackers-know-about-trusting-user-input/\">carefully handle user input</a>.</p><h2 id=\"putting-newlines-in-variables\">Putting newlines in variables</h2><p>In an effort to improve portability amongst compilers, the <a href=\"https://en.wikipedia.org/wiki/ANSI_C\">ANSI C Standard</a> was established in 1983. With <a href=\"https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html#ANSI_002dC-Quoting\">ANSI-C quoting</a> using <code>$'...'</code>, <a href=\"https://en.wikipedia.org/wiki/Escape_sequences_in_C#Table_of_escape_sequences\">escape sequences</a> are replaced in output according to the standard.</p><p>This allows us to store strings with newlines in variables that are printed with the newlines interpreted. You can do this by setting the variable, then calling it with <code>printf</code> using <code>$</code>:</p><pre tabindex=\"0\"><code>puns=$'\\number\\narrow\\nether\\nice'\n\nprintf \"%b\\n\" \"These words started with n but don't make $puns\"\n\n# These words started with n but don't make \n# umber\n# arrow\n# ether\n# ice</code></pre><p>The expanded variable is single-quoted, which is passed literally to <code>printf</code>. As always, it is important to properly handle the input.</p><h2 id=\"bonus-round-shell-parameter-expansion\">Bonus round: shell parameter expansion</h2><p>In my article explaining <a href=\"https://victoria.dev/blog/bash-and-shell-expansions-lazy-list-making/\">Bash and braces</a>, I covered the magic of <a href=\"https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html\">shell parameter expansion</a>. We can use one expansion, <code>${parameter@operator}</code>, to interpret escape sequences, too. We use <code>printf</code>\u2019s <code>%s</code> specifier to print as a string, and the <code>E</code> operator will properly expand the escape sequences in our variable:</p><pre tabindex=\"0\"><code>printf \"%s\\n\" ${puns@E}\n\n# umber\n# arrow\n# ether\n# ice</code></pre><h2 id=\"the-ongoing-challenge-of-talking-in-human\">The ongoing challenge of talking in human</h2><p><a href=\"https://en.wikipedia.org/wiki/String_interpolation\">String interpolation</a> continues to be a chewy problem for programmers. Besides getting \u00a0languages and shells to agree on what certain placeholders mean, properly using the correct escape sequences requires an eye for detail.</p><p>Poor string interpolation can lead to silly-looking output, as well as introduce security vulnerabilities, such as from <a href=\"https://en.wikipedia.org/wiki/Code_injection\">injection attacks</a>. Until the next evolution of the terminal has us talking in emojis, we\u2019d best pay attention when printing output for humans.</p>\n</section>\n<hr/>\n<hr/>\n<p>\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. <a href=\"https://www.freecodecamp.org/learn/\" id=\"learn-to-code-cta\" rel=\"noopener noreferrer\" target=\"_blank\">Get started</a>\n</p>\n</section>\n</article>\n</div></div>", "textContent": "\n            \n                \n                \n                \n                    \n                \n                \n                    \n                            \nSurprisingly, getting computers to give humans readable output is no easy feat. With the introduction of standard streams and specifically standard output, programs gained a way to talk to each other using plain text streams. But humanizing and displaying stdout is another matter. Technology throughout the computing age has tried to solve this problem, from the use of ASCII characters in video computer displays to modern shell commands like echo and printf.These advancements have not been seamless. The job of printing output to a terminal is fraught with quirks for programmers to navigate, as exemplified by the deceptively nontrivial task of expanding an escape sequence to print newlines. The expansion of the placeholder \\n can be accomplished in a multitude of ways, each with its own unique history and complications.Using echoFrom its appearance in Multics to its modern-day Unix-like system ubiquity, echo remains a familiar tool for getting your terminal to say \u201cHello world!\u201d Unfortunately, inconsistent implementations across operating systems make its usage tricky. Where echo on some systems will automatically expand escape sequences, others require a -e option to do the same:echo \"the study of European nerves is \\neurology\"\n# the study of European nerves is \\neurology\n\necho -e \"the study of European nerves is \\neurology\"\n# the study of European nerves is \n# eurologyBecause of these inconsistencies in implementations, echo is considered non-portable. Additionally, its usage in conjunction with user input is relatively easy to corrupt through shell injection attack using command substitutions.In modern systems, it is retained only to provide compatibility with the many programs that still use it. The POSIX specification recommends the use of printf in new programs.Using printfSince 4th Edition Unix, the portable printf command has essentially been the new and better echo. It allows you to use format specifiers to humanize input. To interpret backslash escape sequences, use %b. The character sequence \\n ensures the output ends with a newline:printf \"%b\\n\" \"Many females in Oble are \\noblewomen\"\n# Many females in Oble are \n# oblewomenThough printf has further options that make it a far more powerful replacement of echo, this utility is not foolproof and can be vulnerable to an uncontrolled format string attack. It\u2019s important for programmers to ensure they carefully handle user input.Putting newlines in variablesIn an effort to improve portability amongst compilers, the ANSI C Standard was established in 1983. With ANSI-C quoting using $'...', escape sequences are replaced in output according to the standard.This allows us to store strings with newlines in variables that are printed with the newlines interpreted. You can do this by setting the variable, then calling it with printf using $:puns=$'\\number\\narrow\\nether\\nice'\n\nprintf \"%b\\n\" \"These words started with n but don't make $puns\"\n\n# These words started with n but don't make \n# umber\n# arrow\n# ether\n# iceThe expanded variable is single-quoted, which is passed literally to printf. As always, it is important to properly handle the input.Bonus round: shell parameter expansionIn my article explaining Bash and braces, I covered the magic of shell parameter expansion. We can use one expansion, ${parameter@operator}, to interpret escape sequences, too. We use printf\u2019s %s specifier to print as a string, and the E operator will properly expand the escape sequences in our variable:printf \"%s\\n\" ${puns@E}\n\n# umber\n# arrow\n# ether\n# iceThe ongoing challenge of talking in humanString interpolation continues to be a chewy problem for programmers. Besides getting \u00a0languages and shells to agree on what certain placeholders mean, properly using the correct escape sequences requires an eye for detail.Poor string interpolation can lead to silly-looking output, as well as introduce security vulnerabilities, such as from injection attacks. Until the next evolution of the terminal has us talking in emojis, we\u2019d best pay attention when printing output for humans.\n\n                        \n                    \n                    \n                        \n                        \n                    \n\n                    \n                    \n                        \n    \n\n\n\n\n\n    \n    \n\n\n                        \n\n\n        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started\n    \n\n                    \n                \n                \n                    \n                \n            \n        ", "length": 4757, "excerpt": "Surprisingly, getting computers to give humans readable output is no easy feat.\nWith the introduction of standard streams\n[https://en.wikipedia.org/wiki/Standard_streams] and specifically standard\noutput, programs gained a way to talk to each other using plain text streams.\nBut humanizing and displaying stdout is another matter. Technology throughout\nthe computing age has tried to solve this problem, from the use of ASCII\ncharacters in video computer displays\n[https://en.wikipedia.org/wiki/Compu", "siteName": "freeCodeCamp.org", "publishedTime": "2019-12-05T14:02:00.000Z", "id": "6985d94fc85b23eca57d102a0a04d8d893f8557c", "url": "https://www.freecodecamp.org/news/how-print-newlines-command-line-output/", "domain": "freecodecamp.org", "date": "2023-12-27T18:08:25.970780", "resultUri": "http://localhost:3000/result/6985d94fc85b23eca57d102a0a04d8d893f8557c", "query": {"url": ["https://www.freecodecamp.org/news/how-print-newlines-command-line-output/"]}, "meta": {"og": {"site_name": "freeCodeCamp.org", "type": "article", "title": "How to print newlines in command line output", "description": "Surprisingly, getting computers to give humans readable output is no easy feat. With the introduction of standard streams [https://en.wikipedia.org/wiki/Standard_streams] and specifically standard output, programs gained a way to talk to each other using plain text streams. But humanizing and displaying stdout is another matter. Technology throughout the computing age has", "url": "https://www.freecodecamp.org/news/how-print-newlines-command-line-output/", "image": "https://www.freecodecamp.org/news/content/images/2019/12/cover.png", "image:width": "2000", "image:height": "800"}, "twitter": {"card": "summary_large_image", "title": "How to print newlines in command line output", "description": "Surprisingly, getting computers to give humans readable output is no easy feat. With the introduction of standard streams [https://en.wikipedia.org/wiki/Standard_streams] and specifically standard output, programs gained a way to talk to each other using plain text streams. But humanizing and displaying stdout is another matter. Technology throughout the computing age has", "url": "https://www.freecodecamp.org/news/how-print-newlines-command-line-output/", "image": "https://www.freecodecamp.org/news/content/images/2019/12/cover.png", "label1": "Written by", "data1": "Victoria Drake", "label2": "Filed under", "data2": "Terminal, Bash, Linux, C Programming, Programming", "site": "@freecodecamp", "creator": "@victoriadotdev"}}}